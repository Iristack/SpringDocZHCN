Spring Security 的 `JdbcDaoImpl` 实现了
[`UserDetailsService`](servlet/authentication/passwords/user-details-service.xml#servlet-authentication-userdetailsservice)，以支持基于用户名和密码的认证，这些信息通过
JDBC 查询获取。 `JdbcUserDetailsManager` 继承自 `JdbcDaoImpl`，并通过
`UserDetailsManager` 接口提供对 `UserDetails` 的管理功能。 当 Spring
Security 被配置为
[接受用户名/密码](servlet/authentication/passwords/index.xml#servlet-authentication-unpwd-input)
进行认证时，就会使用基于 `UserDetails` 的认证方式。

在接下来的章节中，我们将讨论以下内容：

- Spring Security JDBC 认证所使用的
  [默认数据库结构](#servlet-authentication-jdbc-schema)

- [数据源配置](#servlet-authentication-jdbc-datasource)

- [JdbcUserDetailsManager Bean 配置](#servlet-authentication-jdbc-bean)

# 默认数据库结构 {#servlet-authentication-jdbc-schema}

Spring Security 提供了用于基于 JDBC 认证的默认查询语句。
本节介绍与这些默认查询对应的数据库表结构。你需要根据自定义查询以及所使用的数据库方言调整该结构。

## 用户表结构 {#servlet-authentication-jdbc-schema-user}

`JdbcDaoImpl`
需要数据库表来加载用户的密码、账户状态（启用或禁用）以及用户的角色权限列表（authorities）。

:::: note
::: title
:::

默认的数据库结构也作为一个类路径资源文件提供，名称为：`org/springframework/security/core/userdetails/jdbc/users.ddl`。
::::

:::: formalpara
::: title
默认用户表结构
:::

``` sql
create table users(
    username varchar_ignorecase(50) not null primary key,
    password varchar_ignorecase(500) not null,
    enabled boolean not null
);

create table authorities (
    username varchar_ignorecase(50) not null,
    authority varchar_ignorecase(50) not null,
    constraint fk_authorities_users foreign key(username) references users(username)
);
create unique index ix_auth_username on authorities (username,authority);
```
::::

Oracle 是一个常用的数据库，但其结构略有不同：

:::: formalpara
::: title
Oracle 数据库的默认用户表结构
:::

``` sql
CREATE TABLE USERS (
    USERNAME NVARCHAR2(128) PRIMARY KEY,
    PASSWORD NVARCHAR2(128) NOT NULL,
    ENABLED CHAR(1) CHECK (ENABLED IN ('Y','N') ) NOT NULL
);


CREATE TABLE AUTHORITIES (
    USERNAME NVARCHAR2(128) NOT NULL,
    AUTHORITY NVARCHAR2(128) NOT NULL
);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_UNIQUE UNIQUE (USERNAME, AUTHORITY);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_FK1 FOREIGN KEY (USERNAME) REFERENCES USERS (USERNAME) ENABLE;
```
::::

## 分组表结构 {#servlet-authentication-jdbc-schema-group}

如果你的应用使用了用户组功能，则还需要提供以下分组相关的表结构：

:::: formalpara
::: title
默认分组表结构
:::

``` sql
create table groups (
    id bigint generated by default as identity(start with 0) primary key,
    group_name varchar_ignorecase(50) not null
);

create table group_authorities (
    group_id bigint not null,
    authority varchar(50) not null,
    constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);

create table group_members (
    id bigint generated by default as identity(start with 0) primary key,
    username varchar(50) not null,
    group_id bigint not null,
    constraint fk_group_members_group foreign key(group_id) references groups(id)
);
```
::::

# 配置 DataSource {#servlet-authentication-jdbc-datasource}

在配置 `JdbcUserDetailsManager` 之前，我们必须先创建一个 `DataSource`。
在本示例中，我们设置了一个
[嵌入式数据源](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html#jdbc-embedded-database-support)，并使用上面的
[默认用户表结构](#servlet-authentication-jdbc-schema) 初始化它。

:::: example
::: title
嵌入式数据源配置
:::

Java

:   ``` java
    @Bean
    DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(H2)
            .addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION)
            .build();
    }
    ```

XML

:   ``` xml
    <jdbc:embedded-database>
        <jdbc:script location="classpath:org/springframework/security/core/userdetails/jdbc/users.ddl"/>
    </jdbc:embedded-database>
    ```

Kotlin

:   ``` kotlin
    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
            .setType(H2)
            .addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION)
            .build()
    }
    ```
::::

在生产环境中，你需要确保配置连接到外部数据库的数据源。

# JdbcUserDetailsManager Bean {#servlet-authentication-jdbc-bean}

在这个示例中，我们使用 [Spring Boot
CLI](features/authentication/password-storage.xml#authentication-password-storage-boot-cli)
对明文密码 `password`
进行编码，得到加密后的结果：`{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW`。
有关密码存储的更多细节，请参阅
[PasswordEncoder](features/authentication/password-storage.xml#authentication-password-storage)
章节。

:::: example
::: title
JdbcUserDetailsManager 配置
:::

Java

:   ``` java
    @Bean
    UserDetailsManager users(DataSource dataSource) {
        UserDetails user = User.builder()
            .username("user")
            .password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
            .roles("USER")
            .build();
        UserDetails admin = User.builder()
            .username("admin")
            .password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
            .roles("USER", "ADMIN")
            .build();
        JdbcUserDetailsManager users = new JdbcUserDetailsManager(dataSource);
        users.createUser(user);
        users.createUser(admin);
        return users;
    }
    ```

XML

:   ``` xml
    <jdbc-user-service>
        <user name="user"
            password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
            authorities="ROLE_USER" />
        <user name="admin"
            password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
            authorities="ROLE_USER,ROLE_ADMIN" />
    </jdbc-user-service>
    ```

Kotlin

:   ``` kotlin
    @Bean
    fun users(dataSource: DataSource): UserDetailsManager {
        val user = User.builder()
                .username("user")
                .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
                .roles("USER")
                .build();
        val admin = User.builder()
                .username("admin")
                .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
                .roles("USER", "ADMIN")
                .build();
        val users = JdbcUserDetailsManager(dataSource)
        users.createUser(user)
        users.createUser(admin)
        return users
    }
    ```
::::
