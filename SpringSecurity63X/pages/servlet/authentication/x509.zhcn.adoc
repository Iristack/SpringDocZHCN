[[servlet-x509]]
= X.509 认证

[[x509-overview]]
X.509 证书认证最常见的用途是在使用 SSL（最常见的是通过浏览器使用 HTTPS）时验证服务器的身份。  
浏览器会自动检查服务器提供的证书是否由其维护的受信任证书颁发机构列表中的某个机构签发（即数字签名）。

你也可以使用带有“**双向认证**”（mutual authentication）的 SSL。在这种情况下，服务器会在 SSL 握手过程中向客户端请求一个有效的证书。  
服务器通过检查该证书是否由可接受的权威机构签发来对客户端进行身份验证。  
如果提供了有效证书，则可以通过 Servlet API 在应用程序中获取该证书。  
例如，如果你使用的是 Tomcat，请先阅读 https://tomcat.apache.org/tomcat-10.1-doc/ssl-howto.html[Tomcat SSL 使用指南]。  
在尝试与 Spring Security 集成之前，你应该先确保 SSL 双向认证能够正常工作。

Spring Security 的 X.509 模块通过一个过滤器提取客户端证书，  
并将该证书映射到一个应用用户，然后加载该用户的权限集合，以便与标准的 Spring Security 基础设施集成使用。

== 将 X.509 认证添加到你的 Web 应用程序

启用 X.509 客户端认证非常简单。  
只需将 `<x509/>` 元素添加到你的 `http` 安全命名空间配置中：

[source,xml]
----
<http>
...
	<x509 subject-principal-regex="CN=(.*?)," user-service-ref="userService"/>
</http>
----

该元素有两个可选属性：

* `subject-principal-regex`：用于从证书的“主题名称”（Subject Name）中提取用户名的正则表达式。  
  默认值如上所示。这个提取出的用户名会被传递给 `UserDetailsService`，以加载该用户的权限信息。
  
* `user-service-ref`：指定用于 X.509 认证的 `UserDetailsService` Bean ID。  
  如果你的应用上下文中只定义了一个 `UserDetailsService`，则无需设置此属性。

`subject-principal-regex` 应包含一个捕获组。  
例如，默认表达式 `CN=(.*?)` 匹配的是“通用名”（Common Name）字段。  
因此，如果证书中的主题名称为 `"CN=Jimi Hendrix, OU=..."`，那么提取出的用户名就是 `"Jimi Hendrix"`。  
匹配过程是不区分大小写的。  
所以，表达式 `emailAddress=(.+?+),` 可以匹配 `"EMAILADDRESS=jimi@hendrix.org,CN=..."`，从而得到用户名 `"jimi@hendrix.org"`。

如果客户端提供了证书，并且成功提取出了有效的用户名，则安全上下文中应当包含一个有效的 `Authentication` 对象。  
如果未找到证书，或无法找到对应的用户，则安全上下文保持为空。  
这意味着你可以将 X.509 认证与其他认证方式（如基于表单的登录）结合使用。

[[x509-ssl-config]]
== 在 Tomcat 中配置 SSL

在 {gh-samples-url}/servlet/java-configuration/authentication/x509/server[Spring Security 示例仓库] 中提供了一些预生成的证书。  
如果你不想自己生成证书，可以使用这些证书来进行测试。  
`server.jks` 文件包含了服务器证书、私钥以及签发机构的证书。  
此外还提供了一些示例用户的客户端证书文件，你可以将这些证书导入浏览器，以启用 SSL 客户端认证。

要在 Tomcat 中启用 SSL 支持，请将 `server.jks` 文件复制到 Tomcat 的 `conf` 目录下，  
并在 `server.xml` 文件中添加以下连接器配置：

[source,xml]
----
<Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true" scheme="https" secure="true"
			clientAuth="true" sslProtocol="TLS"
			keystoreFile="${catalina.home}/conf/server.jks"
			keystoreType="JKS" keystorePass="password"
			truststoreFile="${catalina.home}/conf/server.jks"
			truststoreType="JKS" truststorePass="password"
/>
----

其中 `clientAuth` 还可以设置为 `"want"`，表示即使客户端未提供证书，SSL 连接仍然可以建立。  
但在此模式下，未能提供证书的客户端将无法访问任何由 Spring Security 保护的资源，除非你同时配置了非 X.509 的认证机制（如表单登录）。