[[oauth2Client-core-interface-class]]
= 核心接口与类

本节介绍 Spring Security 提供的 OAuth2 核心接口和类。

[[oauth2Client-client-registration]]
== ClientRegistration

`ClientRegistration` 是表示在 OAuth 2.0 或 OpenID Connect 1.0 提供商注册的客户端。

一个 `ClientRegistration` 对象包含如下信息：客户端 ID、客户端密钥、授权授予类型、重定向 URI、作用域（scopes）、授权 URI、令牌 URI以及其他详细信息。

`ClientRegistration` 及其属性定义如下：

[source,java]
----
public final class ClientRegistration {
	private String registrationId;	<1>
	private String clientId;	<2>
	private String clientSecret;	<3>
	private ClientAuthenticationMethod clientAuthenticationMethod;	<4>
	private AuthorizationGrantType authorizationGrantType;	<5>
	private String redirectUri;	<6>
	private Set<String> scopes;	<7>
	private ProviderDetails providerDetails;
	private String clientName;	<8>

	public class ProviderDetails {
		private String authorizationUri;	<9>
		private String tokenUri;	<10>
		private UserInfoEndpoint userInfoEndpoint;
		private String jwkSetUri;	<11>
		private String issuerUri;	<12>
        private Map<String, Object> configurationMetadata;  <13>

		public class UserInfoEndpoint {
			private String uri;	<14>
            private AuthenticationMethod authenticationMethod;  <15>
			private String userNameAttributeName;	<16>

		}
	}
}
----
<1> `registrationId`：唯一标识 `ClientRegistration` 的 ID。
<2> `clientId`：客户端标识符。
<3> `clientSecret`：客户端密钥。
<4> `clientAuthenticationMethod`：客户端用于向提供商进行身份验证的方法。支持的值包括 *client_secret_basic*、*client_secret_post*、*private_key_jwt*、*client_secret_jwt* 和 *none* https://tools.ietf.org/html/rfc6749#section-2.1[（公共客户端）]。
<5> `authorizationGrantType`：OAuth 2.0 授权框架定义了四种 https://tools.ietf.org/html/rfc6749#section-1.3[授权授予类型]。支持的值包括 `authorization_code`、`client_credentials`、`password`，以及扩展授予类型 `urn:ietf:params:oauth:grant-type:jwt-bearer`。
<6> `redirectUri`：客户端注册的重定向 URI，_授权服务器_ 在用户完成身份验证并授权访问客户端后，将最终用户的用户代理重定向到该 URI。
<7> `scopes`：客户端在授权请求流程中请求的作用域，例如 openid、email 或 profile。
<8> `clientName`：客户端的描述性名称。该名称可能在某些场景下使用，例如在自动生成的登录页面上显示客户端名称。
<9> `authorizationUri`：授权服务器的授权端点 URI。
<10> `tokenUri`：授权服务器的令牌端点 URI。
<11> `jwkSetUri`：用于从授权服务器检索 https://tools.ietf.org/html/rfc7517[JSON Web Key (JWK)] 集合的 URI，其中包含用于验证 ID Token 以及（可选）UserInfo 响应的 https://tools.ietf.org/html/rfc7515[JSON Web Signature (JWS)] 的加密密钥。
<12> `issuerUri`：OpenID Connect 1.0 提供商或 OAuth 2.0 授权服务器的发行者标识符 URI。
<13> `configurationMetadata`：https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[OpenID 提供商配置信息]。只有当 Spring Boot 属性 `spring.security.oauth2.client.provider.[providerId].issuerUri` 被配置时，此信息才可用。
<14> `(userInfoEndpoint)uri`：用于访问已认证最终用户的声明和属性的 UserInfo 端点 URI。
<15> `(userInfoEndpoint)authenticationMethod`：向 UserInfo 端点发送访问令牌时使用的身份验证方法。支持的值为 *header*、*form* 和 *query*。
<16> `userNameAttributeName`：UserInfo 响应中返回的属性名称，该属性引用最终用户的名称或标识符。

您最初可以通过发现 OpenID Connect 提供商的 https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[配置端点] 或授权服务器的 https://tools.ietf.org/html/rfc8414#section-3[元数据端点] 来配置 `ClientRegistration`。

`ClientRegistrations` 提供了以这种方式配置 `ClientRegistration` 的便捷方法，如下所示：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
ClientRegistration clientRegistration =
    ClientRegistrations.fromIssuerLocation("https://idp.example.com/issuer").build();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val clientRegistration = ClientRegistrations.fromIssuerLocation("https://idp.example.com/issuer").build()
----
======

上述代码按顺序依次查询 `https://idp.example.com/issuer/.well-known/openid-configuration`、`https://idp.example.com/.well-known/openid-configuration/issuer` 和 `https://idp.example.com/.well-known/oauth-authorization-server/issuer`，并在第一个返回 200 响应时停止。

作为替代方案，您可以使用 `ClientRegistrations.fromOidcIssuerLocation()` 仅查询 OpenID Connect 提供商的配置端点。

[[oauth2Client-client-registration-repo]]
== ClientRegistrationRepository

`ClientRegistrationRepository` 用作 OAuth 2.0 / OpenID Connect 1.0 `ClientRegistration`(s) 的存储库。

[NOTE]
====
客户端注册信息最终由关联的授权服务器存储和管理。该存储库提供了检索部分主要客户端注册信息的能力，这些信息存储在授权服务器中。
====

Spring Boot 自动配置将 `spring.security.oauth2.client.registration._[registrationId]_` 下的每个属性绑定到 `ClientRegistration` 实例，并将每个 `ClientRegistration` 实例组合到 `ClientRegistrationRepository` 中。

[NOTE]
====
`ClientRegistrationRepository` 的默认实现是 `InMemoryClientRegistrationRepository`。
====

自动配置还会将 `ClientRegistrationRepository` 注册为 `ApplicationContext` 中的一个 `@Bean`，以便在应用程序需要时可通过依赖注入使用。

以下示例展示了一个例子：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Controller
public class OAuth2ClientController {

	@Autowired
	private ClientRegistrationRepository clientRegistrationRepository;

	@GetMapping("/")
	public String index() {
		ClientRegistration oktaRegistration =
			this.clientRegistrationRepository.findByRegistrationId("okta");

		...

		return "index";
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Controller
class OAuth2ClientController {

    @Autowired
    private lateinit var clientRegistrationRepository: ClientRegistrationRepository

    @GetMapping("/")
    fun index(): String {
        val oktaRegistration =
                this.clientRegistrationRepository.findByRegistrationId("okta")

        //...

        return "index";
    }
}
----
======

[[oauth2Client-authorized-client]]
== OAuth2AuthorizedClient

`OAuth2AuthorizedClient` 表示一个已授权的客户端。当资源所有者（即最终用户）已授予客户端访问其受保护资源的权限时，该客户端被视为已授权。

`OAuth2AuthorizedClient` 的作用是将 `OAuth2AccessToken`（以及可选的 `OAuth2RefreshToken`）与 `ClientRegistration`（客户端）和资源所有者（即授予授权的 `Principal` 最终用户）关联起来。

[[oauth2Client-authorized-repo-service]]
== OAuth2AuthorizedClientRepository 和 OAuth2AuthorizedClientService

`OAuth2AuthorizedClientRepository` 负责在 Web 请求之间持久化 `OAuth2AuthorizedClient`(s)，而 `OAuth2AuthorizedClientService` 的主要职责是在应用级别管理 `OAuth2AuthorizedClient`(s)。

从开发者的角度来看，`OAuth2AuthorizedClientRepository` 或 `OAuth2AuthorizedClientService` 提供了查找与客户端关联的 `OAuth2AccessToken` 的能力，以便可用于发起对受保护资源的请求。

以下列表展示了一个示例：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Controller
public class OAuth2ClientController {

    @Autowired
    private OAuth2AuthorizedClientService authorizedClientService;

    @GetMapping("/")
    public String index(Authentication authentication) {
        OAuth2AuthorizedClient authorizedClient =
            this.authorizedClientService.loadAuthorizedClient("okta", authentication.getName());

        OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

        ...

        return "index";
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Controller
class OAuth2ClientController {

    @Autowired
    private lateinit var authorizedClientService: OAuth2AuthorizedClientService

    @GetMapping("/")
    fun index(authentication: Authentication): String {
        val authorizedClient: OAuth2AuthorizedClient =
            this.authorizedClientService.loadAuthorizedClient("okta", authentication.getName());
        val accessToken = authorizedClient.accessToken

        ...

        return "index";
    }
}
----
======

[NOTE]
====
Spring Boot 自动配置会在 `ApplicationContext` 中注册一个 `OAuth2AuthorizedClientRepository` 或 `OAuth2AuthorizedClientService` `@Bean`。但是，应用程序可以覆盖并注册自定义的 `OAuth2AuthorizedClientRepository` 或 `OAuth2AuthorizedClientService` `@Bean`。
====

`OAuth2AuthorizedClientService` 的默认实现是 `InMemoryOAuth2AuthorizedClientService`，它将 `OAuth2AuthorizedClient` 对象保存在内存中。

或者，您可以配置 JDBC 实现 `JdbcOAuth2AuthorizedClientService` 将 `OAuth2AuthorizedClient` 实例持久化到数据库中。

[NOTE]
====
`JdbcOAuth2AuthorizedClientService` 依赖于 xref:servlet/appendix/database-schema.adoc#dbschema-oauth2-client[OAuth 2.0 客户端模式] 中描述的表结构。
====


[[oauth2Client-authorized-manager-provider]]
== OAuth2AuthorizedClientManager 和 OAuth2AuthorizedClientProvider

`OAuth2AuthorizedClientManager` 负责 `OAuth2AuthorizedClient`(s) 的整体管理。

其主要职责包括：

* 使用 `OAuth2AuthorizedClientProvider` 对 OAuth 2.0 客户端进行授权（或重新授权）。
* 委托持久化 `OAuth2AuthorizedClient`，通常通过使用 `OAuth2AuthorizedClientService` 或 `OAuth2AuthorizedClientRepository`。
* 当 OAuth 2.0 客户端成功授权（或重新授权）时，委托给 `OAuth2AuthorizationSuccessHandler`。
* 当 OAuth 2.0 客户端授权（或重新授权）失败时，委托给 `OAuth2AuthorizationFailureHandler`。

`OAuth2AuthorizedClientProvider` 实现了对 OAuth 2.0 客户端进行授权（或重新授权）的策略。其实现通常对应一种授权授予类型，如 `authorization_code`、`client_credentials` 等。

`OAuth2AuthorizedClientManager` 的默认实现是 `DefaultOAuth2AuthorizedClientManager`，它与一个 `OAuth2AuthorizedClientProvider` 关联，该提供者可通过基于委托的组合方式支持多种授权授予类型。您可以使用 `OAuth2AuthorizedClientProviderBuilder` 来配置和构建这种基于委托的组合。

以下代码展示了如何配置和构建一个支持 `authorization_code`、`refresh_token`、`client_credentials` 和 `password` 授权授予类型的 `OAuth2AuthorizedClientProvider` 组合：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.authorizationCode()
					.refreshToken()
					.clientCredentials()
					.password()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .authorizationCode()
            .refreshToken()
            .clientCredentials()
            .password()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}
----
======

当授权尝试成功时，`DefaultOAuth2AuthorizedClientManager` 会委托给 `OAuth2AuthorizationSuccessHandler`，该处理器默认通过 `OAuth2AuthorizedClientRepository` 保存 `OAuth2AuthorizedClient`。在重新授权失败的情况下（例如刷新令牌已失效），`RemoveAuthorizedClientOAuth2AuthorizationFailureHandler` 会通过 `OAuth2AuthorizedClientRepository` 删除之前保存的 `OAuth2AuthorizedClient`。您可以通过 `setAuthorizationSuccessHandler(OAuth2AuthorizationSuccessHandler)` 和 `setAuthorizationFailureHandler(OAuth2AuthorizationFailureHandler)` 自定义默认行为。

`DefaultOAuth2AuthorizedClientManager` 还关联了一个类型为 `Function<OAuth2AuthorizeRequest, Map<String, Object>>` 的 `contextAttributesMapper`，负责将 `OAuth2AuthorizeRequest` 中的属性映射到与 `OAuth2AuthorizationContext` 关联的属性 `Map` 上。这在需要向 `OAuth2AuthorizedClientProvider` 提供必需（支持）属性时非常有用，例如 `PasswordOAuth2AuthorizedClientProvider` 要求资源所有者的 `username` 和 `password` 出现在 `OAuth2AuthorizationContext.getAttributes()` 中。

以下代码展示了 `contextAttributesMapper` 的示例：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.password()
					.refreshToken()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	// 假设 `username` 和 `password` 作为 `HttpServletRequest` 参数提供，
	// 将 `HttpServletRequest` 参数映射到 `OAuth2AuthorizationContext.getAttributes()`
	authorizedClientManager.setContextAttributesMapper(contextAttributesMapper());

	return authorizedClientManager;
}

private Function<OAuth2AuthorizeRequest, Map<String, Object>> contextAttributesMapper() {
	return authorizeRequest -> {
		Map<String, Object> contextAttributes = Collections.emptyMap();
		HttpServletRequest servletRequest = authorizeRequest.getAttribute(HttpServletRequest.class.getName());
		String username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME);
		String password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD);
		if (StringUtils.hasText(username) && StringUtils.hasText(password)) {
			contextAttributes = new HashMap<>();

			// `PasswordOAuth2AuthorizedClientProvider` 需要这两个属性
			contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username);
			contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password);
		}
		return contextAttributes;
	};
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .password()
            .refreshToken()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)

    // 假设 `username` 和 `password` 作为 `HttpServletRequest` 参数提供，
    // 将 `HttpServletRequest` 参数映射到 `OAuth2AuthorizationContext.getAttributes()`
    authorizedClientManager.setContextAttributesMapper(contextAttributesMapper())
    return authorizedClientManager
}

private fun contextAttributesMapper(): Function<OAuth2AuthorizeRequest, MutableMap<String, Any>> {
    return Function { authorizeRequest ->
        var contextAttributes: MutableMap<String, Any> = mutableMapOf()
        val servletRequest: HttpServletRequest = authorizeRequest.getAttribute(HttpServletRequest::class.java.name)
        val username: String = servletRequest.getParameter(OAuth2ParameterNames.USERNAME)
        val password: String = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD)
        if (StringUtils.hasText(username) && StringUtils.hasText(password)) {
            contextAttributes = hashMapOf()

            // `PasswordOAuth2AuthorizedClientProvider` 需要这两个属性
            contextAttributes[OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME] = username
            contextAttributes[OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME] = password
        }
        contextAttributes
    }
}
----
======

`DefaultOAuth2AuthorizedClientManager` 设计用于在 `HttpServletRequest` 上下文中使用。当在 `HttpServletRequest` 上下文之外运行时，请改用 `AuthorizedClientServiceOAuth2AuthorizedClientManager`。

服务应用程序是一个典型的使用 `AuthorizedClientServiceOAuth2AuthorizedClientManager` 的场景。服务应用通常在后台运行，无需用户交互，通常以系统级账户而非用户账户运行。使用 `client_credentials` 授予类型的 OAuth 2.0 客户端可视为一种服务应用。

以下代码展示如何配置支持 `client_credentials` 授予类型的 `AuthorizedClientServiceOAuth2AuthorizedClientManager` 的示例：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientService authorizedClientService) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.clientCredentials()
					.build();

	AuthorizedClientServiceOAuth2AuthorizedClientManager authorizedClientManager =
			new AuthorizedClientServiceOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientService);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientService: OAuth2AuthorizedClientService): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .clientCredentials()
            .build()
    val authorizedClientManager = AuthorizedClientServiceOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientService)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}
----
======