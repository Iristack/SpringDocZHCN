[[servlet-csrf]]
= 跨站请求伪造 (CSRF)
:figures: servlet/exploits

在用户可以登录的应用程序中，必须考虑如何防范 xref:features/exploits/csrf.adoc#csrf[跨站请求伪造 (CSRF)] 攻击。

Spring Security 默认会对 xref:features/exploits/csrf.adoc#csrf-protection-read-only[不安全的 HTTP 方法]（如 POST 请求）提供 CSRF 防护，因此无需额外编码。
您也可以使用以下配置显式指定默认设置：

[[csrf-configuration]]
.配置 CSRF 保护
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.csrf(Customizer.withDefaults());
		return http.build();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.annotation.web.invoke

@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            csrf { }
        }
        return http.build()
    }
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<csrf/>
</http>
----
======

要深入了解应用程序的 CSRF 防护，请考虑以下用例：

* 我想 <<csrf-components,了解 CSRF 防护的组件>>
* 我需要 <<migrating-to-spring-security-6,将应用程序从 Spring Security 5 迁移到 6>>
* 我想 <<csrf-token-repository-cookie,将 `CsrfToken` 存储在 cookie 中>>，而不是 <<csrf-token-repository-httpsession,会话中>>
* 我想 <<csrf-token-repository-custom,将 `CsrfToken` 存储在自定义位置>>
* 我想 <<deferred-csrf-token-opt-out,选择退出延迟令牌>>
* 我想 <<csrf-token-request-handler-opt-out-of-breach,选择退出 BREACH 防护>>
* 我需要指导如何将 <<csrf-integration-form,Thymeleaf、JSP 或其他视图技术>> 与后端集成
* 我需要指导如何将 <<csrf-integration-javascript,Angular 或其他 JavaScript 框架>> 与后端集成
* 我需要指导如何将 <<csrf-integration-mobile,移动应用程序或其他客户端>> 与后端集成
* 我需要关于 <<csrf-access-denied-handler,处理错误> 的指导
* 我想 <<csrf-testing,测试 CSRF 防护>>
* 我需要关于 <<disable-csrf,禁用 CSRF 防护>> 的指导

[[csrf-components]]
== 理解 CSRF 防护的组件

CSRF 防护由多个组件组成，这些组件被组合在 {security-api-url}org/springframework/security/web/csrf/CsrfFilter.html[`CsrfFilter`] 中：

.`CsrfFilter` 组件
[.invert-dark]
image::{figures}/csrf.png[]

CSRF 防护分为两部分：

1. 通过委托给 <<csrf-token-request-handler,`CsrfTokenRequestHandler`>>，使 {security-api-url}org/springframework/security/web/csrf/CsrfToken.html[`CsrfToken`] 对应用程序可用。
2. 确定请求是否需要 CSRF 保护，加载并验证令牌，并 <<csrf-access-denied-handler,处理 `AccessDeniedException`>>。

.`CsrfFilter` 处理流程
[.invert-dark]
image::{figures}/csrf-processing.png[]

* image:{icondir}/number_1.png[] 首先，加载 {security-api-url}org/springframework/security/web/csrf/DeferredCsrfToken.html[`DeferredCsrfToken`]，它持有对 <<csrf-token-repository,`CsrfTokenRepository`>> 的引用，以便稍后（在 image:{icondir}/number_4.png[] 中）加载持久化的 `CsrfToken`。
* image:{icondir}/number_2.png[] 其次，将一个 `Supplier<CsrfToken>`（从 `DeferredCsrfToken` 创建）传递给 <<csrf-token-request-handler,`CsrfTokenRequestHandler`>>，该处理器负责填充请求属性，使 `CsrfToken` 对应用程序的其余部分可用。
* image:{icondir}/number_3.png[] 接着，主要的 CSRF 防护处理开始，并检查当前请求是否需要 CSRF 防护。如果不需要，则继续过滤器链并结束处理。
* image:{icondir}/number_4.png[] 如果需要 CSRF 防护，则最终从 `DeferredCsrfToken` 加载持久化的 `CsrfToken`。
* image:{icondir}/number_5.png[] 继续，使用 <<csrf-token-request-handler,`CsrfTokenRequestHandler`>> 解析客户端提供的实际 CSRF 令牌（如果有）。
* image:{icondir}/number_6.png[] 将实际的 CSRF 令牌与持久化的 `CsrfToken` 进行比较。如果有效，则继续过滤器链并结束处理。
* image:{icondir}/number_7.png[] 如果实际的 CSRF 令牌无效（或缺失），则将 `AccessDeniedException` 传递给 <<csrf-access-denied-handler,`AccessDeniedHandler`>> 并结束处理。

[[migrating-to-spring-security-6]]
== 迁移到 Spring Security 6

从 Spring Security 5 迁移到 6 时，有一些更改可能会影响您的应用程序。
以下是 Spring Security 6 中 CSRF 防护方面发生变化的概述：

* 现在默认 <<deferred-csrf-token,延迟加载 `CsrfToken`>>，以通过不再要求每次请求都加载会话来提高性能。
* `CsrfToken` 现在默认 <<csrf-token-request-handler-breach,在每个请求中包含随机性>>，以保护 CSRF 令牌免受 https://en.wikipedia.org/wiki/BREACH[BREACH] 攻击。

[TIP]
====
Spring Security 6 中的更改需要为单页应用程序进行额外配置，因此您可能会发现 <<csrf-integration-javascript-spa>> 部分特别有用。
====
有关迁移 Spring Security 5 应用程序的更多信息，请参阅 https://docs.spring.io/spring-security/reference/5.8/migration/index.html[迁移] 章节中的 https://docs.spring.io/spring-security/reference/5.8/migration/servlet/exploits.html[漏洞防护] 部分。

[[csrf-token-repository]]
== 持久化 `CsrfToken`

`CsrfToken` 使用 `CsrfTokenRepository` 进行持久化。

默认情况下，使用 <<csrf-token-repository-httpsession,`HttpSessionCsrfTokenRepository`>> 在会话中存储令牌。
Spring Security 还提供了 <<csrf-token-repository-cookie,`CookieCsrfTokenRepository`>> 用于在 cookie 中存储令牌。
您还可以指定 <<csrf-token-repository-custom,自己的实现>> 来将令牌存储在任何您喜欢的位置。

[[csrf-token-repository-httpsession]]
=== 使用 `HttpSessionCsrfTokenRepository`

默认情况下，Spring Security 使用 {security-api-url}org/springframework/security/web/csrf/HttpSessionCsrfTokenRepository.html[`HttpSessionCsrfTokenRepository`] 将预期的 CSRF 令牌存储在 `HttpSession` 中，因此无需额外编码。

`HttpSessionCsrfTokenRepository` 从会话（无论是内存中、缓存还是数据库）读取令牌。如果您需要直接访问会话属性，请首先使用 `HttpSessionCsrfTokenRepository#setSessionAttributeName` 配置会话属性名称。

您可以使用以下配置显式指定默认配置：

[[csrf-token-repository-httpsession-configuration]]
.配置 `HttpSessionCsrfTokenRepository`
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.csrf((csrf) -> csrf
				.csrfTokenRepository(new HttpSessionCsrfTokenRepository())
			);
		return http.build();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.annotation.web.invoke

@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            csrf {
                csrfTokenRepository = HttpSessionCsrfTokenRepository()
            }
        }
        return http.build()
    }
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<csrf token-repository-ref="tokenRepository"/>
</http>
<b:bean id="tokenRepository"
	class="org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository"/>
----
======

[[csrf-token-repository-cookie]]
=== 使用 `CookieCsrfTokenRepository`

您可以使用 {security-api-url}org/springframework/security/web/csrf/CookieCsrfTokenRepository.html[`CookieCsrfTokenRepository`] 将 `CsrfToken` 持久化到 cookie 中，以 <<csrf-integration-javascript,支持基于 JavaScript 的应用程序>>。

`CookieCsrfTokenRepository` 默认将令牌写入名为 `XSRF-TOKEN` 的 cookie，并从名为 `X-XSRF-TOKEN` 的 HTTP 请求头或 `_csrf` 请求参数中读取它。
这些默认值来自 Angular 及其前身 https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection[AngularJS]。

[TIP]
====
有关此主题的最新信息，请参阅 https://angular.dev/best-practices/security#httpclient-xsrf-csrf-security[HttpClient XSRF/CSRF 安全性] 和 https://angular.dev/api/common/http/withXsrfConfiguration[withXsrfConfiguration]。
====

您可以使用以下配置配置 `CookieCsrfTokenRepository`：

[[csrf-token-repository-cookie-configuration]]
.配置 `CookieCsrfTokenRepository`
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.csrf((csrf) -> csrf
				.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
			);
		return http.build();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.annotation.web.invoke

@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            csrf {
                csrfTokenRepository = CookieCsrfTokenRepository.withHttpOnlyFalse()
            }
        }
        return http.build()
    }
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<csrf token-repository-ref="tokenRepository"/>
</http>
<b:bean id="tokenRepository"
	class="org.springframework.security.web.csrf.CookieCsrfTokenRepository"
	p:cookieHttpOnly="false"/>
----
======

[NOTE]
====
示例明确将 `HttpOnly` 设置为 `false`。
这是为了让 JavaScript 框架（如 Angular）能够读取它所必需的。
如果您不需要直接用 JavaScript 读取 cookie 的能力，我们 _建议_ 省略 `HttpOnly`（通过使用 `new CookieCsrfTokenRepository()` 代替）以提高安全性。
====

[[csrf-token-repository-custom]]
=== 自定义 `CsrfTokenRepository`

有时您可能需要实现自定义的 {security-api-url}org/springframework/security/web/csrf/CsrfTokenRepository.html[`CsrfTokenRepository`]。

一旦实现了 `CsrfTokenRepository` 接口，您就可以使用以下配置让 Spring Security 使用它：

[[csrf-token-repository-custom-configuration]]
.配置自定义 `CsrfTokenRepository`
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.csrf((csrf) -> csrf
				.csrfTokenRepository(new CustomCsrfTokenRepository())
			);
		return http.build();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.annotation.web.invoke

@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            csrf {
                csrfTokenRepository = CustomCsrfTokenRepository()
            }
        }
        return http.build()
    }
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<csrf token-repository-ref="tokenRepository"/>
</http>
<b:bean id="tokenRepository"
	class="example.CustomCsrfTokenRepository"/>
----
======

[[csrf-token-request-handler]]
== 处理 `CsrfToken`

使用 `CsrfTokenRequestHandler` 将 `CsrfToken` 提供给应用程序。
此组件还负责从 HTTP 头或请求参数中解析 `CsrfToken`。

默认情况下，使用 <<csrf-token-request-handler-breach,`XorCsrfTokenRequestAttributeHandler`>> 为 `CsrfToken` 提供 https://en.wikipedia.org/wiki/BREACH[BREACH] 防护。
Spring Security 还提供了 <<csrf-token-request-handler-plain,`CsrfTokenRequestAttributeHandler`>> 以选择退出 BREACH 防护。
您还可以指定 <<csrf-token-request-handler-custom,自己的实现>> 来自定义处理和解析令牌的策略。

[[csrf-token-request-handler-breach]]
=== 使用 `XorCsrfTokenRequestAttributeHandler` (BREACH)

`XorCsrfTokenRequestAttributeHandler` 将 `CsrfToken` 作为名为 `_csrf` 的 `HttpServletRequest` 属性提供，并且还为 https://en.wikipedia.org/wiki/BREACH[BREACH] 提供了保护。

[NOTE]
====
`CsrfToken` 也作为请求属性使用名称 `CsrfToken.class.getName()` 提供。
此名称不可配置，但可以使用 `XorCsrfTokenRequestAttributeHandler#setCsrfRequestAttributeName` 更改名称 `_csrf`。
====

此实现还从请求中解析令牌值，作为请求头（默认为 <<csrf-token-repository-httpsession,`X-CSRF-TOKEN`>> 或 <<csrf-token-repository-cookie,`X-XSRF-TOKEN`>>）或请求参数（默认为 `_csrf`）。

[NOTE]
====
通过在 CSRF 令牌值中编码随机性以确保返回的 `CsrfToken` 在每个请求中都发生变化，从而提供 BREACH 防护。
当稍后将令牌解析为头值或请求参数时，会对其进行解码以获取原始令牌，然后将其与 <<csrf-token-repository,持久化的 `CsrfToken`>> 进行比较。
====

Spring Security 默认保护 CSRF 令牌免受 BREACH 攻击，因此无需额外编码。
您可以使用以下配置显式指定默认配置：

[[csrf-token-request-handler-breach-configuration]]
.配置 BREACH 防护
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.csrf((csrf) -> csrf
				.csrfTokenRequestHandler(new XorCsrfTokenRequestAttributeHandler())
			);
		return http.build();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.annotation.web.invoke

@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            csrf {
                csrfTokenRequestHandler = XorCsrfTokenRequestAttributeHandler()
            }
        }
        return http.build()
    }
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<csrf request-handler-ref="requestHandler"/>
</http>
<b:bean id="requestHandler"
	class="org.springframework.security.web.csrf.XorCsrfTokenRequestAttributeHandler"/>
----
======

[[csrf-token-request-handler-plain]]
=== 使用 `CsrfTokenRequestAttributeHandler`

`CsrfTokenRequestAttributeHandler` 将 `CsrfToken` 作为名为 `_csrf` 的 `HttpServletRequest` 属性提供。

[NOTE]
====
`CsrfToken` 也作为请求属性使用名称 `CsrfToken.class.getName()` 提供。
此名称不可配置，但可以使用 `CsrfTokenRequestAttributeHandler#setCsrfRequestAttributeName` 更改名称 `_csrf`。
====

此实现还从请求中解析令牌值，作为请求头（默认为 <<csrf-token-repository-httpsession,`X-CSRF-TOKEN`>> 或 <<csrf-token-repository-cookie,`X-XSRF-TOKEN`>>）或请求参数（默认为 `_csrf`）。

[[csrf-token-request-handler-opt-out-of-breach]]
`CsrfTokenRequestAttributeHandler` 的主要用途是选择退出 `CsrfToken` 的 BREACH 防护，可以使用以下配置进行配置：

.选择退出 BREACH 防护
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.csrf((csrf) -> csrf
				.csrfTokenRequestHandler(new CsrfTokenRequestAttributeHandler())
			);
		return http.build();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.annotation.web.invoke

@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            csrf {
                csrfTokenRequestHandler = CsrfTokenRequestAttributeHandler()
            }
        }
        return http.build()
    }
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<csrf request-handler-ref="requestHandler"/>
</http>
<b:bean id="requestHandler"
	class="org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler"/>
----
======

[[csrf-token-request-handler-custom]]
=== 自定义 `CsrfTokenRequestHandler`

您可以实现 `CsrfTokenRequestHandler` 接口来自定义处理和解析令牌的策略。

[TIP]
====
`CsrfTokenRequestHandler` 接口是一个 `@FunctionalInterface`，可以使用 lambda 表达式实现以自定义请求处理。
您需要实现完整的接口才能自定义如何从请求中解析令牌。
请参阅 <<csrf-integration-javascript-spa-configuration>> 以获取使用委托实现自定义处理和解析令牌策略的示例。
====

一旦实现了 `CsrfTokenRequestHandler` 接口，您就可以使用以下配置让 Spring Security 使用它：

[[csrf-token-request-handler-custom-configuration]]
.配置自定义 `CsrfTokenRequestHandler`
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.csrf((csrf) -> csrf
				.csrfTokenRequestHandler(new CustomCsrfTokenRequestHandler())
			);
		return http.build();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.annotation.web.invoke

@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            csrf {
                csrfTokenRequestHandler = CustomCsrfTokenRequestHandler()
            }
        }
        return http.build()
    }
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<csrf request-handler-ref="requestHandler"/>
</http>
<b:bean id="requestHandler"
	class="example.CustomCsrfTokenRequestHandler"/>
----
======

[[deferred-csrf-token]]
== 延迟加载 `CsrfToken`

默认情况下，Spring Security 会延迟加载 `CsrfToken`，直到需要时才加载。

[NOTE]
====
每当使用 xref:features/exploits/csrf.adoc#csrf-protection-read-only[不安全的 HTTP 方法]（如 POST）发出请求时，都需要 `CsrfToken`。
此外，任何将令牌渲染到响应中的请求也需要它，例如包含隐藏 `<input>` 的 `<form>` 标签的网页。
====

由于 Spring Security 默认也将 `CsrfToken` 存储在 `HttpSession` 中，因此延迟 CSRF 令牌可以通过不要求每次请求都加载会话来提高性能。

[[deferred-csrf-token-opt-out]]
如果您希望选择退出延迟令牌并在每次请求时加载 `CsrfToken`，可以使用以下配置：

[[deferred-csrf-token-opt-out-configuration]]
.选择退出延迟 CSRF 令牌
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		XorCsrfTokenRequestAttributeHandler requestHandler = new XorCsrfTokenRequestAttributeHandler();
		// 设置将填充 CsrfToken 的属性名称
		requestHandler.setCsrfRequestAttributeName(null);
		http
			// ...
			.csrf((csrf) -> csrf
				.csrfTokenRequestHandler(requestHandler)
			);
		return http.build();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.annotation.web.invoke

@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        val requestHandler = XorCsrfTokenRequestAttributeHandler()
        // 设置将填充 CsrfToken 的属性名称
        requestHandler.setCsrfRequestAttributeName(null)
        http {
            // ...
            csrf {
                csrfTokenRequestHandler = requestHandler
            }
        }
        return http.build()
    }
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<csrf request-handler-ref="requestHandler"/>
</http>
<b:bean id="requestHandler"
	class="org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler">
	<b:property name="csrfRequestAttributeName">
		<b:null/>
	</b:property>
</b:bean>
----
======

[NOTE]
====
通过将 `csrfRequestAttributeName` 设置为 `null`，必须先加载 `CsrfToken` 才能确定要使用的属性名称。
这会导致 `CsrfToken` 在每次请求时都被加载。
====


[[csrf-integration]]
== 与 CSRF 防护集成

为了通过 xref:features/exploits/csrf.adoc#csrf-protection-stp[同步令牌模式] 防范 CSRF 攻击，我们必须在 HTTP 请求中包含实际的 CSRF 令牌。
这必须包含在请求的一部分中（表单参数、HTTP 头或其他部分），而浏览器不会自动将其包含在 HTTP 请求中。

以下部分描述了前端或客户端应用程序与受 CSRF 保护的后端应用程序集成的各种方式：

* <<csrf-integration-form>>
* <<csrf-integration-javascript>>
* <<csrf-integration-mobile>>

[[csrf-integration-form]]
=== HTML 表单

提交 HTML 表单时，必须将 CSRF 令牌作为隐藏输入包含在表单中。
例如，渲染后的 HTML 可能如下所示：

.HTML 表单中的 CSRF 令牌
[source,html]
----
<input type="hidden"
	name="_csrf"
	value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
----

以下视图技术会自动在具有不安全 HTTP 方法（如 POST）的表单中包含实际的 CSRF 令牌：

* https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view-jsp-formtaglib[Spring 的表单标签库]
* https://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#integration-with-requestdatavalueprocessor[Thymeleaf]
* 任何其他与 {spring-framework-api-url}org/springframework/web/servlet/support/RequestDataValueProcessor.html[`RequestDataValueProcessor`] 集成的视图技术（通过 {security-api-url}org/springframework/security/web/servlet/support/csrf/CsrfRequestDataValueProcessor.html[`CsrfRequestDataValueProcessor`])
* 您还可以通过 xref:servlet/integrations/jsp-taglibs.adoc#taglibs-csrfinput[csrfInput] 标签自行包含令牌

如果这些选项不可用，您可以利用 `CsrfToken` 作为 <<csrf-token-request-handler,名为 `_csrf` 的 `HttpServletRequest` 属性>> 暴露的事实。
以下示例在 JSP 中这样做：

.使用请求属性的 HTML 表单中的 CSRF 令牌
[source,xml]
----
<c:url var="logoutUrl" value="/logout"/>
<form action="${logoutUrl}"
	method="post">
<input type="submit"
	value="Log out" />
<input type="hidden"
	name="${_csrf.parameterName}"
	value="${_csrf.token}"/>
</form>
----

[[csrf-integration-javascript]]
=== JavaScript 应用程序

JavaScript 应用程序通常使用 JSON 而不是 HTML。
如果您使用 JSON，可以在 HTTP 请求头中提交 CSRF 令牌，而不是请求参数。

为了获取 CSRF 令牌，您可以配置 Spring Security 将预期的 CSRF 令牌 <<csrf-token-repository-cookie,存储在 cookie 中>>。
通过将预期的令牌存储在 cookie 中，Angular 等 JavaScript 框架可以自动将实际的 CSRF 令牌作为 HTTP 请求头包含。

[TIP]
====
在将单页应用程序 (SPA) 与 Spring Security 的 CSRF 防护集成时，需要特别注意 BREACH 防护和延迟令牌。
下一个部分提供了完整的配置示例。
====

您可以在以下部分中阅读不同类型的 JavaScript 应用程序：

* <<csrf-integration-javascript-spa>>
* <<csrf-integration-javascript-mpa>>
* <<csrf-integration-javascript-other>>

[[csrf-integration-javascript-spa]]
==== 单页应用程序

将单页应用程序 (SPA) 与 Spring Security 的 CSRF 防护集成时有特殊注意事项。

回想一下，Spring Security 默认提供 <<csrf-token-request-handler-breach,`CsrfToken` 的 BREACH 防护>>。
当将预期的 CSRF 令牌 <<csrf-token-repository-cookie,存储在 cookie 中>> 时，JavaScript 应用程序只能访问纯文本令牌值，而 _无法_ 访问编码后的值。
需要提供一个 <<csrf-token-request-handler-custom,自定义请求处理器>> 来解析实际的令牌值。

此外，在身份验证成功和注销成功后，存储 CSRF 令牌的 cookie 将被清除。
Spring Security 默认延迟加载新的 CSRF 令牌，并且需要额外的工作来返回新的 cookie。

[NOTE]
====
在身份验证成功和注销成功后刷新令牌是必要的，因为 {security-api-url}org/springframework/security/web/csrf/CsrfAuthenticationStrategy.html[`CsrfAuthenticationStrategy`] 和 {security-api-url}org/springframework/security/web/csrf/CsrfLogoutHandler.html[`CsrfLogoutHandler`] 将清除之前的令牌。
客户端应用程序将无法执行不安全的 HTTP 请求（如 POST），除非获得新的令牌。
====

为了轻松地将单页应用程序与 Spring Security 集成，可以使用以下配置：

[[csrf-integration-javascript-spa-configuration]]
.为单页应用程序配置 CSRF
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.csrf((csrf) -> csrf
				.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())   // <1>
				.csrfTokenRequestHandler(new SpaCsrfTokenRequestHandler())            // <2>
			)
			.addFilterAfter(new CsrfCookieFilter(), BasicAuthenticationFilter.class); // <3>
		return http.build();
	}
}

final class SpaCsrfTokenRequestHandler extends CsrfTokenRequestAttributeHandler {
	private final CsrfTokenRequestHandler delegate = new XorCsrfTokenRequestAttributeHandler();

	@Override
	public void handle(HttpServletRequest request, HttpServletResponse response, Supplier<CsrfToken> csrfToken) {
		/*
		 * 始终使用 XorCsrfTokenRequestAttributeHandler 在响应体中渲染 CsrfToken 时提供 BREACH 防护。
		 */
		this.delegate.handle(request, response, csrfToken);
	}

	@Override
	public String resolveCsrfTokenValue(HttpServletRequest request, CsrfToken csrfToken) {
		/*
		 * 如果请求包含请求头，则使用 CsrfTokenRequestAttributeHandler 解析 CsrfToken。
		 * 这适用于单页应用程序自动包含头值的情况，该头值是通过包含原始 CsrfToken 的 cookie 获得的。
		 */
		if (StringUtils.hasText(request.getHeader(csrfToken.getHeaderName()))) {
			return super.resolveCsrfTokenValue(request, csrfToken);
		}
		/*
		 * 在所有其他情况下（例如，如果请求包含请求参数），使用 XorCsrfTokenRequestAttributeHandler 解析 CsrfToken。
		 * 这适用于服务器端渲染的表单将 _csrf 请求参数作为隐藏输入包含的情况。
		 */
		return this.delegate.resolveCsrfTokenValue(request, csrfToken);
	}
}

final class CsrfCookieFilter extends OncePerRequestFilter {

	@Override
	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
			throws ServletException, IOException {
		CsrfToken csrfToken = (CsrfToken) request.getAttribute("_csrf");
		// 通过强制加载延迟的令牌将令牌值渲染到 cookie 中
		csrfToken.getToken();

		filterChain.doFilter(request, response);
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.annotation.web.invoke

@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            csrf {
                csrfTokenRepository = CookieCsrfTokenRepository.withHttpOnlyFalse()    // <1>
                csrfTokenRequestHandler = SpaCsrfTokenRequestHandler()                 // <2>
            }
        }
        http.addFilterAfter(CsrfCookieFilter(), BasicAuthenticationFilter::class.java) // <3>
        return http.build()
    }
}

class SpaCsrfTokenRequestHandler : CsrfTokenRequestAttributeHandler() {
    private val delegate: CsrfTokenRequestHandler = XorCsrfTokenRequestAttributeHandler()

    override fun handle(request: HttpServletRequest, response: HttpServletResponse, csrfToken: Supplier<CsrfToken>) {
        /*
         * 始终使用 XorCsrfTokenRequestAttributeHandler 在响应体中渲染 CsrfToken 时提供 BREACH 防护。
         */
        delegate.handle(request, response, csrfToken)
    }

    override fun resolveCsrfTokenValue(request: HttpServletRequest, csrfToken: CsrfToken): String? {
        /*
         * 如果请求包含请求头，则使用 CsrfTokenRequestAttributeHandler 解析 CsrfToken。
         * 这适用于单页应用程序自动包含头值的情况，该头值是通过包含原始 CsrfToken 的 cookie 获得的。
         */
        return if (StringUtils.hasText(request.getHeader(csrfToken.headerName))) {
            super.resolveCsrfTokenValue(request, csrfToken)
        } else {
            /*
             * 在所有其他情况下（例如，如果请求包含请求参数），使用 XorCsrfTokenRequestAttributeHandler 解析 CsrfToken。
             * 这适用于服务器端渲染的表单将 _csrf 请求参数作为隐藏输入包含的情况。
             */
            delegate.resolveCsrfTokenValue(request, csrfToken)
        }
    }
}

class CsrfCookieFilter : OncePerRequestFilter() {

    @Throws(ServletException::class, IOException::class)
    override fun doFilterInternal(request: HttpServletRequest, response: HttpServletResponse, filterChain: FilterChain) {
        val csrfToken = request.getAttribute("_csrf") as CsrfToken
        // 通过强制加载延迟的令牌将令牌值渲染到 cookie 中
        csrfToken.token
        filterChain.doFilter(request, response)
    }
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<csrf
		token-repository-ref="tokenRepository"                        <1>
		request-handler-ref="requestHandler"/>                        <2>
	<custom-filter ref="csrfCookieFilter" after="BASIC_AUTH_FILTER"/> <3>
</http>
<b:bean id="tokenRepository"
	class="org.springframework.security.web.csrf.CookieCsrfTokenRepository"
	p:cookieHttpOnly="false"/>
<b:bean id="requestHandler"
	class="example.SpaCsrfTokenRequestHandler"/>
<b:bean id="csrfCookieFilter"
	class="example.CsrfCookieFilter"/>
----
======

<1> 配置 `CookieCsrfTokenRepository`，并将 `HttpOnly` 设置为 `false`，以便 JavaScript 应用程序可以读取 cookie。
<2> 配置自定义的 `CsrfTokenRequestHandler`，根据它是 HTTP 请求头 (`X-XSRF-TOKEN`) 还是请求参数 (`_csrf`) 来解析 CSRF 令牌。
<3> 配置自定义的 `Filter` 以在每次请求时加载 `CsrfToken`，如果需要，将返回一个新的 cookie。

[[csrf-integration-javascript-mpa]]
==== 多页应用程序

对于在每页加载 JavaScript 的多页应用程序，除了将 CSRF 令牌 <<csrf-token-repository-cookie,暴露在 cookie 中>> 外，另一种选择是将 CSRF 令牌包含在 `meta` 标签中。
HTML 可能如下所示：

.HTML meta 标签中的 CSRF 令牌
[source,html]
----
<html>
<head>
	<meta name="_csrf" content="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
	<meta name="_csrf_header" content="X-CSRF-TOKEN"/>
	<!-- ... -->
</head>
<!-- ... -->
</html>
----

为了在请求中包含 CSRF 令牌，您可以利用 `CsrfToken` 作为 <<csrf-token-request-handler,名为 `_csrf` 的 `HttpServletRequest` 属性>> 暴露的事实。
以下示例在 JSP 中这样做：

.使用请求属性的 HTML meta 标签中的 CSRF 令牌
[source,html]
----
<html>
<head>
	<meta name="_csrf" content="${_csrf.token}"/>
	<!-- 默认头名称为 X-CSRF-TOKEN -->
	<meta name="_csrf_header" content="${_csrf.headerName}"/>
	<!-- ... -->
</head>
<!-- ... -->
</html>
----

一旦 meta 标签包含 CSRF 令牌，JavaScript 代码就可以读取 meta 标签并包含 CSRF 令牌作为头。
如果您使用 jQuery，可以使用以下代码：

.在 AJAX 请求中包含 CSRF 令牌
[source,javascript]
----
$(function () {
	var token = $("meta[name='_csrf']").attr("content");
	var header = $("meta[name='_csrf_header']").attr("content");
	$(document).ajaxSend(function(e, xhr, options) {
		xhr.setRequestHeader(header, token);
	});
});
----

[[csrf-integration-javascript-other]]
==== 其他 JavaScript 应用程序

JavaScript 应用程序的另一个选择是在 HTTP 响应头中包含 CSRF 令牌。

一种实现方法是使用带有 xref:servlet/integrations/mvc.adoc#mvc-csrf-resolver[`CsrfTokenArgumentResolver`] 的 `@ControllerAdvice`。
以下是应用于应用程序中所有控制器端点的 `@ControllerAdvice` 示例：

[[controller-advice]]
.HTTP 响应头中的 CSRF 令牌
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@ControllerAdvice
public class CsrfControllerAdvice {

	@ModelAttribute
	public void getCsrfToken(HttpServletResponse response, CsrfToken csrfToken) {
		response.setHeader(csrfToken.getHeaderName(), csrfToken.getToken());
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@ControllerAdvice
class CsrfControllerAdvice {

	@ModelAttribute
	fun getCsrfToken(response: HttpServletResponse, csrfToken: CsrfToken) {
		response.setHeader(csrfToken.headerName, csrfToken.token)
	}

}
----
======

[NOTE]
====
由于此 `@ControllerAdvice` 适用于应用程序中的所有端点，它将导致在每个请求时加载 CSRF 令牌，这可能会抵消使用 <<csrf-token-repository-httpsession,`HttpSessionCsrfTokenRepository`>> 时 <<deferred-csrf-token,延迟令牌>> 的好处。
但是，当使用 <<csrf-token-repository-cookie,`CookieCsrfTokenRepository`>> 时，这通常不是问题。
====

[NOTE]
====
重要的是要记住，控制器端点和控制器建议是在 Spring Security 过滤器链之后调用的。
这意味着只有在请求通过过滤器链到达您的应用程序时，此 `@ControllerAdvice` 才会被应用。
有关向过滤器链添加过滤器以更早访问 `HttpServletResponse` 的示例，请参阅 <<csrf-integration-javascript-spa-configuration,单页应用程序>> 的配置。
====

现在，对于此控制器建议适用的任何自定义端点，CSRF 令牌将在响应头中可用（默认为 <<csrf-token-repository-httpsession,`X-CSRF-TOKEN`>> 或 <<csrf-token-repository-cookie,`X-XSRF-TOKEN`>>）。
可以使用对后端的任何请求从响应中获取令牌，后续请求可以将令牌包含在具有相同名称的请求头中。

[[csrf-integration-mobile]]
=== 移动应用程序

像 <<csrf-integration-javascript,JavaScript 应用程序>> 一样，移动应用程序通常使用 JSON 而不是 HTML。
不提供浏览器流量的后端应用程序可以选择 <<disable-csrf,禁用 CSRF>>。
在这种情况下，无需额外工作。

然而，也提供浏览器流量并且因此仍然需要 CSRF 防护的后端应用程序可以继续将 `CsrfToken` <<csrf-token-repository-httpsession,存储在会话中>>，而不是 <<csrf-token-repository-cookie,在 cookie 中>>。

在这种情况下，与后端集成的典型模式是暴露一个 `/csrf` 端点，允许前端（移动或浏览器客户端）按需请求 CSRF 令牌。
使用此模式的好处是 CSRF 令牌 <<deferred-csrf-token,可以继续延迟>>，并且仅在请求需要 CSRF 防护时才需要从会话中加载。
使用自定义端点还意味着客户端应用程序可以通过发出显式请求按需请求生成新令牌（如有必要）。

[TIP]
====
此模式可用于任何需要 CSRF 防护的应用程序类型，不仅仅是移动应用程序。
虽然在这种情况下通常不需要这种方法，但它为与受 CSRF 保护的后端集成提供了另一种选择。
====

以下是使用 xref:servlet/integrations/mvc.adoc#mvc-csrf-resolver[`CsrfTokenArgumentResolver`] 的 `/csrf` 端点的示例：

[[csrf-endpoint]]
.`/csrf` 端点
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@RestController
public class CsrfController {

    @GetMapping("/csrf")
    public CsrfToken csrf(CsrfToken csrfToken) {
        return csrfToken;
    }

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@RestController
class CsrfController {

    @GetMapping("/csrf")
    fun csrf(csrfToken: CsrfToken): CsrfToken {
        return csrfToken
    }

}
----
======

[NOTE]
====
如果上述端点需要在服务器认证之前调用，您可能需要考虑添加 `.requestMatchers("/csrf").permitAll()`。
====

应在应用程序启动或初始化时（例如在加载时）以及身份验证成功和注销成功后调用此端点以获取 CSRF 令牌。

[NOTE]
====
在身份验证成功和注销成功后刷新令牌是必要的，因为 {security-api-url}org/springframework/security/web/csrf/CsrfAuthenticationStrategy.html[`CsrfAuthenticationStrategy`] 和 {security-api-url}org/springframework/security/web/csrf/CsrfLogoutHandler.html[`CsrfLogoutHandler`] 将清除之前的令牌。
客户端应用程序将无法执行不安全的 HTTP 请求（如 POST），除非获得新的令牌。
====

一旦获得 CSRF 令牌，您就需要自己将其作为 HTTP 请求头（默认为 <<csrf-token-repository-httpsession,`X-CSRF-TOKEN`>> 或 <<csrf-token-repository-cookie,`X-XSRF-TOKEN`>>）包含。

[[csrf-access-denied-handler]]
== 处理 `AccessDeniedException`

要处理 `InvalidCsrfTokenException` 等 `AccessDeniedException`，您可以配置 Spring Security 以任何您喜欢的方式处理这些异常。
例如，您可以使用以下配置配置自定义访问拒绝页面：

[[csrf-access-denied-handler-configuration]]
.配置 `AccessDeniedHandler`
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.exceptionHandling((exceptionHandling) -> exceptionHandling
				.accessDeniedPage("/access-denied")
			);
		return http.build();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.annotation.web.invoke

@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            exceptionHandling {
                accessDeniedPage = "/access-denied"
            }
        }
        return http.build()
    }
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<access-denied-handler error-page="/access-denied"/>
</http>
----
======

[[csrf-testing]]
== CSRF 测试

您可以使用 Spring Security 的 xref:servlet/test/mockmvc/setup.adoc[测试支持] 和 xref:servlet/test/mockmvc/csrf.adoc[`CsrfRequestPostProcessor`] 来测试 CSRF 防护，如下所示：

[[csrf-testing-example]]
.测试 CSRF 防护
[tabs]
======
Java::
+
[source,java,role="primary"]
----
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.*;
import static org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = SecurityConfig.class)
@WebAppConfiguration
public class CsrfTests {

	private MockMvc mockMvc;

	@BeforeEach
	public void setUp(WebApplicationContext applicationContext) {
		this.mockMvc = MockMvcBuilders.webAppContextSetup(applicationContext)
			.apply(springSecurity())
			.build();
	}

	@Test
	public void loginWhenValidCsrfTokenThenSuccess() throws Exception {
		this.mockMvc.perform(post("/login").with(csrf())
				.accept(MediaType.TEXT_HTML)
				.param("username", "user")
				.param("password", "password"))
			.andExpect(status().is3xxRedirection())
			.andExpect(header().string(HttpHeaders.LOCATION, "/"));
	}

	@Test
	public void loginWhenInvalidCsrfTokenThenForbidden() throws Exception {
		this.mockMvc.perform(post("/login").with(csrf().useInvalidToken())
				.accept(MediaType.TEXT_HTML)
				.param("username", "user")
				.param("password", "password"))
			.andExpect(status().isForbidden());
	}

	@Test
	public void loginWhenMissingCsrfTokenThenForbidden() throws Exception {
		this.mockMvc.perform(post("/login")
				.accept(MediaType.TEXT_HTML)
				.param("username", "user")
				.param("password", "password"))
			.andExpect(status().isForbidden());
	}

	@Test
	@WithMockUser
	public void logoutWhenValidCsrfTokenThenSuccess() throws Exception {
		this.mockMvc.perform(post("/logout").with(csrf())
				.accept(MediaType.TEXT_HTML))
			.andExpect(status().is3xxRedirection())
			.andExpect(header().string(HttpHeaders.LOCATION, "/login?logout"));
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.*
import org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.*
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.*

@ExtendWith(SpringExtension::class)
@ContextConfiguration(classes = [SecurityConfig::class])
@WebAppConfiguration
class CsrfTests {
	private lateinit var mockMvc: MockMvc

	@BeforeEach
	fun setUp(applicationContext: WebApplicationContext) {
		mockMvc = MockMvcBuilders.webAppContextSetup(applicationContext)
			.apply<DefaultMockMvcBuilder>(springSecurity())
			.build()
	}

	@Test
	fun loginWhenValidCsrfTokenThenSuccess() {
		mockMvc.perform(post("/login").with(csrf())
				.accept(MediaType.TEXT_HTML)
				.param("username", "user")
				.param("password", "password"))
			.andExpect(status().is3xxRedirection)
			.andExpect(header().string(HttpHeaders.LOCATION, "/"))
	}

	@Test
	fun loginWhenInvalidCsrfTokenThenForbidden() {
		mockMvc.perform(post("/login").with(csrf().useInvalidToken())
				.accept(MediaType.TEXT_HTML)
				.param("username", "user")
				.param("password", "password"))
			.andExpect(status().isForbidden)
	}

	@Test
	fun loginWhenMissingCsrfTokenThenForbidden() {
		mockMvc.perform(post("/login")
				.accept(MediaType.TEXT_HTML)
				.param("username", "user")
				.param("password", "password"))
			.andExpect(status().isForbidden)
	}

	@Test
	@WithMockUser
	@Throws(Exception::class)
	fun logoutWhenValidCsrfTokenThenSuccess() {
		mockMvc.perform(post("/logout").with(csrf())
				.accept(MediaType.TEXT_HTML))
			.andExpect(status().is3xxRedirection)
			.andExpect(header().string(HttpHeaders.LOCATION, "/login?logout"))
	}
}
----
======

[[disable-csrf]]
== 禁用 CSRF 防护

默认情况下，CSRF 防护是启用的，这会影响 <<csrf-integration,与后端集成>> 和 <<csrf-testing,测试>> 您的应用程序。
在禁用 CSRF 防护之前，请考虑它是否 xref:features/exploits/csrf.adoc#csrf-when[对您的应用程序有意义]。

您还可以考虑是否只有某些端点不需要 CSRF 防护，并配置忽略规则，如下例所示：

[[disable-csrf-ignoring-configuration]]
.忽略请求
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // ...
            .csrf((csrf) -> csrf
                .ignoringRequestMatchers("/api/*")
            );
        return http.build();
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.annotation.web.invoke

@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            csrf {
                ignoringRequestMatchers("/api/*")
            }
        }
        return http.build()
    }
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<csrf request-matcher-ref="csrfMatcher"/>
</http>
<b:bean id="csrfMatcher"
    class="org.springframework.security.web.util.matcher.AndRequestMatcher">
    <b:constructor-arg value="#{T(org.springframework.security.web.csrf.CsrfFilter).DEFAULT_CSRF_MATCHER}"/>
    <b:constructor-arg>
        <b:bean class="org.springframework.security.web.util.matcher.NegatedRequestMatcher">
            <b:bean class="org.springframework.security.web.util.matcher.AntPathRequestMatcher">
                <b:constructor-arg value="/api/*"/>
            </b:bean>
        </b:bean>
    </b:constructor-arg>
</b:bean>
----
======

如果您需要禁用 CSRF 防护，可以使用以下配置：

[[disable-csrf-configuration]]
.禁用 CSRF
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.csrf((csrf) -> csrf.disable());
		return http.build();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.annotation.web.invoke

@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            csrf {
                disable()
            }
        }
        return http.build()
    }
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<csrf disabled="true"/>
</http>
----
======

[[csrf-considerations]]
== CSRF 注意事项

在实施针对 CSRF 攻击的防护时，有几个特殊的注意事项。
本节讨论这些注意事项在 Servlet 环境中的具体情况。
有关更一般的讨论，请参阅 xref:features/exploits/csrf.adoc#csrf-considerations[CSRF 注意事项]。

[[csrf-considerations-login]]
=== 登录

xref:features/exploits/csrf.adoc#csrf-considerations-login[要求登录请求进行 CSRF 验证] 以防止伪造登录尝试非常重要。
Spring Security 的 Servlet 支持开箱即用。

[[csrf-considerations-logout]]
=== 注销

xref:features/exploits/csrf.adoc#csrf-considerations-logout[要求注销请求进行 CSRF 验证] 以防止伪造注销尝试非常重要。
如果启用了 CSRF 防护（默认），Spring Security 的 `LogoutFilter` 将仅处理 HTTP POST 请求。
这确保了注销需要 CSRF 令牌，并且恶意用户无法强制注销您的用户。

最简单的方法是使用表单注销用户。
如果您真的想要一个链接，可以使用 JavaScript 让链接执行 POST（也许在一个隐藏表单上）。
对于禁用 JavaScript 的浏览器，您可以选择让链接将用户带到一个执行 POST 的注销确认页面。

如果您真的想在注销时使用 HTTP GET，可以这样做。
但是，请记住这通常不推荐。
例如，以下内容在 `/logout` URL 以任何 HTTP 方法请求时注销：

.使用任何 HTTP 方法注销
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.logout((logout) -> logout
				.logoutRequestMatcher(new AntPathRequestMatcher("/logout"))
			);
		return http.build();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.annotation.web.invoke

@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            logout {
                logoutRequestMatcher = AntPathRequestMatcher("/logout")
            }
        }
        return http.build()
    }
}
----
======

有关更多信息，请参阅 xref:servlet/authentication/logout.adoc[注销] 章节。

[[considerations-csrf-timeouts]]
=== CSRF 和会话超时

默认情况下，Spring Security 使用 <<csrf-token-repository-httpsession,`HttpSessionCsrfTokenRepository`>> 将 CSRF 令牌存储在 `HttpSession` 中。
这可能导致会话过期，从而没有 CSRF 令牌可供验证。

我们已经讨论了 xref:features/exploits/csrf.adoc#csrf-considerations-timeouts[会话超时的一般解决方案]。
本节讨论与 Servlet 支持相关的 CSRF 超时的具体情况。

您可以将 CSRF 令牌的存储更改为 cookie 中。
有关详细信息，请参阅 <<csrf-token-repository-cookie>> 部分。

如果令牌确实过期，您可能希望通过指定 <<csrf-access-denied-handler,自定义 `AccessDeniedHandler`>> 来自定义其处理方式。
自定义的 `AccessDeniedHandler` 可以以任何您喜欢的方式处理 `InvalidCsrfTokenException`。

[[csrf-considerations-multipart]]
=== 多部分（文件上传）

我们已经 xref:features/exploits/csrf.adoc#csrf-considerations-multipart[讨论过] 如何保护多部分请求（文件上传）免受 CSRF 攻击会导致 https://en.wikipedia.org/wiki/Chicken_or_the_egg[鸡生蛋还是蛋生鸡] 的问题。
当 JavaScript 可用时，我们 _建议_ <<csrf-integration-javascript-other,在 HTTP 请求头中包含 CSRF 令牌>> 来绕过这个问题。

如果 JavaScript 不可用，以下部分讨论了在 Servlet 应用程序中将 CSRF 令牌放置在 <<csrf-considerations-multipart-body,body>> 和 <<csrf-considerations-multipart-url,url>> 中的选项。

[NOTE]
====
您可以在 Spring 参考文档的 https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart[Multipart Resolver] 部分和 {spring-framework-api-url}org/springframework/web/multipart/support/MultipartFilter.html[`MultipartFilter` javadoc] 中找到有关在 Spring 中使用多部分表单的更多信息。
====

[[csrf-considerations-multipart-body]]
==== 将 CSRF 令牌放在 body 中

我们已经 xref:features/exploits/csrf.adoc#csrf-considerations-multipart-body[讨论过] 将 CSRF 令牌放在 body 中的权衡。
在本节中，我们讨论如何配置 Spring Security 从 body 中读取 CSRF。

要从 body 中读取 CSRF 令牌，`MultipartFilter` 必须在 Spring Security 过滤器之前指定。
在 Spring Security 过滤器之前指定 `MultipartFilter` 意味着调用 `MultipartFilter` 没有授权，这意味着任何人都可以在您的服务器上放置临时文件。
然而，只有授权用户才能提交被您的应用程序处理的文件。
通常，这是推荐的方法，因为临时文件上传对大多数服务器的影响可以忽略不计。

.配置 `MultipartFilter`
[tabs]
======
Java::
+
[source,java,role="primary"]
----
public class SecurityApplicationInitializer extends AbstractSecurityWebApplicationInitializer {

	@Override
	protected void beforeSpringSecurityFilterChain(ServletContext servletContext) {
		insertFilters(servletContext, new MultipartFilter());
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
class SecurityApplicationInitializer : AbstractSecurityWebApplicationInitializer() {
    override fun beforeSpringSecurityFilterChain(servletContext: ServletContext?) {
        insertFilters(servletContext, MultipartFilter())
    }
}
----

XML::
+
[source,xml,role="secondary"]
----
<filter>
	<filter-name>MultipartFilter</filter-name>
	<filter-class>org.springframework.web.multipart.support.MultipartFilter</filter-class>
</filter>
<filter>
	<filter-name>springSecurityFilterChain</filter-name>
	<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
	<filter-name>MultipartFilter</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>
<filter-mapping>
	<filter-name>springSecurityFilterChain</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>
----
======

[NOTE]
====
为了确保在 XML 配置中 `MultipartFilter` 在 Spring Security 过滤器之前指定，您可以确保在 `web.xml` 文件中 `MultipartFilter` 的 `<filter-mapping>` 元素位于 `springSecurityFilterChain` 之前。
====

[[csrf-considerations-multipart-url]]
==== 在 URL 中包含 CSRF 令牌

如果允许未经授权的用户上传临时文件不可接受，另一种选择是将 `MultipartFilter` 放在 Spring Security 过滤器之后，并在表单的 action 属性中将 CSRF 作为查询参数包含。
由于 `CsrfToken` 作为 <<csrf-token-request-handler,名为 `_csrf` 的 `HttpServletRequest` 属性>> 暴露，我们可以使用它来创建一个包含 CSRF 令牌的 `action`。
以下示例在 JSP 中这样做：

.action 中的 CSRF 令牌
[source,html]
----
<form method="post"
	action="./upload?${_csrf.parameterName}=${_csrf.token}"
	enctype="multipart/form-data">
----

[[csrf-considerations-override-method]]
=== HiddenHttpMethodFilter

我们已经 xref:features/exploits/csrf.adoc#csrf-considerations-multipart-body[讨论过] 将 CSRF 令牌放在 body 中的权衡。

在 Spring 的 Servlet 支持中，通过使用 {spring-framework-api-url}org/springframework/web/filter/reactive/HiddenHttpMethodFilter.html[`HiddenHttpMethodFilter`] 来覆盖 HTTP 方法。
您可以在参考文档的 https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-rest-method-conversion[HTTP 方法转换] 部分找到更多信息。

[[csrf-further-reading]]
== 进一步阅读

现在您已经回顾了 CSRF 防护，请考虑进一步了解 xref:servlet/exploits/index.adoc[漏洞防护]，包括 xref:servlet/exploits/headers.adoc[安全头] 和 xref:servlet/exploits/firewall.adoc[HTTP 防火墙]，或者继续学习如何 xref:servlet/test/index.adoc[测试] 您的应用程序。