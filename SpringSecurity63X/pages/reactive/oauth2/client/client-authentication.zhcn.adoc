[[oauth2Client-client-auth-support]]
= 客户端认证支持

[[oauth2Client-client-credentials-auth]]
== 客户端凭据认证

=== 使用 `client_secret_basic` 进行认证

HTTP Basic 方式的客户端认证开箱即用，无需任何自定义配置即可启用。  
默认实现由 `DefaultOAuth2TokenRequestHeadersConverter` 提供。

给定以下用于 OAuth 2.0 客户端注册的 Spring Boot 配置属性：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: client-id
            client-secret: client-secret
            client-authentication-method: client_secret_basic
            authorization-grant-type: authorization_code
            ...
----

以下示例展示如何配置 `WebClientReactiveAuthorizationCodeTokenResponseClient` 以禁用客户端凭据的 URL 编码：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
DefaultOAuth2TokenRequestHeadersConverter<OAuth2AuthorizationCodeGrantRequest> headersConverter =
		new DefaultOAuth2TokenRequestHeadersConverter<>();
headersConverter.setEncodeClientCredentials(false);

WebClientReactiveAuthorizationCodeTokenResponseClient tokenResponseClient =
		new WebClientReactiveAuthorizationCodeTokenResponseClient();
tokenResponseClient.setHeadersConverter(headersConverter);
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val headersConverter = DefaultOAuth2TokenRequestHeadersConverter<OAuth2AuthorizationCodeGrantRequest>()
headersConverter.setEncodeClientCredentials(false)

val tokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient()
tokenResponseClient.setHeadersConverter(headersConverter)
----
======

=== 使用 `client_secret_post` 进行认证

将客户端凭据包含在请求体中的客户端认证方式也开箱即用，无需额外配置即可启用。

以下 Spring Boot 配置属性展示了 OAuth 2.0 客户端注册的相关配置示例：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: client-id
            client-secret: client-secret
            client-authentication-method: client_secret_post
            authorization-grant-type: authorization_code
            ...
----

[[oauth2Client-jwt-bearer-auth]]
== JWT Bearer 认证

[NOTE]
有关 https://datatracker.ietf.org/doc/html/rfc7523#section-2.2[JWT Bearer] 客户端认证的更多细节，请参考《OAuth 2.0 客户端认证与授权许可的 JSON Web Token (JWT) 规范》。

JWT Bearer 客户端认证的默认实现是 `NimbusJwtClientAuthenticationParametersConverter`，  
它是一个 `Converter`，通过在 `client_assertion` 参数中添加一个已签名的 JSON Web Token（JWS）来定制令牌请求参数。  

用于签名 JWS 的 `java.security.PrivateKey` 或 `javax.crypto.SecretKey` 由与 `NimbusJwtClientAuthenticationParametersConverter` 关联的 `com.nimbusds.jose.jwk.JWK` 解析器提供。

=== 使用 `private_key_jwt` 进行认证

给定以下用于 OAuth 2.0 客户端注册的 Spring Boot 配置属性：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-authentication-method: private_key_jwt
            authorization-grant-type: authorization_code
            ...
----

以下示例展示如何配置 `WebClientReactiveAuthorizationCodeTokenResponseClient`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
Function<ClientRegistration, JWK> jwkResolver = (clientRegistration) -> {
	if (clientRegistration.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.PRIVATE_KEY_JWT)) {
		// 假设使用 RSA 密钥类型
		RSAPublicKey publicKey = ...
		RSAPrivateKey privateKey = ...
		return new RSAKey.Builder(publicKey)
				.privateKey(privateKey)
				.keyID(UUID.randomUUID().toString())
				.build();
	}
	return null;
};

WebClientReactiveAuthorizationCodeTokenResponseClient tokenResponseClient =
		new WebClientReactiveAuthorizationCodeTokenResponseClient();
tokenResponseClient.addParametersConverter(
		new NimbusJwtClientAuthenticationParametersConverter<>(jwkResolver));
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val jwkResolver: Function<ClientRegistration, JWK> =
    Function<ClientRegistration, JWK> { clientRegistration ->
        if (clientRegistration.clientAuthenticationMethod.equals(ClientAuthenticationMethod.PRIVATE_KEY_JWT)) {
            // 假设使用 RSA 密钥类型
            var publicKey: RSAPublicKey = ...
            var privateKey: RSAPrivateKey = ...
            RSAKey.Builder(publicKey)
                    .privateKey(privateKey)
                    .keyID(UUID.randomUUID().toString())
                .build()
        }
        null
    }

val tokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient()
tokenResponseClient.addParametersConverter(
    NimbusJwtClientAuthenticationParametersConverter(jwkResolver)
)
----
======


=== 使用 `client_secret_jwt` 进行认证

给定以下用于 OAuth 2.0 客户端注册的 Spring Boot 配置属性：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            client-authentication-method: client_secret_jwt
            authorization-grant-type: client_credentials
            ...
----

以下示例展示如何配置 `WebClientReactiveClientCredentialsTokenResponseClient`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
Function<ClientRegistration, JWK> jwkResolver = (clientRegistration) -> {
	if (clientRegistration.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.CLIENT_SECRET_JWT)) {
		SecretKeySpec secretKey = new SecretKeySpec(
				clientRegistration.getClientSecret().getBytes(StandardCharsets.UTF_8),
				"HmacSHA256");
		return new OctetSequenceKey.Builder(secretKey)
				.keyID(UUID.randomUUID().toString())
				.build();
	}
	return null;
};

WebClientReactiveClientCredentialsTokenResponseClient tokenResponseClient =
		new WebClientReactiveClientCredentialsTokenResponseClient();
tokenResponseClient.addParametersConverter(
		new NimbusJwtClientAuthenticationParametersConverter<>(jwkResolver));
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val jwkResolver = Function<ClientRegistration, JWK?> { clientRegistration: ClientRegistration ->
    if (clientRegistration.clientAuthenticationMethod == ClientAuthenticationMethod.CLIENT_SECRET_JWT) {
        val secretKey = SecretKeySpec(
            clientRegistration.clientSecret.toByteArray(StandardCharsets.UTF_8),
            "HmacSHA256"
        )
        OctetSequenceKey.Builder(secretKey)
            .keyID(UUID.randomUUID().toString())
            .build()
    }
    null
}

val tokenResponseClient = WebClientReactiveClientCredentialsTokenResponseClient()
tokenResponseClient.addParametersConverter(
    NimbusJwtClientAuthenticationParametersConverter(jwkResolver)
)
----
======

=== 自定义 JWT 断言

`NimbusJwtClientAuthenticationParametersConverter` 生成的 JWT 默认包含 `iss`、`sub`、`aud`、`jti`、`iat` 和 `exp` 声明。  
你可以通过调用 `setJwtClientAssertionCustomizer()` 并传入一个 `Consumer<NimbusJwtClientAuthenticationParametersConverter.JwtClientAuthenticationContext<T>>` 来自定义 JWT 的头部和/或声明。  
以下示例展示如何自定义 JWT 的声明：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
Function<ClientRegistration, JWK> jwkResolver = ...

NimbusJwtClientAuthenticationParametersConverter<OAuth2ClientCredentialsGrantRequest> converter =
		new NimbusJwtClientAuthenticationParametersConverter<>(jwkResolver);
converter.setJwtClientAssertionCustomizer((context) -> {
	context.getHeaders().header("custom-header", "header-value");
	context.getClaims().claim("custom-claim", "claim-value");
});
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val jwkResolver = ...

val converter: NimbusJwtClientAuthenticationParametersConverter<OAuth2ClientCredentialsGrantRequest> =
    NimbusJwtClientAuthenticationParametersConverter(jwkResolver)
converter.setJwtClientAssertionCustomizer { context ->
    context.headers.header("custom-header", "header-value")
    context.claims.claim("custom-claim", "claim-value")
}
----
======

[[oauth2Client-public-auth]]
== 公共客户端认证

公共客户端认证开箱即用，无需任何自定义即可启用。

以下 Spring Boot 配置属性展示了 OAuth 2.0 客户端注册的配置示例：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: client-id
            client-authentication-method: none
            authorization-grant-type: authorization_code
            ...
----

[NOTE]
当 `client-authentication-method` 设置为 "none"（即 `ClientAuthenticationMethod.NONE`）时，系统会自动使用 https://tools.ietf.org/html/rfc7636[Proof Key for Code Exchange]（PKCE）来支持公共客户端。