[[oauth2Client-auth-grant-support]]
= 授权授予支持

[[oauth2Client-auth-code-grant]]
== 授权码

[NOTE]
有关授权码授权的更多详细信息，请参阅 OAuth 2.0 授权框架中的 https://tools.ietf.org/html/rfc6749#section-1.3.1[授权码] 授予。

=== 获取授权

[NOTE]
请参考 https://tools.ietf.org/html/rfc6749#section-4.1.1[授权请求/响应] 协议流程以了解授权码授权。

=== 发起授权请求

`OAuth2AuthorizationRequestRedirectWebFilter` 使用 `ServerOAuth2AuthorizationRequestResolver` 来解析 `OAuth2AuthorizationRequest`，并通过将最终用户的用户代理重定向到授权服务器的授权端点来启动授权码授权流程。

`ServerOAuth2AuthorizationRequestResolver` 的主要作用是从提供的 Web 请求中解析出一个 `OAuth2AuthorizationRequest`。默认实现 `DefaultServerOAuth2AuthorizationRequestResolver` 匹配（默认）路径 `+/oauth2/authorization/{registrationId}+`，提取 `registrationId` 并使用它为关联的 `ClientRegistration` 构建 `OAuth2AuthorizationRequest`。

给定以下用于 OAuth 2.0 客户端注册的 Spring Boot 属性：

[source,yaml,attrs="-attributes"]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/authorized/okta"
            scope: read, write
        provider:
          okta:
            authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token
----

对基本路径 `/oauth2/authorization/okta` 的请求将由 `OAuth2AuthorizationRequestRedirectWebFilter` 发起授权请求重定向，并最终启动授权码授权流程。

[NOTE]
`AuthorizationCodeReactiveOAuth2AuthorizedClientProvider` 是针对授权码授权的 `ReactiveOAuth2AuthorizedClientProvider` 实现，
它也会通过 `OAuth2AuthorizationRequestRedirectWebFilter` 发起授权请求重定向。

如果 OAuth 2.0 客户端是一个 https://tools.ietf.org/html/rfc6749#section-2.1[公共客户端]，则按如下方式配置 OAuth 2.0 客户端注册：

[source,yaml,attrs="-attributes"]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-authentication-method: none
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/authorized/okta"
            ...
----

公共客户端支持使用 https://tools.ietf.org/html/rfc7636[代码交换证明密钥] (PKCE)。
如果客户端在不受信任的环境中运行（例如本地应用程序或基于 Web 浏览器的应用程序），因此无法维护其凭据的机密性，则在满足以下条件时会自动使用 PKCE：

. `client-secret` 被省略（或为空）
. `client-authentication-method` 设置为 "none" (`ClientAuthenticationMethod.NONE`)

[TIP]
如果 OAuth 2.0 提供者支持 https://tools.ietf.org/html/rfc6749#section-2.1[保密客户端] 的 PKCE，您可以选择使用 `DefaultServerOAuth2AuthorizationRequestResolver.setAuthorizationRequestCustomizer(OAuth2AuthorizationRequestCustomizers.withPkce())` 进行配置。

[[oauth2Client-auth-code-redirect-uri]]
`DefaultServerOAuth2AuthorizationRequestResolver` 还支持使用 `UriComponentsBuilder` 对 `redirect-uri` 使用 `URI` 模板变量。

以下配置使用了所有支持的 `URI` 模板变量：

[source,yaml,attrs="-attributes"]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            ...
            redirect-uri: "{baseScheme}://{baseHost}{basePort}{basePath}/authorized/{registrationId}"
            ...
----

[NOTE]
`+{baseUrl}+` 解析为 `+{baseScheme}://{baseHost}{basePort}{basePath}+`

使用 `URI` 模板变量配置 `redirect-uri` 特别适用于当 OAuth 2.0 客户端在 xref:features/exploits/http.adoc#http-proxy-server[代理服务器] 后面运行的情况。
这确保在展开 `redirect-uri` 时使用 `X-Forwarded-*` 头部。

=== 自定义授权请求

`ServerOAuth2AuthorizationRequestResolver` 可以实现的一个主要用例是能够在标准参数之外自定义授权请求并添加额外参数，这些参数超出了 OAuth 2.0 授权框架中定义的标准参数。

例如，OpenID Connect 在 https://tools.ietf.org/html/rfc6749#section-4.1.1[OAuth 2.0 授权框架] 中定义的标准参数基础上，为 https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest[授权码流] 定义了额外的 OAuth 2.0 请求参数。
其中一个扩展参数是 `prompt` 参数。

[NOTE]
====
`prompt` 参数是可选的。由空格分隔、区分大小写的 ASCII 字符串列表，指定授权服务器是否提示最终用户重新认证和同意。定义的值包括：`none`、`login`、`consent` 和 `select_account`。
====

以下示例展示了如何使用 `Consumer<OAuth2AuthorizationRequest.Builder>` 配置 `DefaultServerOAuth2AuthorizationRequestResolver`，通过包含请求参数 `prompt=consent` 来自定义 `oauth2Login()` 的授权请求。

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebFluxSecurity
public class OAuth2LoginSecurityConfig {

	@Autowired
	private ReactiveClientRegistrationRepository clientRegistrationRepository;

	@Bean
	public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
		http
			.authorizeExchange(authorize -> authorize
				.anyExchange().authenticated()
			)
			.oauth2Login(oauth2 -> oauth2
				.authorizationRequestResolver(
					authorizationRequestResolver(this.clientRegistrationRepository)
				)
			);
		return http.build();
	}

	private ServerOAuth2AuthorizationRequestResolver authorizationRequestResolver(
			ReactiveClientRegistrationRepository clientRegistrationRepository) {

		DefaultServerOAuth2AuthorizationRequestResolver authorizationRequestResolver =
				new DefaultServerOAuth2AuthorizationRequestResolver(
						clientRegistrationRepository);
		authorizationRequestResolver.setAuthorizationRequestCustomizer(
				authorizationRequestCustomizer());

		return  authorizationRequestResolver;
	}

	private Consumer<OAuth2AuthorizationRequest.Builder> authorizationRequestCustomizer() {
		return customizer -> customizer
					.additionalParameters(params -> params.put("prompt", "consent"));
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebFluxSecurity
class SecurityConfig {

    @Autowired
    private lateinit var customClientRegistrationRepository: ReactiveClientRegistrationRepository

    @Bean
    fun securityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
        http {
            authorizeExchange {
                authorize(anyExchange, authenticated)
            }
            oauth2Login {
                authorizationRequestResolver = authorizationRequestResolver(customClientRegistrationRepository)
            }
        }

        return http.build()
    }

    private fun authorizationRequestResolver(
            clientRegistrationRepository: ReactiveClientRegistrationRepository): ServerOAuth2AuthorizationRequestResolver {
        val authorizationRequestResolver = DefaultServerOAuth2AuthorizationRequestResolver(
                clientRegistrationRepository)
        authorizationRequestResolver.setAuthorizationRequestCustomizer(
                authorizationRequestCustomizer())
        return authorizationRequestResolver
    }

    private fun authorizationRequestCustomizer(): Consumer<OAuth2AuthorizationRequest.Builder> {
        return Consumer { customizer ->
            customizer
                .additionalParameters { params -> params["prompt"] = "consent" }
        }
    }
}
----
======

对于简单的用例，如果特定提供者的附加请求参数始终相同，则可以直接在 `authorization-uri` 属性中添加。

例如，如果提供者 `okta` 的请求参数 `prompt` 的值始终为 `consent`，那么只需如下配置：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        provider:
          okta:
            authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize?prompt=consent
----

前面的示例展示了在标准参数之上添加自定义参数的常见用例。
另外，如果你的需求更复杂，可以通过简单地覆盖 `OAuth2AuthorizationRequest.authorizationRequestUri` 属性来完全控制构建授权请求 URI 的过程。

[TIP]
`OAuth2AuthorizationRequest.Builder.build()` 构造 `OAuth2AuthorizationRequest.authorizationRequestUri`，该属性表示包含所有查询参数的授权请求 URI，采用 `application/x-www-form-urlencoded` 格式。

以下示例展示了前述示例中 `authorizationRequestCustomizer()` 的变体，并且覆盖了 `OAuth2AuthorizationRequest.authorizationRequestUri` 属性。

[tabs]
======
Java::
+
[source,java,role="primary"]
----
private Consumer<OAuth2AuthorizationRequest.Builder> authorizationRequestCustomizer() {
	return customizer -> customizer
			.authorizationRequestUri(uriBuilder -> uriBuilder
					.queryParam("prompt", "consent").build());
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
private fun authorizationRequestCustomizer(): Consumer<OAuth2AuthorizationRequest.Builder> {
    return Consumer { customizer: OAuth2AuthorizationRequest.Builder ->
        customizer
                .authorizationRequestUri { uriBuilder: UriBuilder ->
                    uriBuilder
                            .queryParam("prompt", "consent").build()
                }
    }
}
----
======


=== 存储授权请求

`ServerAuthorizationRequestRepository` 负责从发起授权请求到接收到授权响应（回调）期间的 `OAuth2AuthorizationRequest` 持久化。

[TIP]
`OAuth2AuthorizationRequest` 用于关联和验证授权响应。

`ServerAuthorizationRequestRepository` 的默认实现是 `WebSessionOAuth2ServerAuthorizationRequestRepository`，它将 `OAuth2AuthorizationRequest` 存储在 `WebSession` 中。

如果你有自定义的 `ServerAuthorizationRequestRepository` 实现，可以按以下示例进行配置：

.ServerAuthorizationRequestRepository 配置
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebFluxSecurity
public class OAuth2ClientSecurityConfig {

	@Bean
	public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
		http
			.oauth2Client(oauth2 -> oauth2
				.authorizationRequestRepository(this.authorizationRequestRepository())
				...
			);
		return http.build();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebFluxSecurity
class OAuth2ClientSecurityConfig {

    @Bean
    fun securityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
        http {
            oauth2Client {
                authorizationRequestRepository = authorizationRequestRepository()
            }
        }

        return http.build()
    }
}
----
======

=== 请求访问令牌

[NOTE]
请参考 https://tools.ietf.org/html/rfc6749#section-4.1.3[访问令牌请求/响应] 协议流程以了解授权码授权。

授权码授权的 `ReactiveOAuth2AccessTokenResponseClient` 默认实现是 `WebClientReactiveAuthorizationCodeTokenResponseClient`，它使用 `WebClient` 在授权服务器的令牌端点处交换授权码以获取访问令牌。

`WebClientReactiveAuthorizationCodeTokenResponseClient` 非常灵活，因为它允许你自定义令牌请求的预处理和/或令牌响应的后处理。


=== 自定义访问令牌请求

如果你需要自定义令牌请求的预处理，可以为 `WebClientReactiveAuthorizationCodeTokenResponseClient.setParametersConverter()` 提供一个自定义的 `Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>>`。
默认实现构建了一个只包含标准 https://tools.ietf.org/html/rfc6749#section-4.1.3[OAuth 2.0 访问令牌请求] 中 `grant_type` 参数的 `MultiValueMap<String, String>`，用于构造请求。其他授权码授权所需的参数直接由 `WebClientReactiveAuthorizationCodeTokenResponseClient` 添加到请求体中。然而，提供一个自定义的 `Converter` 将允许你扩展标准令牌请求并添加自定义参数。

[TIP]
如果你只想添加额外参数，可以改为为 `WebClientReactiveAuthorizationCodeTokenResponseClient.addParametersConverter()` 提供一个自定义的 `Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>>`，它会构建一个聚合 `Converter`。

IMPORTANT: 自定义 `Converter` 必须返回目标 OAuth 2.0 提供商能够理解的有效 OAuth 2.0 访问令牌请求参数。


=== 自定义访问令牌响应

另一方面，如果你需要自定义令牌响应的后处理，你需要为 `WebClientReactiveAuthorizationCodeTokenResponseClient.setBodyExtractor()` 提供一个自定义配置的 `BodyExtractor<Mono<OAuth2AccessTokenResponse>, ReactiveHttpInputMessage>`，用于将 OAuth 2.0 访问令牌响应转换为 `OAuth2AccessTokenResponse`。由 `OAuth2BodyExtractors.oauth2AccessTokenResponse()` 提供的默认实现会解析响应并相应地处理错误。

=== 自定义 `WebClient`

或者，如果你的需求更高级，你可以通过为 `WebClientReactiveAuthorizationCodeTokenResponseClient.setWebClient()` 提供一个自定义配置的 `WebClient` 来完全控制请求/响应。

无论你是自定义 `WebClientReactiveAuthorizationCodeTokenResponseClient` 还是提供自己的 `ReactiveOAuth2AccessTokenResponseClient` 实现，都需要按以下示例进行配置：

.访问令牌响应配置
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebFluxSecurity
public class OAuth2ClientSecurityConfig {

	@Bean
	public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
		http
			.oauth2Client(oauth2 -> oauth2
				.authenticationManager(this.authorizationCodeAuthenticationManager())
				...
			);
		return http.build();
	}

	private ReactiveAuthenticationManager authorizationCodeAuthenticationManager() {
		WebClientReactiveAuthorizationCodeTokenResponseClient accessTokenResponseClient =
				new WebClientReactiveAuthorizationCodeTokenResponseClient();
		...

		return new OAuth2AuthorizationCodeReactiveAuthenticationManager(accessTokenResponseClient);
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebFluxSecurity
class OAuth2ClientSecurityConfig {

    @Bean
    fun securityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
        http {
            oauth2Client {
                authenticationManager = authorizationCodeAuthenticationManager()
            }
        }

        return http.build()
    }

    private fun authorizationCodeAuthenticationManager(): ReactiveAuthenticationManager {
        val accessTokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient()
        ...

        return OAuth2AuthorizationCodeReactiveAuthenticationManager(accessTokenResponseClient)
    }
}
----
======


[[oauth2Client-refresh-token-grant]]
== 刷新令牌

[NOTE]
请参考 OAuth 2.0 授权框架以了解更多关于 https://tools.ietf.org/html/rfc6749#section-1.5[刷新令牌] 的详细信息。

=== 刷新访问令牌

[NOTE]
请参考 https://tools.ietf.org/html/rfc6749#section-6[访问令牌请求/响应] 协议流程以了解刷新令牌授权。

刷新令牌授权的 `ReactiveOAuth2AccessTokenResponseClient` 默认实现是 `WebClientReactiveRefreshTokenTokenResponseClient`，它使用 `WebClient` 在授权服务器的令牌端点刷新访问令牌。

`WebClientReactiveRefreshTokenTokenResponseClient` 非常灵活，因为它允许你自定义令牌请求的预处理和/或令牌响应的后处理。


=== 自定义访问令牌请求

如果你需要自定义令牌请求的预处理，可以为 `WebClientReactiveRefreshTokenTokenResponseClient.setParametersConverter()` 提供一个自定义的 `Converter<OAuth2RefreshTokenGrantRequest, MultiValueMap<String, String>>`。
默认实现构建了一个只包含标准 https://tools.ietf.org/html/rfc6749#section-6[OAuth 2.0 访问令牌请求] 中 `grant_type` 参数的 `MultiValueMap<String, String>`，用于构造请求。其他刷新令牌授权所需的参数直接由 `WebClientReactiveRefreshTokenTokenResponseClient` 添加到请求体中。然而，提供一个自定义的 `Converter` 将允许你扩展标准令牌请求并添加自定义参数。

[TIP]
如果你只想添加额外参数，可以改为为 `WebClientReactiveRefreshTokenTokenResponseClient.addParametersConverter()` 提供一个自定义的 `Converter<OAuth2RefreshTokenGrantRequest, MultiValueMap<String, String>>`，它会构建一个聚合 `Converter`。

IMPORTANT: 自定义 `Converter` 必须返回目标 OAuth 2.0 提供商能够理解的有效 OAuth 2.0 访问令牌请求参数。


=== 自定义访问令牌响应

另一方面，如果你需要自定义令牌响应的后处理，你需要为 `WebClientReactiveRefreshTokenTokenResponseClient.setBodyExtractor()` 提供一个自定义配置的 `BodyExtractor<Mono<OAuth2AccessTokenResponse>, ReactiveHttpInputMessage>`，用于将 OAuth 2.0 访问令牌响应转换为 `OAuth2AccessTokenResponse`。由 `OAuth2BodyExtractors.oauth2AccessTokenResponse()` 提供的默认实现会解析响应并相应地处理错误。

=== 自定义 `WebClient`

或者，如果你的需求更高级，你可以通过为 `WebClientReactiveRefreshTokenTokenResponseClient.setWebClient()` 提供一个自定义配置的 `WebClient` 来完全控制请求/响应。

无论你是自定义 `WebClientReactiveRefreshTokenTokenResponseClient` 还是提供自己的 `ReactiveOAuth2AccessTokenResponseClient` 实现，都需要按以下示例进行配置：

.访问令牌响应配置
[tabs]
======
Java::
+
[source,java,role="primary"]
----
// Customize
ReactiveOAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> refreshTokenTokenResponseClient = ...

ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
		ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
				.authorizationCode()
				.refreshToken(configurer -> configurer.accessTokenResponseClient(refreshTokenTokenResponseClient))
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
// Customize
val refreshTokenTokenResponseClient: ReactiveOAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> = ...

val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
        .authorizationCode()
        .refreshToken { it.accessTokenResponseClient(refreshTokenTokenResponseClient) }
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
----
======

[NOTE]
`ReactiveOAuth2AuthorizedClientProviderBuilder.builder().refreshToken()` 配置了一个 `RefreshTokenReactiveOAuth2AuthorizedClientProvider`，
它是针对刷新令牌授权的 `ReactiveOAuth2AuthorizedClientProvider` 实现。

`OAuth2RefreshToken` 可能作为 `authorization_code` 和 `password` 授权类型的访问令牌响应的一部分被返回。
如果 `OAuth2AuthorizedClient.getRefreshToken()` 可用并且 `OAuth2AuthorizedClient.getAccessToken()` 已过期，`RefreshTokenReactiveOAuth2AuthorizedClientProvider` 将自动刷新它。


[[oauth2Client-client-creds-grant]]
== 客户端凭证

[NOTE]
请参考 OAuth 2.0 授权框架以了解更多关于 https://tools.ietf.org/html/rfc6749#section-1.3.4[客户端凭证] 授权的详细信息。

=== 请求访问令牌

[NOTE]
请参考 https://tools.ietf.org/html/rfc6749#section-4.4.2[访问令牌请求/响应] 协议流程以了解客户端凭证授权。

客户端凭证授权的 `ReactiveOAuth2AccessTokenResponseClient` 默认实现是 `WebClientReactiveClientCredentialsTokenResponseClient`，它使用 `WebClient` 在授权服务器的令牌端点请求访问令牌。

`WebClientReactiveClientCredentialsTokenResponseClient` 非常灵活，因为它允许你自定义令牌请求的预处理和/或令牌响应的后处理。


=== 自定义访问令牌请求

如果你需要自定义令牌请求的预处理，可以为 `WebClientReactiveClientCredentialsTokenResponseClient.setParametersConverter()` 提供一个自定义的 `Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>>`。
默认实现构建了一个只包含标准 https://tools.ietf.org/html/rfc6749#section-4.4.2[OAuth 2.0 访问令牌请求] 中 `grant_type` 参数的 `MultiValueMap<String, String>`，用于构造请求。其他客户端凭证授权所需的参数直接由 `WebClientReactiveClientCredentialsTokenResponseClient` 添加到请求体中。然而，提供一个自定义的 `Converter` 将允许你扩展标准令牌请求并添加自定义参数。

[TIP]
如果你只想添加额外参数，可以改为为 `WebClientReactiveClientCredentialsTokenResponseClient.addParametersConverter()` 提供一个自定义的 `Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>>`，它会构建一个聚合 `Converter`。

IMPORTANT: 自定义 `Converter` 必须返回目标 OAuth 2.0 提供商能够理解的有效 OAuth 2.0 访问令牌请求参数。


=== 自定义访问令牌响应

另一方面，如果你需要自定义令牌响应的后处理，你需要为 `WebClientReactiveClientCredentialsTokenResponseClient.setBodyExtractor()` 提供一个自定义配置的 `BodyExtractor<Mono<OAuth2AccessTokenResponse>, ReactiveHttpInputMessage>`，用于将 OAuth 2.0 访问令牌响应转换为 `OAuth2AccessTokenResponse`。由 `OAuth2BodyExtractors.oauth2AccessTokenResponse()` 提供的默认实现会解析响应并相应地处理错误。

=== 自定义 `WebClient`

或者，如果你的需求更高级，你可以通过为 `WebClientReactiveClientCredentialsTokenResponseClient.setWebClient()` 提供一个自定义配置的 `WebClient` 来完全控制请求/响应。

无论你是自定义 `WebClientReactiveClientCredentialsTokenResponseClient` 还是提供自己的 `ReactiveOAuth2AccessTokenResponseClient` 实现，都需要按以下示例进行配置：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
// Customize
ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsTokenResponseClient = ...

ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
		ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
				.clientCredentials(configurer -> configurer.accessTokenResponseClient(clientCredentialsTokenResponseClient))
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
// Customize
val clientCredentialsTokenResponseClient: ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> = ...

val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
        .clientCredentials { it.accessTokenResponseClient(clientCredentialsTokenResponseClient) }
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
----
======

[NOTE]
`ReactiveOAuth2AuthorizedClientProviderBuilder.builder().clientCredentials()` 配置了一个 `ClientCredentialsReactiveOAuth2AuthorizedClientProvider`，
它是针对客户端凭证授权的 `ReactiveOAuth2AuthorizedClientProvider` 实现。

=== 使用访问令牌

给定以下用于 OAuth 2.0 客户端注册的 Spring Boot 属性：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: client_credentials
            scope: read, write
        provider:
          okta:
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token
----

...以及 `ReactiveOAuth2AuthorizedClientManager` `@Bean`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public ReactiveOAuth2AuthorizedClientManager authorizedClientManager(
		ReactiveClientRegistrationRepository clientRegistrationRepository,
		ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {

	ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
			ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
					.clientCredentials()
					.build();

	DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultReactiveOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ReactiveClientRegistrationRepository,
        authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager {
    val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
            .clientCredentials()
            .build()
    val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}
----
======

你可以如下获取 `OAuth2AccessToken`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Controller
public class OAuth2ClientController {

	@Autowired
	private ReactiveOAuth2AuthorizedClientManager authorizedClientManager;

	@GetMapping("/")
	public Mono<String> index(Authentication authentication, ServerWebExchange exchange) {
		OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
				.principal(authentication)
				.attribute(ServerWebExchange.class.getName(), exchange)
				.build();

		return this.authorizedClientManager.authorize(authorizeRequest)
				.map(OAuth2AuthorizedClient::getAccessToken)
				...
				.thenReturn("index");
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
class OAuth2ClientController {

    @Autowired
    private lateinit var authorizedClientManager: ReactiveOAuth2AuthorizedClientManager

    @GetMapping("/")
    fun index(authentication: Authentication, exchange: ServerWebExchange): Mono<String> {
        val authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
                .principal(authentication)
                .attribute(ServerWebExchange::class.java.name, exchange)
                .build()

        return authorizedClientManager.authorize(authorizeRequest)
                .map { it.accessToken }
                ...
                .thenReturn("index")
    }
}
----
======

[NOTE]
`ServerWebExchange` 是一个可选属性。
如果未提供，它将通过键 `ServerWebExchange.class` 从 https://projectreactor.io/docs/core/release/reference/#context[Reactor 上下文] 中获取。


[[oauth2Client-password-grant]]
== 资源所有者密码凭证

[NOTE]
请参考 OAuth 2.0 授权框架以了解更多关于 https://tools.ietf.org/html/rfc6749#section-1.3.3[资源所有者密码凭证] 授权的详细信息。

=== 请求访问令牌

[NOTE]
请参考 https://tools.ietf.org/html/rfc6749#section-4.3.2[访问令牌请求/响应] 协议流程以了解资源所有者密码凭证授权。

资源所有者密码凭证授权的 `ReactiveOAuth2AccessTokenResponseClient` 默认实现是 `WebClientReactivePasswordTokenResponseClient`，它使用 `WebClient` 在授权服务器的令牌端点请求访问令牌。

`WebClientReactivePasswordTokenResponseClient` 非常灵活，因为它允许你自定义令牌请求的预处理和/或令牌响应的后处理。


=== 自定义访问令牌请求

如果你需要自定义令牌请求的预处理，可以为 `WebClientReactivePasswordTokenResponseClient.setParametersConverter()` 提供一个自定义的 `Converter<OAuth2PasswordGrantRequest, MultiValueMap<String, String>>`。
默认实现构建了一个只包含标准 https://tools.ietf.org/html/rfc6749#section-4.4.2[OAuth 2.0 访问令牌请求] 中 `grant_type` 参数的 `MultiValueMap<String, String>`，用于构造请求。其他资源所有者密码凭证授权所需的参数直接由 `WebClientReactivePasswordTokenResponseClient` 添加到请求体中。然而，提供一个自定义的 `Converter` 将允许你扩展标准令牌请求并添加自定义参数。

[TIP]
如果你只想添加额外参数，可以改为为 `WebClientReactivePasswordTokenResponseClient.addParametersConverter()` 提供一个自定义的 `Converter<OAuth2PasswordGrantRequest, MultiValueMap<String, String>>`，它会构建一个聚合 `Converter`。

IMPORTANT: 自定义 `Converter` 必须返回目标 OAuth 2.0 提供商能够理解的有效 OAuth 2.0 访问令牌请求参数。


=== 自定义访问令牌响应

另一方面，如果你需要自定义令牌响应的后处理，你需要为 `WebClientReactivePasswordTokenResponseClient.setBodyExtractor()` 提供一个自定义配置的 `BodyExtractor<Mono<OAuth2AccessTokenResponse>, ReactiveHttpInputMessage>`，用于将 OAuth 2.0 访问令牌响应转换为 `OAuth2AccessTokenResponse`。由 `OAuth2BodyExtractors.oauth2AccessTokenResponse()` 提供的默认实现会解析响应并相应地处理错误。

=== 自定义 `WebClient`

或者，如果你的需求更高级，你可以通过为 `WebClientReactivePasswordTokenResponseClient.setWebClient()` 提供一个自定义配置的 `WebClient` 来完全控制请求/响应。

无论你是自定义 `WebClientReactivePasswordTokenResponseClient` 还是提供自己的 `ReactiveOAuth2AccessTokenResponseClient` 实现，都需要按以下示例进行配置：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
// Customize
ReactiveOAuth2AccessTokenResponseClient<OAuth2PasswordGrantRequest> passwordTokenResponseClient = ...

ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
		ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
				.password(configurer -> configurer.accessTokenResponseClient(passwordTokenResponseClient))
				.refreshToken()
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val passwordTokenResponseClient: ReactiveOAuth2AccessTokenResponseClient<OAuth2PasswordGrantRequest> = ...

val authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
        .password { it.accessTokenResponseClient(passwordTokenResponseClient) }
        .refreshToken()
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
----
======

[NOTE]
`ReactiveOAuth2AuthorizedClientProviderBuilder.builder().password()` 配置了一个 `PasswordReactiveOAuth2AuthorizedClientProvider`，
它是针对资源所有者密码凭证授权的 `ReactiveOAuth2AuthorizedClientProvider` 实现。

=== 使用访问令牌

给定以下用于 OAuth 2.0 客户端注册的 Spring Boot 属性：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: password
            scope: read, write
        provider:
          okta:
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token
----

...以及 `ReactiveOAuth2AuthorizedClientManager` `@Bean`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public ReactiveOAuth2AuthorizedClientManager authorizedClientManager(
		ReactiveClientRegistrationRepository clientRegistrationRepository,
		ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {

	ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
			ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
					.password()
					.refreshToken()
					.build();

	DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultReactiveOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	// 假设 `username` 和 `password` 作为 `ServerHttpRequest` 参数提供，
	// 将 `ServerHttpRequest` 参数映射到 `OAuth2AuthorizationContext.getAttributes()`
	authorizedClientManager.setContextAttributesMapper(contextAttributesMapper());

	return authorizedClientManager;
}

private Function<OAuth2AuthorizeRequest, Mono<Map<String, Object>>> contextAttributesMapper() {
	return authorizeRequest -> {
		Map<String, Object> contextAttributes = Collections.emptyMap();
		ServerWebExchange exchange = authorizeRequest.getAttribute(ServerWebExchange.class.getName());
		ServerHttpRequest request = exchange.getRequest();
		String username = request.getQueryParams().getFirst(OAuth2ParameterNames.USERNAME);
		String password = request.getQueryParams().getFirst(OAuth2ParameterNames.PASSWORD);
		if (StringUtils.hasText(username) && StringUtils.hasText(password)) {
			contextAttributes = new HashMap<>();

			// `PasswordReactiveOAuth2AuthorizedClientProvider` 需要这两个属性
			contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username);
			contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password);
		}
		return Mono.just(contextAttributes);
	};
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ReactiveClientRegistrationRepository,
        authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager {
    val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
            .password()
            .refreshToken()
            .build()
    val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)

    // 假设 `username` 和 `password` 作为 `ServerHttpRequest` 参数提供，
    // 将 `ServerHttpRequest` 参数映射到 `OAuth2AuthorizationContext.getAttributes()`
    authorizedClientManager.setContextAttributesMapper(contextAttributesMapper())
    return authorizedClientManager
}

private fun contextAttributesMapper(): Function<OAuth2AuthorizeRequest, Mono<MutableMap<String, Any>>> {
    return Function { authorizeRequest ->
        var contextAttributes: MutableMap<String, Any> = mutableMapOf()
        val exchange: ServerWebExchange = authorizeRequest.getAttribute(ServerWebExchange::class.java.name)!!
        val request: ServerHttpRequest = exchange.request
        val username: String? = request.queryParams.getFirst(OAuth2ParameterNames.USERNAME)
        val password: String? = request.queryParams.getFirst(OAuth2ParameterNames.PASSWORD)
        if (StringUtils.hasText(username) && StringUtils.hasText(password)) {
            contextAttributes = hashMapOf()

            // `PasswordReactiveOAuth2AuthorizedClientProvider` 需要这两个属性
            contextAttributes[OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME] = username!!
            contextAttributes[OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME] = password!!
        }
        Mono.just(contextAttributes)
    }
}
----
======

你可以如下获取 `OAuth2AccessToken`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Controller
public class OAuth2ClientController {

	@Autowired
	private ReactiveOAuth2AuthorizedClientManager authorizedClientManager;

	@GetMapping("/")
	public Mono<String> index(Authentication authentication, ServerWebExchange exchange) {
		OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
				.principal(authentication)
				.attribute(ServerWebExchange.class.getName(), exchange)
				.build();

		return this.authorizedClientManager.authorize(authorizeRequest)
				.map(OAuth2AuthorizedClient::getAccessToken)
				...
				.thenReturn("index");
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Controller
class OAuth2ClientController {
    @Autowired
    private lateinit var authorizedClientManager: ReactiveOAuth2AuthorizedClientManager

    @GetMapping("/")
    fun index(authentication: Authentication, exchange: ServerWebExchange): Mono<String> {
        val authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
                .principal(authentication)
                .attribute(ServerWebExchange::class.java.name, exchange)
                .build()

        return authorizedClientManager.authorize(authorizeRequest)
                .map { it.accessToken }
                ...
                .thenReturn("index")
    }
}
----
======

[NOTE]
`ServerWebExchange` 是一个可选属性。
如果未提供，它将通过键 `ServerWebExchange.class` 从 https://projectreactor.io/docs/core/release/reference/#context[Reactor 上下文] 中获取。


[[oauth2Client-jwt-bearer-grant]]
== JWT Bearer

[NOTE]
请参考 OAuth 2.0 客户端认证和授权授予的 JSON Web Token (JWT) 配置文件以了解更多关于 https://datatracker.ietf.org/doc/html/rfc7523[JWT Bearer] 授权的详细信息。

=== 请求访问令牌

[NOTE]
请参考 https://datatracker.ietf.org/doc/html/rfc7523#section-2.1[访问令牌请求/响应] 协议流程以了解 JWT Bearer 授权。

JWT Bearer 授权的 `ReactiveOAuth2AccessTokenResponseClient` 默认实现是 `WebClientReactiveJwtBearerTokenResponseClient`，它使用 `WebClient` 在授权服务器的令牌端点请求访问令牌。

`WebClientReactiveJwtBearerTokenResponseClient` 非常灵活，因为它允许你自定义令牌请求的预处理和/或令牌响应的后处理。


=== 自定义访问令牌请求

如果你需要自定义令牌请求的预处理，可以为 `WebClientReactiveJwtBearerTokenResponseClient.setParametersConverter()` 提供一个自定义的 `Converter<JwtBearerGrantRequest, MultiValueMap<String, String>>`。
默认实现构建了一个只包含标准 https://tools.ietf.org/html/rfc6749#section-4.4.2[OAuth 2.0 访问令牌请求] 中 `grant_type` 参数的 `MultiValueMap<String, String>`，用于构造请求。其他 JWT Bearer 授权所需的参数直接由 `WebClientReactiveJwtBearerTokenResponseClient` 添加到请求体中。然而，提供一个自定义的 `Converter` 将允许你扩展标准令牌请求并添加自定义参数。

[TIP]
如果你只想添加额外参数，可以改为为 `WebClientReactiveJwtBearerTokenResponseClient.addParametersConverter()` 提供一个自定义的 `Converter<JwtBearerGrantRequest, MultiValueMap<String, String>>`，它会构建一个聚合 `Converter`。

IMPORTANT: 自定义 `Converter` 必须返回目标 OAuth 2.0 提供商能够理解的有效 OAuth 2.0 访问令牌请求参数。

=== 自定义访问令牌响应

另一方面，如果你需要自定义令牌响应的后处理，你需要为 `WebClientReactiveJwtBearerTokenResponseClient.setBodyExtractor()` 提供一个自定义配置的 `BodyExtractor<Mono<OAuth2AccessTokenResponse>, ReactiveHttpInputMessage>`，用于将 OAuth 2.0 访问令牌响应转换为 `OAuth2AccessTokenResponse`。由 `OAuth2BodyExtractors.oauth2AccessTokenResponse()` 提供的默认实现会解析响应并相应地处理错误。

=== 自定义 `WebClient`

或者，如果你的需求更高级，你可以通过为 `WebClientReactiveJwtBearerTokenResponseClient.setWebClient()` 提供一个自定义配置的 `WebClient` 来完全控制请求/响应。

无论你是自定义 `WebClientReactiveJwtBearerTokenResponseClient` 还是提供自己的 `ReactiveOAuth2AccessTokenResponseClient` 实现，都需要按以下示例进行配置：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
// Customize
ReactiveOAuth2AccessTokenResponseClient<JwtBearerGrantRequest> jwtBearerTokenResponseClient = ...

JwtBearerReactiveOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider = new JwtBearerReactiveOAuth2AuthorizedClientProvider();
jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerTokenResponseClient);

ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
		ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
				.provider(jwtBearerAuthorizedClientProvider)
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
// Customize
val jwtBearerTokenResponseClient: ReactiveOAuth2AccessTokenResponseClient<JwtBearerGrantRequest> = ...

val jwtBearerAuthorizedClientProvider = JwtBearerReactiveOAuth2AuthorizedClientProvider()
jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerTokenResponseClient)

val authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
        .provider(jwtBearerAuthorizedClientProvider)
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
----
======

=== 使用访问令牌

给定以下用于 OAuth 2.0 客户端注册的 Spring Boot 属性：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: urn:ietf:params:oauth:grant-type:jwt-bearer
            scope: read
        provider:
          okta:
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token
----

...以及 `OAuth2AuthorizedClientManager` `@Bean`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public ReactiveOAuth2AuthorizedClientManager authorizedClientManager(
		ReactiveClientRegistrationRepository clientRegistrationRepository,
		ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {

	JwtBearerReactiveOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider =
			new JwtBearerReactiveOAuth2AuthorizedClientProvider();

	ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
			ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
					.provider(jwtBearerAuthorizedClientProvider)
					.build();

	DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultReactiveOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ReactiveClientRegistrationRepository,
        authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager {
    val jwtBearerAuthorizedClientProvider = JwtBearerReactiveOAuth2AuthorizedClientProvider()
    val authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
            .provider(jwtBearerAuthorizedClientProvider)
            .build()
    val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}
----
======

你可以如下获取 `OAuth2AccessToken`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@RestController
public class OAuth2ResourceServerController {

	@Autowired
	private ReactiveOAuth2AuthorizedClientManager authorizedClientManager;

	@GetMapping("/resource")
	public Mono<String> resource(JwtAuthenticationToken jwtAuthentication, ServerWebExchange exchange) {
		OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
				.principal(jwtAuthentication)
				.build();

		return this.authorizedClientManager.authorize(authorizeRequest)
				.map(OAuth2AuthorizedClient::getAccessToken)
				...
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
class OAuth2ResourceServerController {

    @Autowired
    private lateinit var authorizedClientManager: ReactiveOAuth2AuthorizedClientManager

    @GetMapping("/resource")
    fun resource(jwtAuthentication: JwtAuthenticationToken, exchange: ServerWebExchange): Mono<String> {
        val authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
                .principal(jwtAuthentication)
                .build()
        return authorizedClientManager.authorize(authorizeRequest)
                .map { it.accessToken }
                ...
    }
}
----
======

[NOTE]
`JwtBearerReactiveOAuth2AuthorizedClientProvider` 默认通过 `OAuth2AuthorizationContext.getPrincipal().getPrincipal()` 解析 `Jwt` 断言，因此在前面的示例中使用了 `JwtAuthenticationToken`。

[TIP]
如果你需要从不同来源解析 `Jwt` 断言，可以为 `JwtBearerReactiveOAuth2AuthorizedClientProvider.setJwtAssertionResolver()` 提供一个自定义的 `Function<OAuth2AuthorizationContext, Mono<Jwt>>`。

[[oauth2Client-token-exchange-grant]]
== 令牌交换

[NOTE]
请参考 OAuth 2.0 令牌交换以了解更多关于 https://datatracker.ietf.org/doc/html/rfc8693[令牌交换] 授权的详细信息。

=== 请求访问令牌

[NOTE]
请参考 https://datatracker.ietf.org/doc/html/rfc8693#section-2[令牌交换请求和响应] 协议流程以了解令牌交换授权。

令牌交换授权的 `ReactiveOAuth2AccessTokenResponseClient` 默认实现是 `WebClientReactiveTokenExchangeTokenResponseClient`，它使用 `WebClient` 在授权服务器的令牌端点请求访问令牌。

`WebClientReactiveTokenExchangeTokenResponseClient` 非常灵活，因为它允许你自定义令牌请求的预处理和/或令牌响应的后处理。


=== 自定义访问令牌请求

如果你需要自定义令牌请求的预处理，可以为 `WebClientReactiveTokenExchangeTokenResponseClient.setParametersConverter()` 提供一个自定义的 `Converter<TokenExchangeGrantRequest, MultiValueMap<String, String>>`。
默认实现构建了一个只包含标准 https://tools.ietf.org/html/rfc6749#section-4.4.2[OAuth 2.0 访问令牌请求] 中 `grant_type` 参数的 `MultiValueMap<String, String>`，用于构造请求。其他令牌交换授权所需的参数直接由 `WebClientReactiveTokenExchangeTokenResponseClient` 添加到请求体中。然而，提供一个自定义的 `Converter` 将允许你扩展标准令牌请求并添加自定义参数。

[TIP]
如果你只想添加额外参数，可以改为为 `WebClientReactiveTokenExchangeTokenResponseClient.addParametersConverter()` 提供一个自定义的 `Converter<TokenExchangeGrantRequest, MultiValueMap<String, String>>`，它会构建一个聚合 `Converter`。

IMPORTANT: 自定义 `Converter` 必须返回目标 OAuth 2.0 提供商能够理解的有效 OAuth 2.0 访问令牌请求参数。

=== 自定义访问令牌响应

另一方面，如果你需要自定义令牌响应的后处理，你需要为 `WebClientReactiveTokenExchangeTokenResponseClient.setBodyExtractor()` 提供一个自定义配置的 `BodyExtractor<Mono<OAuth2AccessTokenResponse>, ReactiveHttpInputMessage>`，用于将 OAuth 2.0 访问令牌响应转换为 `OAuth2AccessTokenResponse`。由 `OAuth2BodyExtractors.oauth2AccessTokenResponse()` 提供的默认实现会解析响应并相应地处理错误。

=== 自定义 `WebClient`

或者，如果你的需求更高级，你可以通过为 `WebClientReactiveTokenExchangeTokenResponseClient.setWebClient()` 提供一个自定义配置的 `WebClient` 来完全控制请求/响应。

无论你是自定义 `WebClientReactiveTokenExchangeTokenResponseClient` 还是提供自己的 `ReactiveOAuth2AccessTokenResponseClient` 实现，都需要按以下示例进行配置：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
// Customize
ReactiveOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> tokenExchangeTokenResponseClient = ...

TokenExchangeReactiveOAuth2AuthorizedClientProvider tokenExchangeAuthorizedClientProvider = new TokenExchangeReactiveOAuth2AuthorizedClientProvider();
tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeTokenResponseClient);

ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
		ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
				.provider(tokenExchangeAuthorizedClientProvider)
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
// Customize
val tokenExchangeTokenResponseClient: ReactiveOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> = ...

val tokenExchangeAuthorizedClientProvider = TokenExchangeReactiveOAuth2AuthorizedClientProvider()
tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeTokenResponseClient)

val authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
        .provider(tokenExchangeAuthorizedClientProvider)
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
----
======

=== 使用访问令牌

给定以下用于 OAuth 2.0 客户端注册的 Spring Boot 属性：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: urn:ietf:params:oauth:grant-type:token-exchange
            scope: read
        provider:
          okta:
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token
----

...以及 `OAuth2AuthorizedClientManager` `@Bean`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public ReactiveOAuth2AuthorizedClientManager authorizedClientManager(
		ReactiveClientRegistrationRepository clientRegistrationRepository,
		ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {

	TokenExchangeReactiveOAuth2AuthorizedClientProvider tokenExchangeAuthorizedClientProvider =
			new TokenExchangeReactiveOAuth2AuthorizedClientProvider();

	ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
			ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
					.provider(tokenExchangeAuthorizedClientProvider)
					.build();

	DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultReactiveOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ReactiveClientRegistrationRepository,
        authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager {
    val tokenExchangeAuthorizedClientProvider = TokenExchangeReactiveOAuth2AuthorizedClientProvider()
    val authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
            .provider(tokenExchangeAuthorizedClientProvider)
            .build()
    val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}
----
======

你可以如下获取 `OAuth2AccessToken`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@RestController
public class OAuth2ResourceServerController {

	@Autowired
	private ReactiveOAuth2AuthorizedClientManager authorizedClientManager;

	@GetMapping("/resource")
	public Mono<String> resource(JwtAuthenticationToken jwtAuthentication) {
		OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
				.principal(jwtAuthentication)
				.build();

		return this.authorizedClientManager.authorize(authorizeRequest)
				.map(OAuth2AuthorizedClient::getAccessToken)
				...
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
class OAuth2ResourceServerController {

    @Autowired
    private lateinit var authorizedClientManager: ReactiveOAuth2AuthorizedClientManager

    @GetMapping("/resource")
    fun resource(jwtAuthentication: JwtAuthenticationToken): Mono<String> {
        val authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
                .principal(jwtAuthentication)
                .build()
        return authorizedClientManager.authorize(authorizeRequest)
                .map { it.accessToken }
                ...
    }
}
----
======

[NOTE]
`TokenExchangeReactiveOAuth2AuthorizedClientProvider` 默认通过 `OAuth2AuthorizationContext.getPrincipal().getPrincipal()` 解析主体令牌（作为 `OAuth2Token`），因此在前面的示例中使用了 `JwtAuthenticationToken`。
默认情况下不会解析动作令牌。

[TIP]
如果你需要从不同来源解析主体令牌，可以为 `TokenExchangeReactiveOAuth2AuthorizedClientProvider.setSubjectTokenResolver()` 提供一个自定义的 `Function<OAuth2AuthorizationContext, Mono<OAuth2Token>>`。

[TIP]
如果你需要解析动作令牌，可以为 `TokenExchangeReactiveOAuth2AuthorizedClientProvider.setActorTokenResolver()` 提供一个自定义的 `Function<OAuth2AuthorizationContext, Mono<OAuth2Token>>`。