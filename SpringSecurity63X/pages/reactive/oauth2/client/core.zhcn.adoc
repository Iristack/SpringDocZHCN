[[oauth2Client-core-interface-class]]
= 核心接口 / 类


[[oauth2Client-client-registration]]
== ClientRegistration

`ClientRegistration` 是表示在 OAuth 2.0 或 OpenID Connect 1.0 提供方注册的客户端。

一个客户端注册包含诸如客户端 ID、客户端密钥、授权授予类型、重定向 URI、作用域（scopes）、授权 URI、令牌 URI等信息及其他详细信息。

`ClientRegistration` 及其属性定义如下：

[source,java]
----
public final class ClientRegistration {
	private String registrationId;	<1>
	private String clientId;	<2>
	private String clientSecret;	<3>
	private ClientAuthenticationMethod clientAuthenticationMethod;	<4>
	private AuthorizationGrantType authorizationGrantType;	<5>
	private String redirectUri;	<6>
	private Set<String> scopes;	<7>
	private ProviderDetails providerDetails;
	private String clientName;	<8>

	public class ProviderDetails {
		private String authorizationUri;	<9>
		private String tokenUri;	<10>
		private UserInfoEndpoint userInfoEndpoint;
		private String jwkSetUri;	<11>
		private String issuerUri;	<12>
		private Map<String, Object> configurationMetadata;  <13>

		public class UserInfoEndpoint {
			private String uri;	<14>
			private AuthenticationMethod authenticationMethod;  <15>
			private String userNameAttributeName;	<16>

		}
	}
}
----
<1> `registrationId`: 唯一标识 `ClientRegistration` 的 ID。
<2> `clientId`: 客户端标识符。
<3> `clientSecret`: 客户端密钥。
<4> `clientAuthenticationMethod`: 客户端与提供方进行身份验证所使用的方法。支持的值包括 *client_secret_basic*、*client_secret_post*、*private_key_jwt*、*client_secret_jwt* 和 *none* https://tools.ietf.org/html/rfc6749#section-2.1[(公共客户端)]。
<5> `authorizationGrantType`: OAuth 2.0 授权框架定义了四种 https://tools.ietf.org/html/rfc6749#section-1.3[授权授予] 类型。支持的值有 `authorization_code`、`client_credentials`、`password`，以及扩展授予类型 `urn:ietf:params:oauth:grant-type:jwt-bearer`。
<6> `redirectUri`: 客户端注册的重定向 URI，当最终用户完成身份认证并授权访问客户端后，_授权服务器_会将最终用户的用户代理重定向到该地址。
<7> `scopes`: 在授权请求流程中由客户端请求的作用域，例如 openid、email 或 profile。
<8> `clientName`: 客户端的描述性名称。该名称可用于某些场景，比如在自动生成的登录页面上显示客户端名称。
<9> `authorizationUri`: 授权服务器的授权端点 URI。
<10> `tokenUri`: 授权服务器的令牌端点 URI。
<11> `jwkSetUri`: 用于从授权服务器获取 https://tools.ietf.org/html/rfc7517[JSON Web Key (JWK)] 集合的 URI，其中包含用于验证 ID Token 和可选的 UserInfo 响应的 https://tools.ietf.org/html/rfc7515[JSON Web Signature (JWS)] 的加密密钥。
<12> `issuerUri`: 返回 OpenID Connect 1.0 提供方或 OAuth 2.0 授权服务器的发行者标识符 URI。
<13> `configurationMetadata`: https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[OpenID 提供方配置信息]。只有当 Spring Boot 属性 `spring.security.oauth2.client.provider.[providerId].issuerUri` 被配置时，此信息才可用。
<14> `(userInfoEndpoint)uri`: 用户信息端点 URI，用于访问已认证最终用户的声明/属性。
<15> `(userInfoEndpoint)authenticationMethod`: 向用户信息端点发送访问令牌时使用的身份验证方法。支持的值为 *header*、*form* 和 *query*。
<16> `userNameAttributeName`: 用户信息响应中返回的引用最终用户名称或标识符的属性名。

可以通过发现 OpenID Connect 提供方的 https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[配置端点] 或授权服务器的 https://tools.ietf.org/html/rfc8414#section-3[元数据端点] 来初始配置 `ClientRegistration`。

`ClientRegistrations` 提供了便捷方法以这种方式配置 `ClientRegistration`，如下例所示：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
ClientRegistration clientRegistration =
	ClientRegistrations.fromIssuerLocation("https://idp.example.com/issuer").build();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val clientRegistration = ClientRegistrations.fromIssuerLocation("https://idp.example.com/issuer").build()
----
======

上述代码将依次查询 `https://idp.example.com/issuer/.well-known/openid-configuration`，然后是 `https://idp.example.com/.well-known/openid-configuration/issuer`，最后是 `https://idp.example.com/.well-known/oauth-authorization-server/issuer`，并在第一个返回 200 响应处停止。

作为替代方案，您可以使用 `ClientRegistrations.fromOidcIssuerLocation()` 仅查询 OpenID Connect 提供方的配置端点。

[[oauth2Client-client-registration-repo]]
== ReactiveClientRegistrationRepository

`ReactiveClientRegistrationRepository` 用作 OAuth 2.0 / OpenID Connect 1.0 `ClientRegistration`(s) 的存储库。

[NOTE]
客户端注册信息最终由关联的授权服务器存储和管理。该存储库提供了检索主客户端注册信息子集的能力，这些信息存储在授权服务器中。

Spring Boot 自动配置会将 `spring.security.oauth2.client.registration._[registrationId]_` 下的每个属性绑定到 `ClientRegistration` 实例，并将每个 `ClientRegistration` 实例组合在一个 `ReactiveClientRegistrationRepository` 中。

[NOTE]
`ReactiveClientRegistrationRepository` 的默认实现是 `InMemoryReactiveClientRegistrationRepository`。

自动配置还会将 `ReactiveClientRegistrationRepository` 注册为 `ApplicationContext` 中的 `@Bean`，以便应用程序在需要时可以进行依赖注入。

以下示例展示了用法：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Controller
public class OAuth2ClientController {

	@Autowired
	private ReactiveClientRegistrationRepository clientRegistrationRepository;

	@GetMapping("/")
	public Mono<String> index() {
		return this.clientRegistrationRepository.findByRegistrationId("okta")
				...
				.thenReturn("index");
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Controller
class OAuth2ClientController {

    @Autowired
    private lateinit var clientRegistrationRepository: ReactiveClientRegistrationRepository

    @GetMapping("/")
    fun index(): Mono<String> {
        return this.clientRegistrationRepository.findByRegistrationId("okta")
            ...
            .thenReturn("index")
    }
}
----
======

[[oauth2Client-authorized-client]]
== OAuth2AuthorizedClient

`OAuth2AuthorizedClient` 表示一个已授权的客户端。当最终用户（资源所有者）已授权客户端访问其受保护资源时，该客户端被视为已授权。

`OAuth2AuthorizedClient` 的作用是将 `OAuth2AccessToken`（和可选的 `OAuth2RefreshToken`）与 `ClientRegistration`（客户端）和资源所有者（即授予授权的 `Principal` 最终用户）相关联。

[[oauth2Client-authorized-repo-service]]
== ServerOAuth2AuthorizedClientRepository / ReactiveOAuth2AuthorizedClientService

`ServerOAuth2AuthorizedClientRepository` 负责在 Web 请求之间持久化 `OAuth2AuthorizedClient`(s)。而 `ReactiveOAuth2AuthorizedClientService` 的主要职责是在应用级别管理 `OAuth2AuthorizedClient`(s)。

从开发人员的角度来看，`ServerOAuth2AuthorizedClientRepository` 或 `ReactiveOAuth2AuthorizedClientService` 提供了查找与客户端关联的 `OAuth2AccessToken` 的能力，以便发起对受保护资源的请求。

以下示例展示了用法：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Controller
public class OAuth2ClientController {

	@Autowired
	private ReactiveOAuth2AuthorizedClientService authorizedClientService;

	@GetMapping("/")
	public Mono<String> index(Authentication authentication) {
		return this.authorizedClientService.loadAuthorizedClient("okta", authentication.getName())
				.map(OAuth2AuthorizedClient::getAccessToken)
				...
				.thenReturn("index");
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Controller
class OAuth2ClientController {

    @Autowired
    private lateinit var authorizedClientService: ReactiveOAuth2AuthorizedClientService

    @GetMapping("/")
    fun index(authentication: Authentication): Mono<String> {
        return this.authorizedClientService.loadAuthorizedClient<OAuth2AuthorizedClient>("okta", authentication.name)
            .map { it.accessToken }
            ...
            .thenReturn("index")
    }
}
----
======

[NOTE]
Spring Boot 自动配置会在 `ApplicationContext` 中注册 `ServerOAuth2AuthorizedClientRepository` 和/或 `ReactiveOAuth2AuthorizedClientService` `@Bean`。然而，应用程序可以选择覆盖并注册自定义的 `ServerOAuth2AuthorizedClientRepository` 或 `ReactiveOAuth2AuthorizedClientService` `@Bean`。

`ReactiveOAuth2AuthorizedClientService` 的默认实现是 `InMemoryReactiveOAuth2AuthorizedClientService`，它将 `OAuth2AuthorizedClient`(s) 存储在内存中。

或者，也可以配置 R2DBC 实现 `R2dbcReactiveOAuth2AuthorizedClientService`，将 `OAuth2AuthorizedClient`(s) 持久化到数据库中。

[NOTE]
`R2dbcReactiveOAuth2AuthorizedClientService` 依赖于 xref:servlet/appendix/database-schema.adoc#dbschema-oauth2-client[OAuth 2.0 客户端模式] 中描述的表结构定义。


[[oauth2Client-authorized-manager-provider]]
== ReactiveOAuth2AuthorizedClientManager / ReactiveOAuth2AuthorizedClientProvider

`ReactiveOAuth2AuthorizedClientManager` 负责 `OAuth2AuthorizedClient`(s) 的整体管理。

其主要职责包括：

* 使用 `ReactiveOAuth2AuthorizedClientProvider` 对 OAuth 2.0 客户端进行授权（或重新授权）。
* 委托持久化 `OAuth2AuthorizedClient`，通常通过 `ReactiveOAuth2AuthorizedClientService` 或 `ServerOAuth2AuthorizedClientRepository`。
* 当 OAuth 2.0 客户端成功授权（或重新授权）时，委托给 `ReactiveOAuth2AuthorizationSuccessHandler`。
* 当 OAuth 2.0 客户端授权（或重新授权）失败时，委托给 `ReactiveOAuth2AuthorizationFailureHandler`。

`ReactiveOAuth2AuthorizedClientProvider` 实现了对 OAuth 2.0 客户端进行授权（或重新授权）的策略。具体实现通常对应一种授权授予类型，例如 `authorization_code`、`client_credentials` 等。

`ReactiveOAuth2AuthorizedClientManager` 的默认实现是 `DefaultReactiveOAuth2AuthorizedClientManager`，它关联了一个 `ReactiveOAuth2AuthorizedClientProvider`，该提供程序可通过基于委托的组合方式支持多种授权授予类型。可以使用 `ReactiveOAuth2AuthorizedClientProviderBuilder` 来配置和构建这种基于委托的组合。

以下代码展示如何配置和构建一个支持 `authorization_code`、`refresh_token`、`client_credentials` 和 `password` 授权授予类型的 `ReactiveOAuth2AuthorizedClientProvider` 组合：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public ReactiveOAuth2AuthorizedClientManager authorizedClientManager(
		ReactiveClientRegistrationRepository clientRegistrationRepository,
		ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {

	ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
			ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
					.authorizationCode()
					.refreshToken()
					.clientCredentials()
					.password()
					.build();

	DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultReactiveOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ReactiveClientRegistrationRepository,
        authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager {
    val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
            .authorizationCode()
            .refreshToken()
            .clientCredentials()
            .password()
            .build()
    val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}
----
======

当授权尝试成功时，`DefaultReactiveOAuth2AuthorizedClientManager` 将委托给 `ReactiveOAuth2AuthorizationSuccessHandler`，默认情况下会通过 `ServerOAuth2AuthorizedClientRepository` 保存 `OAuth2AuthorizedClient`。如果重新授权失败（例如刷新令牌不再有效），则会通过 `RemoveAuthorizedClientReactiveOAuth2AuthorizationFailureHandler` 从 `ServerOAuth2AuthorizedClientRepository` 中移除之前保存的 `OAuth2AuthorizedClient`。可通过 `setAuthorizationSuccessHandler(ReactiveOAuth2AuthorizationSuccessHandler)` 和 `setAuthorizationFailureHandler(ReactiveOAuth2AuthorizationFailureHandler)` 自定义默认行为。

`DefaultReactiveOAuth2AuthorizedClientManager` 还关联了一个类型为 `Function<OAuth2AuthorizeRequest, Mono<Map<String, Object>>>` 的 `contextAttributesMapper`，负责将 `OAuth2AuthorizeRequest` 中的属性映射为要与 `OAuth2AuthorizationContext` 关联的属性 `Map`。这在您需要向 `ReactiveOAuth2AuthorizedClientProvider` 提供所需（支持）属性时非常有用，例如 `PasswordReactiveOAuth2AuthorizedClientProvider` 需要在 `OAuth2AuthorizationContext.getAttributes()` 中提供资源所有者的 `username` 和 `password`。

以下代码展示了 `contextAttributesMapper` 的示例：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public ReactiveOAuth2AuthorizedClientManager authorizedClientManager(
		ReactiveClientRegistrationRepository clientRegistrationRepository,
		ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {

	ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
			ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
					.password()
					.refreshToken()
					.build();

	DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultReactiveOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	// 假设 `username` 和 `password` 作为 `ServerHttpRequest` 参数提供，
	// 将 `ServerHttpRequest` 参数映射到 `OAuth2AuthorizationContext.getAttributes()`
	authorizedClientManager.setContextAttributesMapper(contextAttributesMapper());

	return authorizedClientManager;
}

private Function<OAuth2AuthorizeRequest, Mono<Map<String, Object>>> contextAttributesMapper() {
	return authorizeRequest -> {
		Map<String, Object> contextAttributes = Collections.emptyMap();
		ServerWebExchange exchange = authorizeRequest.getAttribute(ServerWebExchange.class.getName());
		ServerHttpRequest request = exchange.getRequest();
		String username = request.getQueryParams().getFirst(OAuth2ParameterNames.USERNAME);
		String password = request.getQueryParams().getFirst(OAuth2ParameterNames.PASSWORD);
		if (StringUtils.hasText(username) && StringUtils.hasText(password)) {
			contextAttributes = new HashMap<>();

			// `PasswordReactiveOAuth2AuthorizedClientProvider` 需要这两个属性
			contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username);
			contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password);
		}
		return Mono.just(contextAttributes);
	};
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ReactiveClientRegistrationRepository,
        authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager {
    val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
            .password()
            .refreshToken()
            .build()
    val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)

    // 假设 `username` 和 `password` 作为 `ServerHttpRequest` 参数提供，
    // 将 `ServerHttpRequest` 参数映射到 `OAuth2AuthorizationContext.getAttributes()`
    authorizedClientManager.setContextAttributesMapper(contextAttributesMapper())
    return authorizedClientManager
}

private fun contextAttributesMapper(): Function<OAuth2AuthorizeRequest, Mono<MutableMap<String, Any>>> {
    return Function { authorizeRequest ->
        var contextAttributes: MutableMap<String, Any> = mutableMapOf()
        val exchange: ServerWebExchange = authorizeRequest.getAttribute(ServerWebExchange::class.java.name)!!
        val request: ServerHttpRequest = exchange.request
        val username: String? = request.queryParams.getFirst(OAuth2ParameterNames.USERNAME)
        val password: String? = request.queryParams.getFirst(OAuth2ParameterNames.PASSWORD)
        if (StringUtils.hasText(username) && StringUtils.hasText(password)) {
            contextAttributes = hashMapOf()

            // `PasswordReactiveOAuth2AuthorizedClientProvider` 需要这两个属性
            contextAttributes[OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME] = username!!
            contextAttributes[OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME] = password!!
        }
        Mono.just(contextAttributes)
    }
}
----
======

`DefaultReactiveOAuth2AuthorizedClientManager` 设计用于 *_在_* `ServerWebExchange` 上下文中使用。当 *_在_* `ServerWebExchange` 上下文之外操作时，请改用 `AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager`。

服务应用是使用 `AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager` 的常见用例。服务应用通常在后台运行，无需用户交互，且通常以系统级账户而非用户账户运行。使用 `client_credentials` 授予类型的 OAuth 2.0 客户端可视为一种服务应用。

以下代码展示了如何配置一个支持 `client_credentials` 授予类型的 `AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager` 的示例：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public ReactiveOAuth2AuthorizedClientManager authorizedClientManager(
		ReactiveClientRegistrationRepository clientRegistrationRepository,
		ReactiveOAuth2AuthorizedClientService authorizedClientService) {

	ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
			ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
					.clientCredentials()
					.build();

	AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager authorizedClientManager =
			new AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientService);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ReactiveClientRegistrationRepository,
        authorizedClientService: ReactiveOAuth2AuthorizedClientService): ReactiveOAuth2AuthorizedClientManager {
    val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
            .clientCredentials()
            .build()
    val authorizedClientManager = AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientService)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}
----
======