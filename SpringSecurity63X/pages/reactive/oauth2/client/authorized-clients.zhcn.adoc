[[oauth2Client-additional-features]]
= 已授权的客户端

[[oauth2Client-registered-authorized-client]]
== 解析已授权的客户端

`@RegisteredOAuth2AuthorizedClient` 注解提供了将方法参数解析为 `OAuth2AuthorizedClient` 类型参数值的功能。这相比使用 `ReactiveOAuth2AuthorizedClientManager` 或 `ReactiveOAuth2AuthorizedClientService` 来访问 `OAuth2AuthorizedClient` 是一种更便捷的替代方式。

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Controller
public class OAuth2ClientController {

	@GetMapping("/")
	public Mono<String> index(@RegisteredOAuth2AuthorizedClient("okta") OAuth2AuthorizedClient authorizedClient) {
		return Mono.just(authorizedClient.getAccessToken())
				...
				.thenReturn("index");
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Controller
class OAuth2ClientController {
    @GetMapping("/")
    fun index(@RegisteredOAuth2AuthorizedClient("okta") authorizedClient: OAuth2AuthorizedClient): Mono<String> {
        return Mono.just(authorizedClient.accessToken)
                ...
                .thenReturn("index")
    }
}
----
======

`@RegisteredOAuth2AuthorizedClient` 注解由 `OAuth2AuthorizedClientArgumentResolver` 处理，该类直接使用 <<oauth2Client-authorized-manager-provider, ReactiveOAuth2AuthorizedClientManager>>，因此继承了其所有功能。

[[oauth2Client-webclient-webflux]]
== 针对响应式环境的 WebClient 集成

OAuth 2.0 客户端支持通过 `ExchangeFilterFunction` 与 `WebClient` 进行集成。

`ServerOAuth2AuthorizedClientExchangeFilterFunction` 提供了一种简单机制，用于通过 `OAuth2AuthorizedClient` 请求受保护资源，并将关联的 `OAuth2AccessToken` 作为 Bearer Token 包含在请求中。它直接使用 <<oauth2Client-authorized-manager-provider, ReactiveOAuth2AuthorizedClientManager>>，因此继承了以下功能：

* 如果客户端尚未授权，则会请求一个 `OAuth2AccessToken`：
** `authorization_code` - 触发授权请求重定向以启动流程
** `client_credentials` - 直接从令牌端点获取访问令牌
** `password` - 直接从令牌端点获取访问令牌
* 如果 `OAuth2AccessToken` 已过期，并且存在可用的 `ReactiveOAuth2AuthorizedClientProvider` 执行授权，则会刷新（或重新获取）令牌

以下代码展示了如何配置支持 OAuth 2.0 客户端功能的 `WebClient` 示例：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
WebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) {
	ServerOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =
			new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
	return WebClient.builder()
			.filter(oauth2Client)
			.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webClient(authorizedClientManager: ReactiveOAuth2AuthorizedClientManager): WebClient {
    val oauth2Client = ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)
    return WebClient.builder()
            .filter(oauth2Client)
            .build()
}
----
======

=== 提供已授权的客户端

`ServerOAuth2AuthorizedClientExchangeFilterFunction` 通过从 `ClientRequest.attributes()`（请求属性）中解析 `OAuth2AuthorizedClient` 来确定用于请求的客户端。

以下代码展示如何将 `OAuth2AuthorizedClient` 设置为请求属性：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@GetMapping("/")
public Mono<String> index(@RegisteredOAuth2AuthorizedClient("okta") OAuth2AuthorizedClient authorizedClient) {
	String resourceUri = ...

	return webClient
			.get()
			.uri(resourceUri)
			.attributes(oauth2AuthorizedClient(authorizedClient))   <1>
			.retrieve()
			.bodyToMono(String.class)
			...
			.thenReturn("index");
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@GetMapping("/")
fun index(@RegisteredOAuth2AuthorizedClient("okta") authorizedClient: OAuth2AuthorizedClient): Mono<String> {
    val resourceUri: String = ...

    return webClient
            .get()
            .uri(resourceUri)
            .attributes(oauth2AuthorizedClient(authorizedClient)) <1>
            .retrieve()
            .bodyToMono<String>()
            ...
            .thenReturn("index")
}
----
======
<1> `oauth2AuthorizedClient()` 是 `ServerOAuth2AuthorizedClientExchangeFilterFunction` 中的一个 `static` 方法。

以下代码展示如何将 `ClientRegistration.getRegistrationId()` 设置为请求属性：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@GetMapping("/")
public Mono<String> index() {
	String resourceUri = ...

	return webClient
			.get()
			.uri(resourceUri)
			.attributes(clientRegistrationId("okta"))   <1>
			.retrieve()
			.bodyToMono(String.class)
			...
			.thenReturn("index");
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@GetMapping("/")
fun index(): Mono<String> {
    val resourceUri: String = ...

    return webClient
            .get()
            .uri(resourceUri)
            .attributes(clientRegistrationId("okta"))  <1>
            .retrieve()
            .bodyToMono<String>()
            ...
            .thenReturn("index")
}
----
======
<1> `clientRegistrationId()` 是 `ServerOAuth2AuthorizedClientExchangeFilterFunction` 中的一个 `static` 方法。

=== 默认已授权的客户端

如果既未提供 `OAuth2AuthorizedClient` 也未提供 `ClientRegistration.getRegistrationId()` 作为请求属性，`ServerOAuth2AuthorizedClientExchangeFilterFunction` 可根据其配置来决定使用的 _默认_ 客户端。

若配置了 `setDefaultOAuth2AuthorizedClient(true)` 且用户已通过 `ServerHttpSecurity.oauth2Login()` 认证，则使用当前 `OAuth2AuthenticationToken` 关联的 `OAuth2AccessToken`。

以下代码展示具体配置：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
WebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) {
	ServerOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =
			new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
	oauth2Client.setDefaultOAuth2AuthorizedClient(true);
	return WebClient.builder()
			.filter(oauth2Client)
			.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webClient(authorizedClientManager: ReactiveOAuth2AuthorizedClientManager): WebClient {
    val oauth2Client = ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)
    oauth2Client.setDefaultOAuth2AuthorizedClient(true)
    return WebClient.builder()
            .filter(oauth2Client)
            .build()
}
----
======

[WARNING]
建议谨慎使用此功能，因为所有 HTTP 请求都将携带访问令牌。

另一种情况是，如果配置了 `setDefaultClientRegistrationId("okta")` 并指定了有效的 `ClientRegistration`，则会使用与该 `ClientRegistration` 对应的 `OAuth2AuthorizedClient` 的 `OAuth2AccessToken`。

以下代码展示具体配置：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
WebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) {
	ServerOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =
			new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
	oauth2Client.setDefaultClientRegistrationId("okta");
	return WebClient.builder()
			.filter(oauth2Client)
			.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webClient(authorizedClientManager: ReactiveOAuth2AuthorizedClientManager): WebClient {
    val oauth2Client = ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)
    oauth2Client.setDefaultClientRegistrationId("okta")
    return WebClient.builder()
            .filter(oauth2Client)
            .build()
}
----
======

[WARNING]
建议谨慎使用此功能，因为所有 HTTP 请求都将携带访问令牌。