= OAuth 2.0 资源服务器 JWT

[[webflux-oauth2resourceserver-jwt-minimaldependencies]]
== JWT 的最小依赖

大多数资源服务器支持功能都包含在 `spring-security-oauth2-resource-server` 模块中。然而，解码和验证 JWT 的支持位于 `spring-security-oauth2-jose` 中，这意味着要构建一个支持 JWT 编码的 Bearer Token 的工作资源服务器，这两个模块都是必需的。

[[webflux-oauth2resourceserver-jwt-minimalconfiguration]]
== JWT 的最小配置

当使用 https://spring.io/projects/spring-boot[Spring Boot] 时，将应用程序配置为资源服务器包含两个基本步骤：首先，引入所需的依赖项；其次，指明授权服务器的位置。

=== 指定授权服务器

在 Spring Boot 应用程序中，你需要指定要使用的授权服务器：

[source,yml]
----
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com/issuer
----

其中 `https://idp.example.com/issuer` 是授权服务器颁发的 JWT Token 中 `iss` 声明所包含的值。资源服务器使用此属性进行进一步自配置，发现授权服务器的公钥，并随后验证传入的 JWT。

[NOTE]
====
要使用 `issuer-uri` 属性，还必须满足以下条件之一：`https://idp.example.com/issuer/.well-known/openid-configuration`、`https://idp.example.com/.well-known/openid-configuration/issuer` 或 `https://idp.example.com/.well-known/oauth-authorization-server/issuer` 是授权服务器支持的端点。
这个端点被称为 https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[提供者配置] 端点或 https://tools.ietf.org/html/rfc8414#section-3[授权服务器元数据] 端点。
====

=== 启动期望

当使用此属性和这些依赖项时，资源服务器会自动配置自身以验证 JWT 编码的 Bearer Token。

它通过一个确定性的启动过程实现这一点：

. 访问 Provider Configuration 或 Authorization Server Metadata 端点，处理响应中的 `jwks_url` 属性。
. 配置验证策略，从启动期间获取的 `jwks_url` 查询有效的公钥。
. 配置验证策略，针对 `https://idp.example.com` 验证每个 JWT 的 `iss` 声明。

该过程的一个结果是，在资源服务器成功启动之前，授权服务器必须能够接收请求。

[NOTE]
====
如果在资源服务器查询时（给定适当的超时时间）授权服务器处于宕机状态，则启动失败。
====

=== 运行时期望

一旦应用程序启动，资源服务器会尝试处理任何包含 `Authorization: Bearer` 头的请求：

[source,html]
----
GET / HTTP/1.1
Authorization: Bearer some-token-value # 资源服务器将处理此请求
----

只要指示了这种方案，资源服务器就会根据 Bearer Token 规范尝试处理请求。

对于格式正确的 JWT，资源服务器会执行以下操作：

. 使用启动期间从 `jwks_url` 端点获得并与 JWT 头匹配的公钥验证其签名。
. 验证 JWT 的 `exp` 和 `nbf` 时间戳以及 JWT 的 `iss` 声明。
. 将每个范围映射到带有前缀 `SCOPE_` 的权限。

[NOTE]
====
随着授权服务器提供新的密钥，Spring Security 会自动轮换用于验证 JWT Token 的密钥。
====

默认情况下，生成的 `Authentication#getPrincipal` 是一个 Spring Security `Jwt` 对象，而 `Authentication#getName` 映射到 JWT 的 `sub` 属性（如果存在的话）。

接下来可以考虑跳转至：

* <<webflux-oauth2resourceserver-jwt-jwkseturi,如何在不绑定资源服务器启动与授权服务器可用性的情况下进行配置>>
* <<webflux-oauth2resourceserver-jwt-sansboot,如何在没有 Spring Boot 的情况下进行配置>>

[[webflux-oauth2resourceserver-jwt-jwkseturi]]
=== 直接指定授权服务器 JWK Set Uri

如果授权服务器不支持任何配置端点，或者资源服务器必须能够独立于授权服务器启动，你可以同时提供 `jwk-set-uri`：

[source,yaml]
----
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com
          jwk-set-uri: https://idp.example.com/.well-known/jwks.json
----

[NOTE]
====
JWK Set uri 并未标准化，但通常可以在授权服务器的文档中找到。
====

因此，资源服务器在启动时不向授权服务器发送 ping 请求。我们仍然指定 `issuer-uri`，以便资源服务器仍能验证传入 JWT 的 `iss` 声明。

[NOTE]
====
你也可以直接在 <<webflux-oauth2resourceserver-jwt-jwkseturi-dsl,DSL>> 上提供此属性。
====

[[webflux-oauth2resourceserver-jwt-sansboot]]
=== 覆盖或替换 Boot 自动配置

Spring Boot 代表资源服务器生成两个 `@Bean` 对象。

第一个 Bean 是一个 `SecurityWebFilterChain`，它将应用程序配置为资源服务器。当包含 `spring-security-oauth2-jose` 时，此 `SecurityWebFilterChain` 如下所示：

资源服务器 SecurityWebFilterChain
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		.authorizeExchange(exchanges -> exchanges
			.anyExchange().authenticated()
		)
		.oauth2ResourceServer(OAuth2ResourceServerSpec::jwt)
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt { }
        }
    }
}
----
======

如果应用程序未暴露 `SecurityWebFilterChain` Bean，则 Spring Boot 将暴露默认的 Bean（如上所示）。

要替换它，请在应用程序内暴露该 `@Bean`：

替换 SecurityWebFilterChain
[tabs]
======
Java::
+
[source,java,role="primary"]
----
import static org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope;

@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		.authorizeExchange(exchanges -> exchanges
			.pathMatchers("/message/**").access(hasScope("message:read"))
			.anyExchange().authenticated()
		)
		.oauth2ResourceServer(oauth2 -> oauth2
			.jwt(withDefaults())
		);
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope

@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize("/message/**", hasScope("message:read"))
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt { }
        }
    }
}
----
======

上述配置要求所有以 `/messages/` 开头的 URL 必须具有 `message:read` 范围。

`oauth2ResourceServer` DSL 上的方法还可以覆盖或替换自动配置。

例如，Spring Boot 创建的第二个 `@Bean` 是一个 `ReactiveJwtDecoder`，它将 `String` Token 解码为经过验证的 `Jwt` 实例：

ReactiveJwtDecoder
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public ReactiveJwtDecoder jwtDecoder() {
    return ReactiveJwtDecoders.fromIssuerLocation(issuerUri);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return ReactiveJwtDecoders.fromIssuerLocation(issuerUri)
}
----
======

[NOTE]
====
调用 `{security-api-url}org/springframework/security/oauth2/jwt/ReactiveJwtDecoders.html#fromIssuerLocation-java.lang.String-[ReactiveJwtDecoders#fromIssuerLocation]` 会调用 Provider Configuration 或 Authorization Server Metadata 端点来推导出 JWK Set URI。
如果应用程序未暴露 `ReactiveJwtDecoder` Bean，则 Spring Boot 会暴露上述默认 Bean。
====

可以通过使用 `jwkSetUri()` 来覆盖其配置，或使用 `decoder()` 来完全替换。

[[webflux-oauth2resourceserver-jwt-jwkseturi-dsl]]
==== 使用 `jwkSetUri()`

你可以将授权服务器的 JWK Set URI <<webflux-oauth2resourceserver-jwt-jwkseturi,作为配置属性>> 进行配置，或在 DSL 中提供：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		.authorizeExchange(exchanges -> exchanges
			.anyExchange().authenticated()
		)
		.oauth2ResourceServer(oauth2 -> oauth2
			.jwt(jwt -> jwt
				.jwkSetUri("https://idp.example.com/.well-known/jwks.json")
			)
		);
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt {
                jwkSetUri = "https://idp.example.com/.well-known/jwks.json"
            }
        }
    }
}
----
======

使用 `jwkSetUri()` 优先于任何配置属性。

[[webflux-oauth2resourceserver-jwt-decoder-dsl]]
==== 使用 `decoder()`

`decoder()` 比 `jwkSetUri()` 更强大，因为它完全替换了 Spring Boot 对 `JwtDecoder` 的任何自动配置：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		.authorizeExchange(exchanges -> exchanges
			.anyExchange().authenticated()
		)
		.oauth2ResourceServer(oauth2 -> oauth2
			.jwt(jwt -> jwt
				.decoder(myCustomDecoder())
			)
		);
    return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt {
                jwtDecoder = myCustomDecoder()
            }
        }
    }
}
----
======

当你需要更深层次的配置时（例如 <<webflux-oauth2resourceserver-jwt-validation,验证>>），这非常有用。

[[webflux-oauth2resourceserver-decoder-bean]]
==== 暴露一个 `ReactiveJwtDecoder` `@Bean`

另外，暴露一个 `ReactiveJwtDecoder` `@Bean` 与使用 `decoder()` 效果相同：
你可以使用 `jwkSetUri` 构造一个，如下所示：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withJwkSetUri(jwkSetUri).build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withJwkSetUri(jwkSetUri).build()
}
----
======

或者你可以使用发行者并让 `NimbusReactiveJwtDecoder` 在调用 `build()` 时查找 `jwkSetUri`，如下所示：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withIssuerLocation(issuer).build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withIssuerLocation(issuer).build()
}
----
======

或者，如果默认设置适合你，你也可以使用 `JwtDecoders`，它除了配置解码器的验证器外还会执行上述操作：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public ReactiveJwtDecoder jwtDecoder() {
    return ReactiveJwtDecoders.fromIssuerLocation(issuer);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return ReactiveJwtDecoders.fromIssuerLocation(issuer)
}
----
======

[[webflux-oauth2resourceserver-jwt-decoder-algorithm]]
== 配置受信任的算法

默认情况下，`NimbusReactiveJwtDecoder` 及其对应的资源服务器仅信任并验证使用 `RS256` 的 Token。

你可以通过 <<webflux-oauth2resourceserver-jwt-boot-algorithm,Spring Boot>> 或使用 <<webflux-oauth2resourceserver-jwt-decoder-builder,NimbusJwtDecoder 构建器>> 来自定义此行为。

[[webflux-oauth2resourceserver-jwt-boot-algorithm]]
=== 使用 Spring Boot 自定义受信任的算法

设置算法最简单的方法是作为属性：

[source,yaml]
----
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jws-algorithms: RS512
          jwk-set-uri: https://idp.example.org/.well-known/jwks.json
----

[[webflux-oauth2resourceserver-jwt-decoder-builder]]
=== 使用构建器自定义受信任的算法

为了更大的灵活性，我们可以使用 `NimbusReactiveJwtDecoder` 提供的构建器：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withIssuerLocation(this.issuer)
            .jwsAlgorithm(RS512).build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withIssuerLocation(this.issuer)
            .jwsAlgorithm(RS512).build()
}
----
======

多次调用 `jwsAlgorithm` 可配置 `NimbusReactiveJwtDecoder` 信任多个算法：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withIssuerLocation(this.issuer)
            .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withIssuerLocation(this.issuer)
            .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build()
}
----
======

或者，你也可以调用 `jwsAlgorithms`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withIssuerLocation(this.jwkSetUri)
            .jwsAlgorithms(algorithms -> {
                    algorithms.add(RS512);
                    algorithms.add(ES512);
            }).build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withIssuerLocation(this.jwkSetUri)
            .jwsAlgorithms {
                it.add(RS512)
                it.add(ES512)
            }
            .build()
}
----
======

[[webflux-oauth2resourceserver-jwt-decoder-public-key]]
=== 信任单个非对称密钥

比使用 JWK Set 端点更简单的方式是硬编码 RSA 公钥。公钥可以通过 <<webflux-oauth2resourceserver-jwt-decoder-public-key-boot,Spring Boot>> 或 <<webflux-oauth2resourceserver-jwt-decoder-public-key-builder,使用构建器>> 提供。

[[webflux-oauth2resourceserver-jwt-decoder-public-key-boot]]
==== 通过 Spring Boot

你可以使用 Spring Boot 指定一个密钥：

[source,yaml]
----
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          public-key-location: classpath:my-key.pub
----

或者，为了允许更复杂的查找，你可以后处理 `RsaKeyConversionServicePostProcessor`：

BeanFactoryPostProcessor
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
BeanFactoryPostProcessor conversionServiceCustomizer() {
    return beanFactory ->
        beanFactory.getBean(RsaKeyConversionServicePostProcessor.class)
                .setResourceLoader(new CustomResourceLoader());
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun conversionServiceCustomizer(): BeanFactoryPostProcessor {
    return BeanFactoryPostProcessor { beanFactory: ConfigurableListableBeanFactory ->
        beanFactory.getBean<RsaKeyConversionServicePostProcessor>()
                .setResourceLoader(CustomResourceLoader())
    }
}
----
======

指定你的密钥位置：

[source,yaml]
----
key.location: hfds://my-key.pub
----

然后自动装配该值：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Value("${key.location}")
RSAPublicKey key;
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Value("\${key.location}")
val key: RSAPublicKey? = null
----
======

[[webflux-oauth2resourceserver-jwt-decoder-public-key-builder]]
==== 使用构建器

要直接注入 `RSAPublicKey`，请使用适当的 `NimbusReactiveJwtDecoder` 构建器：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withPublicKey(this.key).build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withPublicKey(key).build()
}
----
======

[[webflux-oauth2resourceserver-jwt-decoder-secret-key]]
=== 信任单个对称密钥

你也可以使用单个对称密钥。你可以加载你的 `SecretKey` 并使用适当的 `NimbusReactiveJwtDecoder` 构建器：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withSecretKey(this.key).build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withSecretKey(this.key).build()
}
----
======

[[webflux-oauth2resourceserver-jwt-authorization]]
=== 配置授权

由 OAuth 2.0 授权服务器发出的 JWT 通常具有 `scope` 或 `scp` 属性，表示已授予的作用域（或权限），例如：

[source,json]
----
{ ..., "scope" : "messages contacts"}
----

在这种情况下，资源服务器会尝试将这些作用域强制转换为权限列表，并为每个作用域添加前缀 `SCOPE_`。

这意味着，若要使用来自 JWT 的作用域保护某个端点或方法，相应的表达式应包含此前缀：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
import static org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope;

@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		.authorizeExchange(exchanges -> exchanges
			.mvcMatchers("/contacts/**").access(hasScope("contacts"))
			.mvcMatchers("/messages/**").access(hasScope("messages"))
			.anyExchange().authenticated()
		)
		.oauth2ResourceServer(OAuth2ResourceServerSpec::jwt);
    return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope

@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize("/contacts/**", hasScope("contacts"))
            authorize("/messages/**", hasScope("messages"))
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt { }
        }
    }
}
----
======

你也可以对方法安全做类似的操作：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@PreAuthorize("hasAuthority('SCOPE_messages')")
public Flux<Message> getMessages(...) {}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@PreAuthorize("hasAuthority('SCOPE_messages')")
fun getMessages(): Flux<Message> { }
----
======

[[webflux-oauth2resourceserver-jwt-authorization-extraction]]
==== 手动提取权限

然而，在某些情况下，默认设置不足以满足需求。例如，一些授权服务器不使用 `scope` 属性，而是使用自己的自定义属性。有时，资源服务器可能需要将属性或属性组合适配为内部权限。

为此，DSL 提供了 `jwtAuthenticationConverter()`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		.authorizeExchange(exchanges -> exchanges
			.anyExchange().authenticated()
		)
		.oauth2ResourceServer(oauth2 -> oauth2
			.jwt(jwt -> jwt
				.jwtAuthenticationConverter(grantedAuthoritiesExtractor())
			)
		);
	return http.build();
}

Converter<Jwt, Mono<AbstractAuthenticationToken>> grantedAuthoritiesExtractor() {
    JwtAuthenticationConverter jwtAuthenticationConverter =
            new JwtAuthenticationConverter();
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter
            (new GrantedAuthoritiesExtractor());
    return new ReactiveJwtAuthenticationConverterAdapter(jwtAuthenticationConverter);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt {
                jwtAuthenticationConverter = grantedAuthoritiesExtractor()
            }
        }
    }
}

fun grantedAuthoritiesExtractor(): Converter<Jwt, Mono<AbstractAuthenticationToken>> {
    val jwtAuthenticationConverter = JwtAuthenticationConverter()
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(GrantedAuthoritiesExtractor())
    return ReactiveJwtAuthenticationConverterAdapter(jwtAuthenticationConverter)
}
----
======

`jwtAuthenticationConverter()` 负责将 `Jwt` 转换为 `Authentication`。在其配置中，我们可以提供一个子转换器，将 `Jwt` 转换为一组授予的权限。

该最终转换器可能是类似于以下 `GrantedAuthoritiesExtractor` 的内容：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
static class GrantedAuthoritiesExtractor
        implements Converter<Jwt, Collection<GrantedAuthority>> {

    public Collection<GrantedAuthority> convert(Jwt jwt) {
        Collection<?> authorities = (Collection<?>)
                jwt.getClaims().getOrDefault("mycustomclaim", Collections.emptyList());

        return authorities.stream()
                .map(Object::toString)
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
internal class GrantedAuthoritiesExtractor : Converter<Jwt, Collection<GrantedAuthority>> {
    override fun convert(jwt: Jwt): Collection<GrantedAuthority> {
        val authorities: List<Any> = jwt.claims
                .getOrDefault("mycustomclaim", emptyList<Any>()) as List<Any>
        return authorities
                .map { it.toString() }
                .map { SimpleGrantedAuthority(it) }
    }
}
----
======

为了更高的灵活性，DSL 支持完全替换实现 `Converter<Jwt, Mono<AbstractAuthenticationToken>>` 的任何类的转换器：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
static class CustomAuthenticationConverter implements Converter<Jwt, Mono<AbstractAuthenticationToken>> {
    public AbstractAuthenticationToken convert(Jwt jwt) {
        return Mono.just(jwt).map(this::doConversion);
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
internal class CustomAuthenticationConverter : Converter<Jwt, Mono<AbstractAuthenticationToken>> {
    override fun convert(jwt: Jwt): Mono<AbstractAuthenticationToken> {
        return Mono.just(jwt).map(this::doConversion)
    }
}
----
======

[[webflux-oauth2resourceserver-jwt-validation]]
=== 配置验证

使用 <<webflux-oauth2resourceserver-jwt-minimalconfiguration,最小 Spring Boot 配置>> 指定授权服务器的发行者 URI，资源服务器默认会验证 `iss` 声明以及 `exp` 和 `nbf` 时间戳声明。

在需要自定义验证需求的情况下，资源服务器提供了两个标准验证器，并接受自定义的 `OAuth2TokenValidator` 实例。

[[webflux-oauth2resourceserver-jwt-validation-clockskew]]
==== 自定义时间戳验证

JWT 实例通常具有有效期窗口，窗口开始由 `nbf` 声明指示，结束由 `exp` 声明指示。

然而，每台服务器都可能出现时钟漂移，这可能导致在一个服务器看来 Token 已过期而在另一个服务器看来尚未过期。随着分布式系统中协作服务器数量的增加，这可能会引起一些实现上的麻烦。

资源服务器使用 `JwtTimestampValidator` 来验证 Token 的有效窗口，并且你可以通过配置 `clockSkew` 来缓解时钟漂移问题：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
ReactiveJwtDecoder jwtDecoder() {
     NimbusReactiveJwtDecoder jwtDecoder = (NimbusReactiveJwtDecoder)
             ReactiveJwtDecoders.fromIssuerLocation(issuerUri);

     OAuth2TokenValidator<Jwt> withClockSkew = new DelegatingOAuth2TokenValidator<>(
            new JwtTimestampValidator(Duration.ofSeconds(60)),
            new IssuerValidator(issuerUri));

     jwtDecoder.setJwtValidator(withClockSkew);

     return jwtDecoder;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    val jwtDecoder = ReactiveJwtDecoders.fromIssuerLocation(issuerUri) as NimbusReactiveJwtDecoder
    val withClockSkew: OAuth2TokenValidator<Jwt> = DelegatingOAuth2TokenValidator(
            JwtTimestampValidator(Duration.ofSeconds(60)),
            JwtIssuerValidator(issuerUri))
    jwtDecoder.setJwtValidator(withClockSkew)
    return jwtDecoder
}
----
======

[NOTE]
====
默认情况下，资源服务器配置了 60 秒的时钟偏差。
====

[[webflux-oauth2resourceserver-validation-custom]]
==== 配置自定义验证器

你可以使用 `OAuth2TokenValidator` API 添加对 `aud` 声明的检查：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
public class AudienceValidator implements OAuth2TokenValidator<Jwt> {
    OAuth2Error error = new OAuth2Error("invalid_token", "The required audience is missing", null);

    public OAuth2TokenValidatorResult validate(Jwt jwt) {
        if (jwt.getAudience().contains("messaging")) {
            return OAuth2TokenValidatorResult.success();
        } else {
            return OAuth2TokenValidatorResult.failure(error);
        }
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
class AudienceValidator : OAuth2TokenValidator<Jwt> {
    var error: OAuth2Error = OAuth2Error("invalid_token", "The required audience is missing", null)
    override fun validate(jwt: Jwt): OAuth2TokenValidatorResult {
        return if (jwt.audience.contains("messaging")) {
            OAuth2TokenValidatorResult.success()
        } else {
            OAuth2TokenValidatorResult.failure(error)
        }
    }
}
----
======

然后，要将其添加到资源服务器中，可以指定 `ReactiveJwtDecoder` 实例：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
ReactiveJwtDecoder jwtDecoder() {
    NimbusReactiveJwtDecoder jwtDecoder = (NimbusReactiveJwtDecoder)
            ReactiveJwtDecoders.fromIssuerLocation(issuerUri);

    OAuth2TokenValidator<Jwt> audienceValidator = new AudienceValidator();
    OAuth2TokenValidator<Jwt> withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri);
    OAuth2TokenValidator<Jwt> withAudience = new DelegatingOAuth2TokenValidator<>(withIssuer, audienceValidator);

    jwtDecoder.setJwtValidator(withAudience);

    return jwtDecoder;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    val jwtDecoder = ReactiveJwtDecoders.fromIssuerLocation(issuerUri) as NimbusReactiveJwtDecoder
    val audienceValidator: OAuth2TokenValidator<Jwt> = AudienceValidator()
    val withIssuer: OAuth2TokenValidator<Jwt> = JwtValidators.createDefaultWithIssuer(issuerUri)
    val withAudience: OAuth2TokenValidator<Jwt> = DelegatingOAuth2TokenValidator(withIssuer, audienceValidator)
    jwtDecoder.setJwtValidator(withAudience)
    return jwtDecoder
}
----
======