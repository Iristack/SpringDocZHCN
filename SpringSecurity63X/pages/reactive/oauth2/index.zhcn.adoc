[[webflux-oauth2]]
= OAuth2 WebFlux

Spring Security 提供了全面的 OAuth 2.0 支持。
本节讨论如何将 OAuth 2.0 集成到你的响应式应用程序中。

[[oauth2-overview]]
== 概述

Spring Security 的 OAuth 2.0 支持包含两个主要功能集：

* <<oauth2-resource-server>>
* <<oauth2-client>>

[NOTE]
====
<<oauth2-client-log-users-in,OAuth2 登录>> 是一个非常强大的 OAuth2 客户端功能，在参考文档中值得拥有自己的章节。
然而，它并不是一个独立的功能，需要依赖 OAuth2 客户端才能正常工作。
====

这些功能集涵盖了 https://tools.ietf.org/html/rfc6749#section-1.1[OAuth 2.0 授权框架] 中定义的 _资源服务器_ 和 _客户端_ 角色，而 _授权服务器_ 角色则由 https://docs.spring.io/spring-authorization-server/reference/index.html[Spring Authorization Server] 覆盖，这是一个基于 xref:index.adoc[Spring Security] 构建的独立项目。

在 OAuth2 中，_资源服务器_ 和 _客户端_ 角色通常由一个或多个服务端应用程序表示。
此外，_授权服务器_ 角色可以由一个或多个第三方表示（例如在组织内集中身份管理和/或认证时的情况）*-或者-* 可以由一个应用程序表示（如 Spring Authorization Server 的情况）。

例如，典型的基于 OAuth2 的微服务架构可能包括一个面向用户的客户端应用程序、几个提供 REST API 的后端资源服务器以及一个用于管理用户和认证问题的第三方授权服务器。
也很常见的是，单个应用程序只代表其中一个角色，并且需要与一个或多个提供其他角色的第三方集成。

Spring Security 处理这些场景以及其他更多场景。
以下部分介绍了 Spring Security 提供的角色，并包含常见场景的示例。

[[oauth2-resource-server]]
== OAuth2 资源服务器

[NOTE]
====
本节总结了 OAuth2 资源服务器功能并提供了示例。
有关完整的参考文档，请参阅 xref:reactive/oauth2/resource-server/index.adoc[OAuth 2.0 资源服务器]。
====

要开始使用，请将 `spring-security-oauth2-resource-server` 依赖项添加到你的项目中。
当使用 Spring Boot 时，添加以下启动器：

.Spring Boot 中的 OAuth2 客户端
[tabs]
======
Gradle::
+
[source,gradle,role="primary"]
----
implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'
----

Maven::
+
[source,maven,role="secondary"]
----
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
----
======

[TIP]
====
如果不使用 Spring Boot，请参阅 xref:getting-spring-security.adoc[] 获取其他选项。
====

考虑以下适用于 OAuth2 资源服务器的用例：

* <<oauth2-resource-server-access-token,我想使用 OAuth2 保护对 API 的访问>> （授权服务器提供 JWT 或不透明的访问令牌）
* <<oauth2-resource-server-custom-jwt,我想使用 JWT 保护对 API 的访问>> （自定义令牌）

[[oauth2-resource-server-access-token]]
=== 使用 OAuth2 访问令牌保护访问

使用 OAuth2 访问令牌来保护 API 访问是非常常见的。
在大多数情况下，Spring Security 只需最少的配置即可使用 OAuth2 保护应用程序。

Spring Security 支持两种类型的 `Bearer` 令牌，每种类型都使用不同的组件进行验证：

* <<oauth2-resource-server-access-token-jwt,JWT 支持>> 使用 `ReactiveJwtDecoder` bean 来验证签名并解码令牌
* <<oauth2-resource-server-access-token-opaque,不透明令牌支持>> 使用 `ReactiveOpaqueTokenIntrospector` bean 来检查令牌

[[oauth2-resource-server-access-token-jwt]]
==== JWT 支持

以下示例使用 Spring Boot 配置属性配置 `ReactiveJwtDecoder` bean：

[source,yaml]
----
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://my-auth-server.com
----

使用 Spring Boot 时，这就是所需的全部内容。
Spring Boot 提供的默认配置等同于以下内容：

使用 JWT 配置资源服务器
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

	@Bean
	public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
		http
			.authorizeExchange((authorize) -> authorize
				.anyExchange().authenticated()
			)
			.oauth2ResourceServer((oauth2) -> oauth2
				.jwt(Customizer.withDefaults())
			);
		return http.build();
	}

	@Bean
	public ReactiveJwtDecoder jwtDecoder() {
		return ReactiveJwtDecoders.fromIssuerLocation("https://my-auth-server.com");
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.web.server.invoke

@Configuration
@EnableWebFluxSecurity
class SecurityConfig {

	@Bean
	fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
		return http {
			authorizeExchange {
				authorize(anyExchange, authenticated)
			}
			oauth2ResourceServer {
				jwt { }
			}
		}
	}

	@Bean
	fun jwtDecoder(): ReactiveJwtDecoder {
		return ReactiveJwtDecoders.fromIssuerLocation("https://my-auth-server.com")
	}

}
----
=====

[[oauth2-resource-server-access-token-opaque]]
==== 不透明令牌支持

以下示例使用 Spring Boot 配置属性配置 `OpaqueTokenIntrospector` bean：

[source,yaml]
----
spring:
  security:
    oauth2:
      resourceserver:
        opaquetoken:
          introspection-uri: https://my-auth-server.com/oauth2/introspect
          client-id: my-client-id
          client-secret: my-client-secret
----

使用 Spring Boot 时，这就是所需的全部内容。
Spring Boot 提供的默认配置等同于以下内容：

使用不透明令牌配置资源服务器
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

	@Bean
	public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
		http
			.authorizeExchange((authorize) -> authorize
				.anyExchange().authenticated()
			)
			.oauth2ResourceServer((oauth2) -> oauth2
				.opaqueToken(Customizer.withDefaults())
			);
		return http.build();
	}

	@Bean
	public ReactiveOpaqueTokenIntrospector opaqueTokenIntrospector() {
		return new SpringReactiveOpaqueTokenIntrospector(
			"https://my-auth-server.com/oauth2/introspect", "my-client-id", "my-client-secret");
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.web.server.invoke

@Configuration
@EnableWebFluxSecurity
class SecurityConfig {

	@Bean
	fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
		return http {
			authorizeExchange {
				authorize(anyExchange, authenticated)
			}
			oauth2ResourceServer {
				opaqueToken { }
			}
		}
	}

	@Bean
	fun opaqueTokenIntrospector(): ReactiveOpaqueTokenIntrospector {
		return SpringReactiveOpaqueTokenIntrospector(
			"https://my-auth-server.com/oauth2/introspect", "my-client-id", "my-client-secret"
		)
	}

}
----
=====

[[oauth2-resource-server-custom-jwt]]
=== 使用自定义 JWT 保护访问

使用 JWT 保护对 API 的访问是一个相当常见的目标，特别是当前端开发为单页应用时。
Spring Security 中的 OAuth2 资源服务器支持可用于任何类型的 `Bearer` 令牌，包括自定义 JWT。

使用 JWT 保护 API 所需的一切就是一个 `ReactiveJwtDecoder` bean，该 bean 用于验证签名并解码令牌。
Spring Security 将自动使用提供的 bean 在 `SecurityWebFilterChain` 内配置保护。

以下示例使用 Spring Boot 配置属性配置 `ReactiveJwtDecoder` bean：

[source,yaml]
----
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          public-key-location: classpath:my-public-key.pub
----

[NOTE]
====
你可以将公钥作为类路径资源提供（在此示例中称为 `my-public-key.pub`）。
====

使用 Spring Boot 时，这就是所需的全部内容。
Spring Boot 提供的默认配置等同于以下内容：

使用自定义 JWT 配置资源服务器
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

	@Bean
	public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
		http
			.authorizeExchange((authorize) -> authorize
				.anyExchange().authenticated()
			)
			.oauth2ResourceServer((oauth2) -> oauth2
				.jwt(Customizer.withDefaults())
			);
		return http.build();
	}

	@Bean
	public ReactiveJwtDecoder jwtDecoder() {
		return NimbusReactiveJwtDecoder.withPublicKey(publicKey()).build();
	}

	private RSAPublicKey publicKey() {
		// ...
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.web.server.invoke

@Configuration
@EnableWebFluxSecurity
class SecurityConfig {

	@Bean
	fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
		return http {
			authorizeExchange {
				authorize(anyExchange, authenticated)
			}
			oauth2ResourceServer {
				jwt { }
			}
		}
	}

	@Bean
	fun jwtDecoder(): ReactiveJwtDecoder {
		return NimbusReactiveJwtDecoder.withPublicKey(publicKey()).build()
	}

	private fun publicKey(): RSAPublicKey {
		// ...
	}

}
----
=====

[NOTE]
====
Spring Security 不提供用于铸造令牌的端点。
但是，Spring Security 确实提供了 `JwtEncoder` 接口及其一个实现，即 `NimbusJwtEncoder`。
====

[[oauth2-client]]
== OAuth2 客户端

[NOTE]
====
本节总结了 OAuth2 客户端功能并提供了示例。
有关完整参考文档，请参阅 xref:reactive/oauth2/client/index.adoc[OAuth 2.0 客户端] 和 xref:reactive/oauth2/login/index.adoc[OAuth 2.0 登录]。
====

要开始使用，请将 `spring-security-oauth2-client` 依赖项添加到你的项目中。
当使用 Spring Boot 时，添加以下启动器：

.Spring Boot 中的 OAuth2 客户端
[tabs]
======
Gradle::
+
[source,gradle,role="primary"]
----
implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'
----

Maven::
+
[source,maven,role="secondary"]
----
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>
----
======

[TIP]
====
如果不使用 Spring Boot，请参阅 xref:getting-spring-security.adoc[] 获取其他选项。
====

考虑以下适用于 OAuth2 客户端的用例：

* <<oauth2-client-log-users-in,我想使用 OAuth 2.0 或 OpenID Connect 1.0 登录用户>>
* <<oauth2-client-access-protected-resources,我想为用户获取访问令牌以访问第三方 API>>
* <<oauth2-client-access-protected-resources-current-user,我想同时做到这两点>> （登录用户 _并_ 访问第三方 API）
* <<oauth2-client-enable-extension-grant-type,我想启用扩展授权类型>>
* <<oauth2-client-customize-existing-grant-type,我想自定义现有授权类型>>
* <<oauth2-client-customize-request-parameters,我想自定义令牌请求参数>>
* <<oauth2-client-customize-web-client,我想自定义 OAuth2 客户端组件使用的 `WebClient`>>

[[oauth2-client-log-users-in]]
=== 使用 OAuth2 登录用户

要求用户通过 OAuth2 登录是很常见的。
https://openid.net/specs/openid-connect-core-1_0.html[OpenID Connect 1.0] 提供了一种名为 `id_token` 的特殊令牌，旨在使 OAuth2 客户端能够执行用户身份验证并登录用户。
在某些情况下，可以直接使用 OAuth2 登录用户（例如流行的社交登录提供商，如 GitHub 和 Facebook，它们并未实现 OpenID Connect）。

以下示例配置应用程序作为一个能够使用 OAuth2 或 OpenID Connect 登录用户的 OAuth2 客户端：

配置 OAuth2 登录
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

	@Bean
	public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
		http
			// ...
			.oauth2Login(Customizer.withDefaults());
		return http.build();
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.web.server.invoke

@Configuration
@EnableWebFluxSecurity
class SecurityConfig {

	@Bean
	fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
		return http {
			// ...
			oauth2Login { }
		}
	}

}
----
=====

除了上述配置外，应用程序还需要至少配置一个 `ClientRegistration`，通过使用 `ReactiveClientRegistrationRepository` bean 实现。
以下示例使用 Spring Boot 配置属性配置 `InMemoryReactiveClientRegistrationRepository` bean：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          my-oidc-client:
            provider: my-oidc-provider
            client-id: my-client-id
            client-secret: my-client-secret
            authorization-grant-type: authorization_code
            scope: openid,profile
        provider:
          my-oidc-provider:
            issuer-uri: https://my-oidc-provider.com
----

通过以上配置，应用程序现在支持两个额外的端点：

1. 登录端点（例如 `/oauth2/authorization/my-oidc-client`）用于启动登录并重定向到第三方授权服务器。
2. 重定向端点（例如 `/login/oauth2/code/my-oidc-client`）被授权服务器用来重定向回客户端应用程序，并将包含一个 `code` 参数，用于通过访问令牌请求获取 `id_token` 和/或 `access_token`。

[NOTE]
====
上述配置中的 `openid` 范围的存在表明应使用 OpenID Connect 1.0。
这指示 Spring Security 在请求处理期间使用特定于 OIDC 的组件（如 `OidcReactiveOAuth2UserService`）。
如果没有此范围，Spring Security 将改用特定于 OAuth2 的组件（如 `DefaultReactiveOAuth2UserService`）。
====

[[oauth2-client-access-protected-resources]]
=== 访问受保护的资源

向受 OAuth2 保护的第三方 API 发出请求是 OAuth2 客户端的核心用例。
这是通过授权客户端（在 Spring Security 中由 `OAuth2AuthorizedClient` 类表示）并在传出请求的 `Authorization` 头中放置 `Bearer` 令牌来实现的。

以下示例配置应用程序作为一个能够从第三方 API 请求受保护资源的 OAuth2 客户端：

配置 OAuth2 客户端
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

	@Bean
	public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
		http
			// ...
			.oauth2Client(Customizer.withDefaults());
		return http.build();
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.web.server.invoke

@Configuration
@EnableWebFluxSecurity
class SecurityConfig {

	@Bean
	fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
		return http {
			// ...
			oauth2Client { }
		}
	}

}
----
=====

[NOTE]
====
上面的例子没有提供一种登录用户的方式。
你可以使用任何其他登录机制（例如 `formLogin()`）。
请参见下一节 <<oauth2-client-access-protected-resources-current-user,>>，了解结合 `oauth2Client()` 和 `oauth2Login()` 的示例。
====

除了上述配置之外，应用程序还需要至少配置一个 `ClientRegistration`，通过使用 `ReactiveClientRegistrationRepository` bean 实现。
以下示例使用 Spring Boot 配置属性配置 `InMemoryReactiveClientRegistrationRepository` bean：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: my-client-id
            client-secret: my-client-secret
            authorization-grant-type: authorization_code
            scope: message.read,message.write
        provider:
          my-auth-server:
            issuer-uri: https://my-auth-server.com
----

除了配置 Spring Security 以支持 OAuth2 客户端功能外，你还需要决定如何访问受保护的资源，并相应地配置你的应用程序。
Spring Security 提供了 `ReactiveOAuth2AuthorizedClientManager` 的实现，用于获取可用于访问受保护资源的访问令牌。

[TIP]
====
当不存在时，Spring Security 会为你注册一个默认的 `ReactiveOAuth2AuthorizedClientManager` bean。
====

使用 `ReactiveOAuth2AuthorizedClientManager` 最简单的方法是通过一个拦截请求的 `ExchangeFilterFunction` 使用 `WebClient`。

以下示例使用默认的 `ReactiveOAuth2AuthorizedClientManager` 配置 `WebClient`，使其能够在每个请求的 `Authorization` 头中放置 `Bearer` 令牌来访问受保护的资源：

使用 `ExchangeFilterFunction` 配置 `WebClient`
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
public class WebClientConfig {

	@Bean
	public WebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) {
		ServerOAuth2AuthorizedClientExchangeFilterFunction filter =
				new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
		return WebClient.builder()
				.filter(filter)
				.build();
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
class WebClientConfig {

	@Bean
	fun webClient(authorizedClientManager: ReactiveOAuth2AuthorizedClientManager): WebClient {
		val filter = ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)
		return WebClient.builder()
			.filter(filter)
			.build()
	}

}
----
=====

这个配置好的 `WebClient` 可以按以下示例使用：

[[oauth2-client-accessing-protected-resources-example]]
使用 `WebClient` 访问受保护的资源
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
import static org.springframework.security.oauth2.client.web.reactive.function.client.ServerOAuth2AuthorizedClientExchangeFilterFunction.clientRegistrationId;

@RestController
public class MessagesController {

	private final WebClient webClient;

	public MessagesController(WebClient webClient) {
		this.webClient = webClient;
	}

	@GetMapping("/messages")
	public Mono<ResponseEntity<List<Message>>> messages() {
		return this.webClient.get()
				.uri("http://localhost:8090/messages")
				.attributes(clientRegistrationId("my-oauth2-client"))
				.retrieve()
				.toEntityList(Message.class);
	}

	public record Message(String message) {
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.oauth2.client.web.reactive.function.client.ServerOAuth2AuthorizedClientExchangeFilterFunction.clientRegistrationId

@RestController
class MessagesController(private val webClient: WebClient) {

	@GetMapping("/messages")
	fun messages(): Mono<ResponseEntity<List<Message>>> {
		return webClient.get()
			.uri("http://localhost:8090/messages")
			.attributes(clientRegistrationId("my-oauth2-client"))
			.retrieve()
			.toEntityList<Message>()
	}

	data class Message(val message: String)

}
----
=====

[[oauth2-client-access-protected-resources-current-user]]
=== 为当前用户访问受保护的资源

当用户通过 OAuth2 或 OpenID Connect 登录时，授权服务器可能会提供一个可以直接用于访问受保护资源的访问令牌。
这很方便，因为它只需要配置一个 `ClientRegistration` 即可同时满足这两种用途。

[NOTE]
====
本节将 <<oauth2-client-log-users-in>> 和 <<oauth2-client-access-protected-resources>> 结合到单一配置中。
还存在其他高级场景，例如为登录配置一个 `ClientRegistration` 并为访问受保护资源配置另一个。
所有这些场景都会使用相同的基本配置。
====

以下示例配置应用程序作为一个既能登录用户又能从第三方 API 请求受保护资源的 OAuth2 客户端：

配置 OAuth2 登录和 OAuth2 客户端
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

	@Bean
	public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
		http
			// ...
			.oauth2Login(Customizer.withDefaults())
			.oauth2Client(Customizer.withDefaults());
		return http.build();
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.web.server.invoke

@Configuration
@EnableWebFluxSecurity
class SecurityConfig {

	@Bean
	fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
		return http {
			// ...
			oauth2Login { }
			oauth2Client { }
		}
	}

}
----
=====

除了上述配置外，应用程序还需要至少配置一个 `ClientRegistration`，通过使用 `ReactiveClientRegistrationRepository` bean 实现。
以下示例使用 Spring Boot 配置属性配置 `InMemoryReactiveClientRegistrationRepository` bean：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          my-combined-client:
            provider: my-auth-server
            client-id: my-client-id
            client-secret: my-client-secret
            authorization-grant-type: authorization_code
            scope: openid,profile,message.read,message.write
        provider:
          my-auth-server:
            issuer-uri: https://my-auth-server.com
----

[NOTE]
====
与前面的例子（<<oauth2-client-log-users-in>>,  <<oauth2-client-access-protected-resources>>）相比，主要区别在于通过 `scope` 属性配置的内容，它将标准范围 `openid` 和 `profile` 与自定义范围 `message.read` 和 `message.write` 结合在一起。
====

除了配置 Spring Security 以支持 OAuth2 客户端功能外，你还需要决定如何访问受保护的资源，并相应地配置你的应用程序。
Spring Security 提供了 `ReactiveOAuth2AuthorizedClientManager` 的实现，用于获取可用于访问受保护资源的访问令牌。

[TIP]
====
当不存在时，Spring Security 会为你注册一个默认的 `ReactiveOAuth2AuthorizedClientManager` bean。
====

使用 `ReactiveOAuth2AuthorizedClientManager` 最简单的方法是通过一个拦截请求的 `ExchangeFilterFunction` 使用 `WebClient`。

以下示例使用默认的 `ReactiveOAuth2AuthorizedClientManager` 配置 `WebClient`，使其能够在每个请求的 `Authorization` 头中放置 `Bearer` 令牌来访问受保护的资源：

使用 `ExchangeFilterFunction` 配置 `WebClient`
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
public class WebClientConfig {

	@Bean
	public WebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) {
		ServerOAuth2AuthorizedClientExchangeFilterFunction filter =
				new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
		return WebClient.builder()
				.filter(filter)
				.build();
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
class WebClientConfig {

	@Bean
	fun webClient(authorizedClientManager: ReactiveOAuth2AuthorizedClientManager): WebClient {
		val filter = ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)
		return WebClient.builder()
			.filter(filter)
			.build()
	}

}
----
=====

这个配置好的 `WebClient` 可以按以下示例使用：

[[oauth2-client-accessing-protected-resources-current-user-example]]
使用 `WebClient` 访问受保护的资源（当前用户）
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@RestController
public class MessagesController {

	private final WebClient webClient;

	public MessagesController(WebClient webClient) {
		this.webClient = webClient;
	}

	@GetMapping("/messages")
	public Mono<ResponseEntity<List<Message>>> messages() {
		return this.webClient.get()
				.uri("http://localhost:8090/messages")
				.retrieve()
				.toEntityList(Message.class);
	}

	public record Message(String message) {
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@RestController
class MessagesController(private val webClient: WebClient) {

	@GetMapping("/messages")
	fun messages(): Mono<ResponseEntity<List<Message>>> {
		return webClient.get()
			.uri("http://localhost:8090/messages")
			.retrieve()
			.toEntityList<Message>()
	}

	data class Message(val message: String)

}
----
=====

[NOTE]
====
与 <<oauth2-client-accessing-protected-resources-example,前一个例子>> 不同，请注意我们不需要告诉 Spring Security 我们想要使用的 `clientRegistrationId`。
这是因为可以从当前登录的用户推导出来。
====

[[oauth2-client-enable-extension-grant-type]]
=== 启用扩展授权类型

一个常见的用例涉及启用和/或配置扩展授权类型。
例如，Spring Security 提供了对 `jwt-bearer` 和 `token-exchange` 授权类型的支持，但默认情况下不会启用它们，因为它们不属于核心 OAuth 2.0 规范。

从 Spring Security 6.3 开始，我们可以简单地发布一个或多个 `ReactiveOAuth2AuthorizedClientProvider` 的 bean，它们将被自动拾取。
以下示例仅启用了 `jwt-bearer` 授权类型：

启用 `jwt-bearer` 授权类型
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
public class SecurityConfig {

	@Bean
	public ReactiveOAuth2AuthorizedClientProvider jwtBearer() {
		return new JwtBearerReactiveOAuth2AuthorizedClientProvider();
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
class SecurityConfig {

	@Bean
	fun jwtBearer(): ReactiveOAuth2AuthorizedClientProvider {
		return JwtBearerReactiveOAuth2AuthorizedClientProvider()
	}

}
----
=====

如果未提供，默认的 `ReactiveOAuth2AuthorizedClientManager` 将由 Spring Security 自动发布。

[TIP]
====
任何自定义的 `OAuth2AuthorizedClientProvider` bean 也会被拾取并应用于提供的 `ReactiveOAuth2AuthorizedClientManager`，在默认授权类型之后。
====

在 Spring Security 6.3 之前实现上述配置，我们必须自己发布这个 bean 并确保重新启用默认授权类型。
为了理解幕后配置的内容，以下是配置可能的样子：

启用 `jwt-bearer` 授权类型（6.3 之前）
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
public class SecurityConfig {

	@Bean
	public ReactiveOAuth2AuthorizedClientManager authorizedClientManager(
			ReactiveClientRegistrationRepository clientRegistrationRepository,
			ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {

		ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
			ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
				.authorizationCode()
				.refreshToken()
				.clientCredentials()
				.password()
				.provider(new JwtBearerReactiveOAuth2AuthorizedClientProvider())
				.build();

		DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultReactiveOAuth2AuthorizedClientManager(
				clientRegistrationRepository, authorizedClientRepository);
		authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

		return authorizedClientManager;
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
class SecurityConfig {

	@Bean
	fun authorizedClientManager(
		clientRegistrationRepository: ReactiveClientRegistrationRepository,
		authorizedClientRepository: ServerOAuth2AuthorizedClientRepository
	): ReactiveOAuth2AuthorizedClientManager {
		val authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
			.authorizationCode()
			.refreshToken()
			.clientCredentials()
			.password()
			.provider(JwtBearerReactiveOAuth2AuthorizedClientProvider())
			.build()

		val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(
			clientRegistrationRepository, authorizedClientRepository
		)
		authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)

		return authorizedClientManager
	}

}
----
=====

[[oauth2-client-customize-existing-grant-type]]
=== 自定义现有授权类型

通过发布 bean 来 <<oauth2-client-enable-extension-grant-type,启用扩展授权类型>> 的能力也提供了在无需重新定义默认值的情况下自定义现有授权类型的机会。
例如，如果我们想自定义 `client_credentials` 授权的 `ReactiveOAuth2AuthorizedClientProvider` 的时钟偏移，我们可以简单地发布如下 bean：

自定义客户端凭据授权类型
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
public class SecurityConfig {

	@Bean
	public ReactiveOAuth2AuthorizedClientProvider clientCredentials() {
		ClientCredentialsReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
				new ClientCredentialsReactiveOAuth2AuthorizedClientProvider();
		authorizedClientProvider.setClockSkew(Duration.ofMinutes(5));

		return authorizedClientProvider;
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
class SecurityConfig {

	@Bean
	fun clientCredentials(): ReactiveOAuth2AuthorizedClientProvider {
		val authorizedClientProvider = ClientCredentialsReactiveOAuth2AuthorizedClientProvider()
		authorizedClientProvider.setClockSkew(Duration.ofMinutes(5))
		return authorizedClientProvider
	}

}
----
=====

[[oauth2-client-customize-request-parameters]]
=== 自定义令牌请求参数

在获取访问令牌时自定义请求参数的需求相当普遍。
例如，假设我们想在令牌请求中添加一个自定义的 `audience` 参数，因为提供者需要此参数用于 `authorization_code` 授权。

我们可以简单地发布一个类型为 `ReactiveOAuth2AccessTokenResponseClient` 的 bean，其泛型类型为 `OAuth2AuthorizationCodeGrantRequest`，Spring Security 将使用它来配置 OAuth2 客户端组件。

以下示例为 `authorization_code` 授权自定义令牌请求参数：

为授权码授权自定义令牌请求参数
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
public class SecurityConfig {

	@Bean
	public ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> authorizationCodeAccessTokenResponseClient() {
		WebClientReactiveAuthorizationCodeTokenResponseClient accessTokenResponseClient =
			new WebClientReactiveAuthorizationCodeTokenResponseClient();
		accessTokenResponseClient.addParametersConverter(parametersConverter());

		return accessTokenResponseClient;
	}

	private static Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> parametersConverter() {
		return (grantRequest) -> {
			MultiValueMap<String, String> parameters = new LinkedMultiValueMap<>();
			parameters.set("audience", "xyz_value");

			return parameters;
		};
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
class SecurityConfig {

	@Bean
	fun authorizationCodeAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> {
		val accessTokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient()
		accessTokenResponseClient.addParametersConverter(parametersConverter())

		return accessTokenResponseClient
	}

	private fun parametersConverter(): Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> {
		return Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> { grantRequest ->
			LinkedMultiValueMap<String, String>().also { parameters ->
				parameters["audience"] = "xyz_value"
			}
		}
	}

}
----
=====

[TIP]
====
请注意，在这种情况下，我们不需要自定义 `SecurityWebFilterChain` bean，可以坚持使用默认设置。
如果使用 Spring Boot 且没有额外的自定义，实际上可以完全省略 `SecurityWebFilterChain` bean。
====

正如你所看到的，将 `ReactiveOAuth2AccessTokenResponseClient` 作为 bean 提供非常方便。
直接使用 Spring Security DSL 时，我们需要确保此自定义同时应用于 OAuth2 登录（如果我们使用此功能）和 OAuth2 客户端组件。
为了理解幕后的配置内容，以下是使用 DSL 的配置样子：

使用 DSL 为授权码授权自定义令牌请求参数
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

	@Bean
	public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
		WebClientReactiveAuthorizationCodeTokenResponseClient accessTokenResponseClient =
			new WebClientReactiveAuthorizationCodeTokenResponseClient();
		accessTokenResponseClient.addParametersConverter(parametersConverter());

		http
			.authorizeExchange((authorize) -> authorize
				.anyExchange().authenticated()
			)
			.oauth2Login((oauth2Login) -> oauth2Login
				.authenticationManager(new DelegatingReactiveAuthenticationManager(
					new OidcAuthorizationCodeReactiveAuthenticationManager(
						accessTokenResponseClient, new OidcReactiveOAuth2UserService()
					),
					new OAuth2LoginReactiveAuthenticationManager(
						accessTokenResponseClient, new DefaultReactiveOAuth2UserService()
					)
				))
			)
			.oauth2Client((oauth2Client) -> oauth2Client
				.authenticationManager(new OAuth2AuthorizationCodeReactiveAuthenticationManager(
					accessTokenResponseClient
				))
			);

		return http.build();
	}

	private static Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> parametersConverter() {
		// ...
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.web.server.invoke

@Configuration
@EnableWebFluxSecurity
class SecurityConfig {

	@Bean
	fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
		val accessTokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient()
		accessTokenResponseClient.addParametersConverter(parametersConverter())

		return http {
			authorizeExchange {
				authorize(anyExchange, authenticated)
			}
			oauth2Login {
				authenticationManager = DelegatingReactiveAuthenticationManager(
					OidcAuthorizationCodeReactiveAuthenticationManager(
						accessTokenResponseClient, OidcReactiveOAuth2UserService()
					),
					OAuth2LoginReactiveAuthenticationManager(
						accessTokenResponseClient, DefaultReactiveOAuth2UserService()
					)
				)
			}
			oauth2Client {
				authenticationManager = OAuth2AuthorizationCodeReactiveAuthenticationManager(
					accessTokenResponseClient
				)
			}
		}
	}

	private fun parametersConverter(): Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> {
		// ...
	}

}
----
=====

对于其他授权类型，我们可以发布额外的 `ReactiveOAuth2AccessTokenResponseClient` bean 来覆盖默认值。
例如，要为 `client_credentials` 授权自定义令牌请求，我们可以发布以下 bean：

为客户端凭据授权自定义令牌请求参数
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
public class SecurityConfig {

	@Bean
	public ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsAccessTokenResponseClient() {
		WebClientReactiveClientCredentialsTokenResponseClient accessTokenResponseClient =
				new WebClientReactiveClientCredentialsTokenResponseClient();
		accessTokenResponseClient.addParametersConverter(parametersConverter());

		return accessTokenResponseClient;
	}

	private static Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>> parametersConverter() {
		// ...
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
class SecurityConfig {

	@Bean
	fun clientCredentialsAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> {
		val accessTokenResponseClient = WebClientReactiveClientCredentialsTokenResponseClient()
		accessTokenResponseClient.addParametersConverter(parametersConverter())

		return accessTokenResponseClient
	}

	private fun parametersConverter(): Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>> {
		// ...
	}

}
----
=====

Spring Security 自动解析以下 `ReactiveOAuth2AccessTokenResponseClient` bean 的泛型类型：

* `OAuth2AuthorizationCodeGrantRequest` （参见 `WebClientReactiveAuthorizationCodeTokenResponseClient`）
* `OAuth2RefreshTokenGrantRequest` （参见 `WebClientReactiveRefreshTokenTokenResponseClient`）
* `OAuth2ClientCredentialsGrantRequest` （参见 `WebClientReactiveClientCredentialsTokenResponseClient`）
* `OAuth2PasswordGrantRequest` （参见 `WebClientReactivePasswordTokenResponseClient`）
* `JwtBearerGrantRequest` （参见 `WebClientReactiveJwtBearerTokenResponseClient`）
* `TokenExchangeGrantRequest` （参见 `WebClientReactiveTokenExchangeTokenResponseClient`）

[TIP]
====
发布类型为 `ReactiveOAuth2AccessTokenResponseClient<JwtBearerGrantRequest>` 的 bean 将自动启用 `jwt-bearer` 授权类型，无需 <<oauth2-client-enable-extension-grant-type,单独配置>>。
====

[TIP]
====
发布类型为 `ReactiveOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest>` 的 bean 将自动启用 `token-exchange` 授权类型，无需 <<oauth2-client-enable-extension-grant-type,单独配置>>。
====

[[oauth2-client-customize-web-client]]
=== 自定义 OAuth2 客户端组件使用的 `WebClient`

另一个常见的用例是需要自定义获取访问令牌时使用的 `WebClient`。
我们可能需要这样做来定制底层 HTTP 客户端库（通过自定义 `ClientHttpConnector`）以配置 SSL 设置或为企业网络应用代理设置。

从 Spring Security 6.3 开始，我们可以简单地发布类型为 `ReactiveOAuth2AccessTokenResponseClient` 的 bean，Spring Security 将为我们配置并发布一个 `ReactiveOAuth2AuthorizedClientManager` bean。

以下示例为所有支持的授权类型自定义 `WebClient`：

为 OAuth2 客户端自定义 `WebClient`
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
public class SecurityConfig {

	@Bean
	public ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> authorizationCodeAccessTokenResponseClient() {
		WebClientReactiveAuthorizationCodeTokenResponseClient accessTokenResponseClient =
			new WebClientReactiveAuthorizationCodeTokenResponseClient();
		accessTokenResponseClient.setWebClient(webClient());

		return accessTokenResponseClient;
	}

	@Bean
	public ReactiveOAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> refreshTokenAccessTokenResponseClient() {
		WebClientReactiveRefreshTokenTokenResponseClient accessTokenResponseClient =
			new WebClientReactiveRefreshTokenTokenResponseClient();
		accessTokenResponseClient.setWebClient(webClient());

		return accessTokenResponseClient;
	}

	@Bean
	public ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsAccessTokenResponseClient() {
		WebClientReactiveClientCredentialsTokenResponseClient accessTokenResponseClient =
			new WebClientReactiveClientCredentialsTokenResponseClient();
		accessTokenResponseClient.setWebClient(webClient());

		return accessTokenResponseClient;
	}

	@Bean
	public ReactiveOAuth2AccessTokenResponseClient<OAuth2PasswordGrantRequest> passwordAccessTokenResponseClient() {
		WebClientReactivePasswordTokenResponseClient accessTokenResponseClient =
			new WebClientReactivePasswordTokenResponseClient();
		accessTokenResponseClient.setWebClient(webClient());

		return accessTokenResponseClient;
	}

	@Bean
	public ReactiveOAuth2AccessTokenResponseClient<JwtBearerGrantRequest> jwtBearerAccessTokenResponseClient() {
		WebClientReactiveJwtBearerTokenResponseClient accessTokenResponseClient =
			new WebClientReactiveJwtBearerTokenResponseClient();
		accessTokenResponseClient.setWebClient(webClient());

		return accessTokenResponseClient;
	}

	@Bean
	public ReactiveOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> tokenExchangeAccessTokenResponseClient() {
		WebClientReactiveTokenExchangeTokenResponseClient accessTokenResponseClient =
			new WebClientReactiveTokenExchangeTokenResponseClient();
		accessTokenResponseClient.setWebClient(webClient());

		return accessTokenResponseClient;
	}

	@Bean
	public WebClient webClient() {
		// ...
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
class SecurityConfig {

	@Bean
	fun authorizationCodeAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> {
		val accessTokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient()
		accessTokenResponseClient.setWebClient(webClient())

		return accessTokenResponseClient
	}

	@Bean
	fun refreshTokenAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> {
		val accessTokenResponseClient = WebClientReactiveRefreshTokenTokenResponseClient()
		accessTokenResponseClient.setWebClient(webClient())

		return accessTokenResponseClient
	}

	@Bean
	fun clientCredentialsAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> {
		val accessTokenResponseClient = WebClientReactiveClientCredentialsTokenResponseClient()
		accessTokenResponseClient.setWebClient(webClient())

		return accessTokenResponseClient
	}

	@Bean
	fun passwordAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2PasswordGrantRequest> {
		val accessTokenResponseClient = WebClientReactivePasswordTokenResponseClient()
		accessTokenResponseClient.setWebClient(webClient())

		return accessTokenResponseClient
	}

	@Bean
	fun jwtBearerAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<JwtBearerGrantRequest> {
		val accessTokenResponseClient = WebClientReactiveJwtBearerTokenResponseClient()
		accessTokenResponseClient.setWebClient(webClient())

		return accessTokenResponseClient
	}

	@Bean
	fun tokenExchangeAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> {
		val accessTokenResponseClient = WebClientReactiveTokenExchangeTokenResponseClient()
		accessTokenResponseClient.setWebClient(webClient())

		return accessTokenResponseClient
	}

	@Bean
	fun webClient(): WebClient {
		// ...
	}

}
----
=====

如果未提供，默认的 `ReactiveOAuth2AuthorizedClientManager` 将由 Spring Security 自动发布。

[TIP]
====
请注意，在这种情况下，我们不需要自定义 `SecurityWebFilterChain` bean，可以坚持使用默认设置。
如果使用 Spring Boot 且没有额外的自定义，实际上可以完全省略 `SecurityWebFilterChain` bean。
====

在 Spring Security 6.3 之前，我们必须确保此自定义应用于 OAuth2 客户端组件。
虽然我们可以为 `authorization_code` 授权发布类型为 `ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest>` 的 bean，但对于其他授权类型，我们必须发布类型为 `ReactiveOAuth2AuthorizedClientManager` 的 bean。
为了理解幕后配置的内容，以下是配置可能的样子：

为 OAuth2 客户端自定义 `WebClient`（6.3 之前）
[tabs]
=====
Java::
+
[source,java,role="primary"]
----
@Configuration
public class SecurityConfig {

	@Bean
	public ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> authorizationCodeAccessTokenResponseClient() {
		WebClientReactiveAuthorizationCodeTokenResponseClient accessTokenResponseClient =
			new WebClientReactiveAuthorizationCodeTokenResponseClient();
		accessTokenResponseClient.setWebClient(webClient());

		return accessTokenResponseClient;
	}

	@Bean
	public ReactiveOAuth2AuthorizedClientManager authorizedClientManager(
			ReactiveClientRegistrationRepository clientRegistrationRepository,
			ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {

		WebClientReactiveRefreshTokenTokenResponseClient refreshTokenAccessTokenResponseClient =
			new WebClientReactiveRefreshTokenTokenResponseClient();
		refreshTokenAccessTokenResponseClient.setWebClient(webClient());

		WebClientReactiveClientCredentialsTokenResponseClient clientCredentialsAccessTokenResponseClient =
			new WebClientReactiveClientCredentialsTokenResponseClient();
		clientCredentialsAccessTokenResponseClient.setWebClient(webClient());

		WebClientReactivePasswordTokenResponseClient passwordAccessTokenResponseClient =
			new WebClientReactivePasswordTokenResponseClient();
		passwordAccessTokenResponseClient.setWebClient(webClient());

		WebClientReactiveJwtBearerTokenResponseClient jwtBearerAccessTokenResponseClient =
			new WebClientReactiveJwtBearerTokenResponseClient();
		jwtBearerAccessTokenResponseClient.setWebClient(webClient());

		JwtBearerReactiveOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider =
			new JwtBearerReactiveOAuth2AuthorizedClientProvider();
		jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerAccessTokenResponseClient);

		WebClientReactiveTokenExchangeTokenResponseClient tokenExchangeAccessTokenResponseClient =
			new WebClientReactiveTokenExchangeTokenResponseClient();
		tokenExchangeAccessTokenResponseClient.setWebClient(webClient());

		TokenExchangeReactiveOAuth2AuthorizedClientProvider tokenExchangeAuthorizedClientProvider =
			new TokenExchangeReactiveOAuth2AuthorizedClientProvider();
		tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeAccessTokenResponseClient);

		ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
			ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
				.authorizationCode()
				.refreshToken((refreshToken) -> refreshToken
					.accessTokenResponseClient(refreshTokenAccessTokenResponseClient)
				)
				.clientCredentials((clientCredentials) -> clientCredentials
					.accessTokenResponseClient(clientCredentialsAccessTokenResponseClient)
				)
				.password((password) -> password
					.accessTokenResponseClient(passwordAccessTokenResponseClient)
				)
				.provider(jwtBearerAuthorizedClientProvider)
				.provider(tokenExchangeAuthorizedClientProvider)
				.build();

		DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultReactiveOAuth2AuthorizedClientManager(
				clientRegistrationRepository, authorizedClientRepository);
		authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

		return authorizedClientManager;
	}

	@Bean
	public WebClient webClient() {
		// ...
	}

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.web.server.invoke

@Configuration
class SecurityConfig {

	@Bean
	fun authorizationCodeAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> {
		val accessTokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient()
		accessTokenResponseClient.setWebClient(webClient())

		return accessTokenResponseClient
	}

	@Bean
	fun authorizedClientManager(
		clientRegistrationRepository: ReactiveClientRegistrationRepository?,
		authorizedClientRepository: ServerOAuth2AuthorizedClientRepository?
	): ReactiveOAuth2AuthorizedClientManager {
		val refreshTokenAccessTokenResponseClient = WebClientReactiveRefreshTokenTokenResponseClient()
		refreshTokenAccessTokenResponseClient.setWebClient(webClient())

		val clientCredentialsAccessTokenResponseClient = WebClientReactiveClientCredentialsTokenResponseClient()
		clientCredentialsAccessTokenResponseClient.setWebClient(webClient())

		val passwordAccessTokenResponseClient = WebClientReactivePasswordTokenResponseClient()
		passwordAccessTokenResponseClient.setWebClient(webClient())

		val jwtBearerAccessTokenResponseClient = WebClientReactiveJwtBearerTokenResponseClient()
		jwtBearerAccessTokenResponseClient.setWebClient(webClient())

		val jwtBearerAuthorizedClientProvider = JwtBearerReactiveOAuth2AuthorizedClientProvider()
		jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerAccessTokenResponseClient)

		val tokenExchangeAccessTokenResponseClient = WebClientReactiveTokenExchangeTokenResponseClient()
		tokenExchangeAccessTokenResponseClient.setWebClient(webClient())

		val tokenExchangeAuthorizedClientProvider = TokenExchangeReactiveOAuth2AuthorizedClientProvider()
		tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeAccessTokenResponseClient)

		val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
			.authorizationCode()
			.refreshToken { refreshToken ->
				refreshToken.accessTokenResponseClient(refreshTokenAccessTokenResponseClient)
			}
			.clientCredentials { clientCredentials ->
				clientCredentials.accessTokenResponseClient(clientCredentialsAccessTokenResponseClient)
			}
			.password { password ->
				password.accessTokenResponseClient(passwordAccessTokenResponseClient)
			}
			.provider(jwtBearerAuthorizedClientProvider)
			.provider(tokenExchangeAuthorizedClientProvider)
			.build()

		val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(
			clientRegistrationRepository, authorizedClientRepository
		)
		authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)

		return authorizedClientManager
	}

	@Bean
	fun webClient(): WebClient {
		// ...
	}

}
----
=====


[[further-reading]]
== 进一步阅读

前面的部分介绍了 Spring Security 对 OAuth2 的支持，并提供了常见场景的示例。
你可以在参考文档的以下部分了解更多关于 OAuth2 客户端和资源服务器的信息：

* xref:reactive/oauth2/login/index.adoc[]
* xref:reactive/oauth2/client/index.adoc[]
* xref:reactive/oauth2/resource-server/index.adoc[]