[[webflux-serverwebexchangefirewall]]
= ServerWebExchangeFirewall

恶意用户可能通过多种方式构造请求，从而利用应用程序中的漏洞。  
Spring Security 提供了 `ServerWebExchangeFirewall` 来拒绝看起来具有恶意的请求。  
默认实现是 `StrictServerWebExchangeFirewall`，它会拒绝恶意请求。

例如，一个请求可能包含路径遍历序列（如 `/../`）或多个正斜杠（`//`），这可能导致模式匹配失败。  
某些容器在执行 Servlet 映射之前会将这些内容规范化，但其他容器则不会。  
为了防范此类问题，`WebFilterChainProxy` 使用 `ServerWebExchangeFirewall` 策略来检查并包装请求。  
默认情况下，未规范化的请求会被自动拒绝，并且在匹配时会移除路径参数。  
（例如，原始请求路径 `/secure;hack=1/somefile.html;hack=2` 会被处理为 `/secure/somefile.html`。）  
因此，使用 `WebFilterChainProxy` 至关重要。

在实践中，我们建议您在服务层使用方法级别的安全控制来管理对应用程序的访问，而不是完全依赖于在 Web 应用程序级别定义的安全约束。  
URL 可能会发生变化，而且很难考虑到应用程序可能支持的所有 URL 以及请求可能被如何篡改的情况。  
您应尽量仅使用几个简单易懂的模式。  
始终尝试采用“默认拒绝”（`deny-by-default`）的方法，即最后定义一个通配符捕获规则（如 `/**` 或 `**`），以拒绝所有未明确允许的访问。

在服务层定义的安全性更加健壮且更难绕过，因此您应充分利用 Spring Security 的方法级安全功能。

您可以通过将其声明为 Bean 来自定义 `ServerWebExchangeFirewall`。

.允许 Matrix Variables
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public StrictServerWebExchangeFirewall httpFirewall() {
    StrictServerWebExchangeFirewall firewall = new StrictServerWebExchangeFirewall();
    firewall.setAllowSemicolon(true);
    return firewall;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun httpFirewall(): StrictServerWebExchangeFirewall {
    val firewall = StrictServerWebExchangeFirewall()
    firewall.setAllowSemicolon(true)
    return firewall
}
----
======

为了防止 https://www.owasp.org/index.php/Cross_Site_Tracing[跨站追踪 (XST)] 和 https://www.owasp.org/index.php/Test_HTTP_Methods_(OTG-CONFIG-006)[HTTP 动词篡改]，`StrictServerWebExchangeFirewall` 提供了一个允许使用的 HTTP 方法白名单。  
默认允许的方法包括：`DELETE`、`GET`、`HEAD`、`OPTIONS`、`PATCH`、`POST` 和 `PUT`。  
如果您的应用需要修改有效方法列表，可以配置一个自定义的 `StrictServerWebExchangeFirewall` Bean。  
以下示例仅允许 HTTP 的 `GET` 和 `POST` 方法：

.仅允许 GET 和 POST
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public StrictServerWebExchangeFirewall httpFirewall() {
    StrictServerWebExchangeFirewall firewall = new StrictServerWebExchangeFirewall();
    firewall.setAllowedHttpMethods(Arrays.asList("GET", "POST"));
    return firewall;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun httpFirewall(): StrictServerWebExchangeFirewall {
    val firewall = StrictServerWebExchangeFirewall()
    firewall.setAllowedHttpMethods(listOf("GET", "POST"))
    return firewall
}
----
======

如果您必须允许任意 HTTP 方法（不推荐），可以使用 `StrictServerWebExchangeFirewall.setUnsafeAllowAnyHttpMethod(true)`。  
这样做将完全禁用对 HTTP 方法的验证。

[[webflux-serverwebexchangefirewall-headers-parameters]]
`StrictServerWebExchangeFirewall` 还会对请求头名称和值以及参数名称进行检查。  
它要求每个字符都具有明确定义的码点，并且不能是控制字符。

如有必要，可通过以下方法放宽或调整此要求：

* `StrictServerWebExchangeFirewall#setAllowedHeaderNames(Predicate)`
* `StrictServerWebExchangeFirewall#setAllowedHeaderValues(Predicate)`
* `StrictServerWebExchangeFirewall#setAllowedParameterNames(Predicate)`

[NOTE]
====
参数值也可以通过 `setAllowedParameterValues(Predicate)` 进行控制。
====

例如，若要关闭此项检查，您可以将 `StrictServerWebExchangeFirewall` 配置为使用始终返回 `true` 的 `Predicate` 实例：

.允许任意请求头名称、请求头值和参数名称
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public StrictServerWebExchangeFirewall httpFirewall() {
    StrictServerWebExchangeFirewall firewall = new StrictServerWebExchangeFirewall();
    firewall.setAllowedHeaderNames((header) -> true);
    firewall.setAllowedHeaderValues((header) -> true);
    firewall.setAllowedParameterNames((parameter) -> true);
    return firewall;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun httpFirewall(): StrictServerWebExchangeFirewall {
    val firewall = StrictServerWebExchangeFirewall()
    firewall.setAllowedHeaderNames { true }
    firewall.setAllowedHeaderValues { true }
    firewall.setAllowedParameterNames { true }
    return firewall
}
----
======

或者，您可能需要允许某个特定值。

例如，iPhone Xʀ 使用的 `User-Agent` 包含一个不在 ISO-8859-1 字符集中的字符。  
由于这一点，一些应用服务器会将该值解析成两个独立的字符，其中后者是一个未定义的字符。

您可以通过 `setAllowedHeaderValues` 方法解决这个问题：

.允许特定 User-Agent
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public StrictServerWebExchangeFirewall httpFirewall() {
    StrictServerWebExchangeFirewall firewall = new StrictServerWebExchangeFirewall();
    Pattern allowed = Pattern.compile("[\\p{IsAssigned}&&[^\\p{IsControl}]]*");
    Pattern userAgent = ...;
    firewall.setAllowedHeaderValues((header) -> allowed.matcher(header).matches() || userAgent.matcher(header).matches());
    return firewall;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun httpFirewall(): StrictServerWebExchangeFirewall {
    val firewall = StrictServerWebExchangeFirewall()
    val allowed = Pattern.compile("[\\p{IsAssigned}&&[^\\p{IsControl}]]*")
    val userAgent = Pattern.compile(...)
    firewall.setAllowedHeaderValues { allowed.matcher(it).matches() || userAgent.matcher(it).matches() }
    return firewall
}
----
======

对于请求头值，您还可以考虑在验证时将其解析为 UTF-8：

.将请求头作为 UTF-8 解析
[tabs]
======
Java::
+
[source,java,role="primary"]
----
firewall.setAllowedHeaderValues((header) -> {
    String parsed = new String(header.getBytes(ISO_8859_1), UTF_8);
    return allowed.matcher(parsed).matches();
});
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
firewall.setAllowedHeaderValues {
    val parsed = String(it.toByteArray(ISO_8859_1), UTF_8)
    allowed.matcher(parsed).matches()
}
----
======

`ServerExchangeRejectedHandler` 接口用于处理 Spring Security 的 `ServerWebExchangeFirewall` 抛出的 `ServerExchangeRejectedException`。  
默认情况下，当请求被拒绝时，会使用 `HttpStatusExchangeRejectedHandler` 向客户端返回 HTTP 400 响应。  
要自定义该行为，用户可以暴露一个 `ServerExchangeRejectedHandler` Bean。  
例如，以下配置会在请求被拒绝时返回 HTTP 404：

.请求被拒时返回 404
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
ServerExchangeRejectedHandler rejectedHandler() {
	return new HttpStatusExchangeRejectedHandler(HttpStatus.NOT_FOUND);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun rejectedHandler(): ServerExchangeRejectedHandler {
    return HttpStatusExchangeRejectedHandler(HttpStatus.NOT_FOUND)
}
----
======

通过创建自定义的 `ServerExchangeRejectedHandler` 实现，可以完全自定义处理逻辑。