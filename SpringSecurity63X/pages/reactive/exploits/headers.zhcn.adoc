[[webflux-headers]]
= 安全HTTP响应头

你可以使用 xref:features/exploits/headers.adoc#headers[安全HTTP响应头] 来提升Web应用程序的安全性。  
本节专门介绍基于WebFlux的Spring Security对安全HTTP响应头的支持。

[[webflux-headers-default]]
== 默认安全头

Spring Security 提供了一组 xref:features/exploits/headers.adoc#headers-default[默认的安全HTTP响应头]，以提供安全的默认配置。  
虽然这些头信息都被认为是最佳实践，但需要注意的是，并非所有客户端都支持这些头，因此建议进行额外的测试。

你可以自定义特定的响应头。例如，假设你希望保留默认配置，但想为 xref:servlet/exploits/headers.adoc#servlet-headers-frame-options[`X-Frame-Options`] 指定 `SAMEORIGIN` 值。

可以通过以下配置实现：

.自定义默认安全头
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.frameOptions(frameOptions -> frameOptions
				.mode(Mode.SAMEORIGIN)
			)
		);
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            frameOptions {
                mode = Mode.SAMEORIGIN
            }
        }
    }
}
----
======

如果你不希望添加默认头，而希望显式控制使用的头信息，可以禁用默认设置：

.禁用HTTP安全响应头
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers.disable());
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            disable()
        }
    }
}
----
======

[[webflux-headers-cache-control]]
== 缓存控制

Spring Security 默认包含 xref:features/exploits/headers.adoc#headers-cache-control[缓存控制] 响应头。

但是，如果你确实希望缓存某些特定响应，你的应用可以有选择地将它们添加到 https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/server/reactive/ServerHttpResponse.html[`ServerHttpResponse`] 中，以覆盖 Spring Security 设置的头。这有助于确保CSS、JavaScript和图片等资源被正确缓存。

在使用 Spring WebFlux 时，通常在配置中完成此操作。有关详细信息，请参阅 Spring 参考文档中的 https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-static-resources[静态资源] 部分。

如有必要，你也可以禁用 Spring Security 的缓存控制 HTTP 响应头。

.禁用缓存控制
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.cache(cache -> cache.disable())
		);
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            cache {
                disable()
            }
        }
    }
}
----
======

[[webflux-headers-content-type-options]]
== 内容类型选项

默认情况下，Spring Security 包含 xref:features/exploits/headers.adoc#headers-content-type-options[内容类型（Content-Type）] 响应头。  
但你可以将其禁用：

.禁用内容类型选项
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.contentTypeOptions(contentTypeOptions -> contentTypeOptions.disable())
		);
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            contentTypeOptions {
                disable()
            }
        }
    }
}
----
======

[[webflux-headers-hsts]]
== HTTP严格传输安全（HSTS）

默认情况下，Spring Security 提供 xref:features/exploits/headers.adoc#headers-hsts[严格传输安全（Strict Transport Security）] 响应头。  
但你可以显式自定义其行为。例如，以下示例显式配置 HSTS：

.严格传输安全
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.hsts(hsts -> hsts
				.includeSubdomains(true)
				.preload(true)
				.maxAge(Duration.ofDays(365))
			)
		);
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            hsts {
                includeSubdomains = true
                preload = true
                maxAge = Duration.ofDays(365)
            }
        }
    }
}
----
======

[[webflux-headers-frame-options]]
== X-Frame-Options

默认情况下，Spring Security 使用 xref:features/exploits/headers.adoc#headers-frame-options[`X-Frame-Options`] 头来禁止页面在 iframe 中渲染。

你可以自定义 frame 选项以允许同源嵌套：

.X-Frame-Options: SAMEORIGIN
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.frameOptions(frameOptions -> frameOptions
				.mode(SAMEORIGIN)
			)
		);
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            frameOptions {
                mode = SAMEORIGIN
            }
        }
    }
}
----
======

[[webflux-headers-xss-protection]]
== X-XSS-Protection

默认情况下，Spring Security 使用 <<headers-xss-protection,X-XSS-Protection header> 指令浏览器禁用 XSS 审计器。  
你可以完全禁用 `X-XSS-Protection` 响应头：

.X-XSS-Protection 自定义
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.xssProtection(xssProtection -> xssProtection.disable())
		);
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            xssProtection {
                disable()
            }
        }
    }
}
----
======

你也可以更改响应头的值：

.X-XSS-Protection 显式设置头值
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.xssProtection(xssProtection -> xssProtection.headerValue(XXssProtectionServerHttpHeadersWriter.HeaderValue.ENABLED_MODE_BLOCK))
		);
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            xssProtection {
                headerValue = XXssProtectionServerHttpHeadersWriter.HeaderValue.ENABLED_MODE_BLOCK
            }
        }
    }
}
----
======

[[webflux-headers-csp]]
== 内容安全策略（CSP）

默认情况下，Spring Security 不会添加 xref:features/exploits/headers.adoc#headers-csp[内容安全策略（Content Security Policy）]，因为无法在不了解应用上下文的情况下确定合理的默认策略。  
Web 应用作者必须声明需要强制执行或监控受保护资源的安全策略。

例如，考虑以下安全策略：

.内容安全策略示例
[source,http]
----
Content-Security-Policy: script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/
----

根据上述策略，你可以启用 CSP 响应头：

.内容安全策略
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.contentSecurityPolicy(policy -> policy
				.policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
			)
		);
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            contentSecurityPolicy {
                policyDirectives = "script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
            }
        }
    }
}
----
======

要启用 CSP 的“仅报告”模式（report-only），请使用以下配置：

.内容安全策略仅报告模式
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.contentSecurityPolicy(policy -> policy
				.policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
				.reportOnly()
			)
		);
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            contentSecurityPolicy {
                policyDirectives = "script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
                reportOnly = true
            }
        }
    }
}
----
======

[[webflux-headers-referrer]]
== 引用策略（Referrer Policy）

Spring Security 默认添加 xref:features/exploits/headers.adoc#headers-referrer[引用策略（Referrer Policy）] 响应头，指令为 `no-referrer`。  
你可以通过如下配置修改该头：

.引用策略配置
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.referrerPolicy(referrer -> referrer
				.policy(ReferrerPolicy.SAME_ORIGIN)
			)
		);
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            referrerPolicy {
                policy = ReferrerPolicy.SAME_ORIGIN
            }
        }
    }
}
----
======

[[webflux-headers-feature]]
== 功能策略（Feature Policy）

默认情况下，Spring Security 不添加 xref:features/exploits/headers.adoc#headers-feature[功能策略（Feature Policy）] 响应头。  
考虑以下 `Feature-Policy` 响应头：

.Feature-Policy 示例
[source]
----
Feature-Policy: geolocation 'self'
----

你可以启用上述功能策略头：

.Feature-Policy 配置
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.featurePolicy("geolocation 'self'")
		);
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            featurePolicy("geolocation 'self'")
        }
    }
}
----
======

[[webflux-headers-permissions]]
== 权限策略（Permissions Policy）

默认情况下，Spring Security 不添加 xref:features/exploits/headers.adoc#headers-permissions[权限策略（Permissions Policy）] 响应头。  
考虑以下 `Permissions-Policy` 响应头：

.Permissions-Policy 示例
[source]
----
Permissions-Policy: geolocation=(self)
----

你可以启用上述权限策略头：

.Permissions-Policy 配置
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.permissionsPolicy(permissions -> permissions
				.policy("geolocation=(self)")
			)
		);
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            permissionsPolicy {
                policy = "geolocation=(self)"
            }
        }
    }
}
----
======

[[webflux-headers-clear-site-data]]
== 清除站点数据（Clear Site Data）

默认情况下，Spring Security 不添加 xref:features/exploits/headers.adoc#headers-clear-site-data[清除站点数据（Clear-Site-Data）] 响应头。  
考虑以下 `Clear-Site-Data` 响应头：

.Clear-Site-Data 示例
----
Clear-Site-Data: "cache", "cookies"
----

你可以在用户登出时发送 `Clear-Site-Data` 响应头：

.Clear-Site-Data 配置
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	ServerLogoutHandler securityContext = new SecurityContextServerLogoutHandler();
	ClearSiteDataServerHttpHeadersWriter writer = new ClearSiteDataServerHttpHeadersWriter(CACHE, COOKIES);
	ServerLogoutHandler clearSiteData = new HeaderWriterServerLogoutHandler(writer);
	DelegatingServerLogoutHandler logoutHandler = new DelegatingServerLogoutHandler(securityContext, clearSiteData);

	http
		// ...
		.logout()
			.logoutHandler(logoutHandler);
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    val securityContext: ServerLogoutHandler = SecurityContextServerLogoutHandler()
    val writer = ClearSiteDataServerHttpHeadersWriter(CACHE, COOKIES)
    val clearSiteData: ServerLogoutHandler = HeaderWriterServerLogoutHandler(writer)
    val customLogoutHandler = DelegatingServerLogoutHandler(securityContext, clearSiteData)

    return http {
        // ...
        logout {
            logoutHandler = customLogoutHandler
        }
    }
}
----
======