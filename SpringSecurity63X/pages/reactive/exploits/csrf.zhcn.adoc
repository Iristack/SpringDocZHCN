[[webflux-csrf]]
= WebFlux 环境中的跨站请求伪造（CSRF）

本节介绍 Spring Security 在 WebFlux 环境下对 xref:features/exploits/csrf.adoc#csrf[跨站请求伪造（CSRF）] 的支持。

[[webflux-csrf-using]]
== 使用 Spring Security 的 CSRF 保护
使用 Spring Security 提供的 CSRF 保护的步骤如下所示：

* <<webflux-csrf-read-only,使用正确的 HTTP 动词>>
* <<webflux-csrf-configure,配置 CSRF 保护>>
* <<webflux-csrf-include,包含 CSRF Token>>

[[webflux-csrf-read-only]]
=== 使用正确的 HTTP 动词
防范 CSRF 攻击的第一步是确保你的网站正确使用了 HTTP 动词。  
这一点在 xref:features/exploits/csrf.adoc#csrf-protection-read-only[安全方法必须是只读的] 中有详细说明。

[[webflux-csrf-configure]]
=== 配置 CSRF 保护
下一步是在应用程序中配置 Spring Security 的 CSRF 保护。  
默认情况下，Spring Security 的 CSRF 保护是启用的，但你可能需要自定义配置。  
接下来的几个小节将介绍一些常见的自定义选项。

[[webflux-csrf-configure-custom-repository]]
==== 自定义 CsrfTokenRepository

默认情况下，Spring Security 使用 `WebSessionServerCsrfTokenRepository` 将预期的 CSRF token 存储在 `WebSession` 中。  
有时，你可能需要配置一个自定义的 `ServerCsrfTokenRepository`。  
例如，你可能希望将 `CsrfToken` 持久化到 cookie 中，以 <<webflux-csrf-include-ajax-auto,支持基于 JavaScript 的应用>>。

默认情况下，`CookieServerCsrfTokenRepository` 会写入名为 `XSRF-TOKEN` 的 cookie，并从名为 `X-XSRF-TOKEN` 的请求头或 `_csrf` HTTP 参数中读取该值。  
这些默认设置来源于 https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection[AngularJS]。

你可以通过 Java 配置来设置 `CookieServerCsrfTokenRepository`：

.将 CSRF Token 存储在 Cookie 中
[tabs]
======
Java::
+
[source,java,role="primary"]
-----
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.csrf(csrf -> csrf.csrfTokenRepository(CookieServerCsrfTokenRepository.withHttpOnlyFalse()))
	return http.build();
}
-----

Kotlin::
+
[source,kotlin,role="secondary"]
-----
@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        csrf {
            csrfTokenRepository = CookieServerCsrfTokenRepository.withHttpOnlyFalse()
        }
    }
}
-----
======

[NOTE]
====
上述示例显式设置了 `cookieHttpOnly=false`。  
这是为了让 JavaScript（此处为 AngularJS）能够读取该 cookie。  
如果你不需要直接用 JavaScript 读取 cookie，我们建议省略 `cookieHttpOnly=false`（可改用 `new CookieServerCsrfTokenRepository()`），以提升安全性。
====

[[webflux-csrf-configure-disable]]
==== 禁用 CSRF 保护
默认情况下，CSRF 保护是启用的。  
然而，如果根据你的应用场景，禁用 CSRF 保护更合适，也可以这么做。详情请参考 xref:features/exploits/csrf.adoc#csrf-when[何时使用 CSRF 保护]。

以下 Java 配置将禁用 CSRF 保护。

.禁用 CSRF 配置
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.csrf(csrf -> csrf.disable())
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
-----
@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        csrf {
            disable()
        }
    }
}
-----
======

[[webflux-csrf-configure-request-handler]]
==== 配置 ServerCsrfTokenRequestHandler

Spring Security 的 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/server/csrf/CsrfWebFilter.html[`CsrfWebFilter`] 借助 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/server/csrf/ServerCsrfTokenRequestHandler.html[`ServerCsrfTokenRequestHandler`]，将 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/server/csrf/CsrfToken.html[`Mono<CsrfToken>`] 作为名为 `org.springframework.security.web.server.csrf.CsrfToken` 的 `ServerWebExchange` 属性暴露出来。

在 5.8 版本中，默认实现是 `ServerCsrfTokenRequestAttributeHandler`，它只是简单地将 `Mono<CsrfToken>` 作为 exchange 属性提供。

从 6.0 版本开始，默认实现变更为 `XorServerCsrfTokenRequestAttributeHandler`，该实现提供了对 BREACH 攻击的防护（参见 https://github.com/spring-projects/spring-security/issues/4001[gh-4001]）。

如果你想禁用 `CsrfToken` 的 BREACH 防护并恢复到 5.8 版本的默认行为，可以使用以下 Java 配置来设置 `ServerCsrfTokenRequestAttributeHandler`：

.禁用 BREACH 防护
[tabs]
======
Java::
+
[source,java,role="primary"]
-----
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.csrf(csrf -> csrf
			.csrfTokenRequestHandler(new ServerCsrfTokenRequestAttributeHandler())
		)
	return http.build();
}
-----

Kotlin::
+
[source,kotlin,role="secondary"]
-----
@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        csrf {
            csrfTokenRequestHandler = ServerCsrfTokenRequestAttributeHandler()
        }
    }
}
-----
======

[[webflux-csrf-include]]
=== 包含 CSRF Token

为了通过 xref:features/exploits/csrf.adoc#csrf-protection-stp[同步令牌模式] 来防御 CSRF 攻击，我们必须将实际的 CSRF token 包含在 HTTP 请求中。  
它必须出现在请求的一部分中（如表单参数、HTTP 头或其他选项），而这一部分不能被浏览器自动包含在 HTTP 请求中。

<<webflux-csrf-configure-request-handler,我们已经看到>>，`Mono<CsrfToken>` 被作为 `ServerWebExchange` 属性暴露出来。  
这意味着任何视图技术都可以访问 `Mono<CsrfToken>`，从而将预期的 token 作为 <<webflux-csrf-include-form-attr,表单>> 或 <<webflux-csrf-include-ajax-meta,meta 标签>> 输出。

[[webflux-csrf-include-subscribe]]
如果你的视图技术无法方便地订阅 `Mono<CsrfToken>`，一个常见的做法是使用 Spring 的 `@ControllerAdvice` 直接暴露 `CsrfToken`。  
下面的例子将 `CsrfToken` 放在 Spring Security 的 <<webflux-csrf-include-form-auto,CsrfRequestDataValueProcessor>> 默认使用的属性名（`_csrf`）上，以便自动将 CSRF token 作为隐藏输入字段包含进来：

.`CsrfToken` 作为 `@ModelAttribute`
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@ControllerAdvice
public class SecurityControllerAdvice {
	@ModelAttribute
	Mono<CsrfToken> csrfToken(ServerWebExchange exchange) {
		Mono<CsrfToken> csrfToken = exchange.getAttribute(CsrfToken.class.getName());
		return csrfToken.doOnSuccess(token -> exchange.getAttributes()
				.put(CsrfRequestDataValueProcessor.DEFAULT_CSRF_ATTR_NAME, token));
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@ControllerAdvice
class SecurityControllerAdvice {
    @ModelAttribute
    fun csrfToken(exchange: ServerWebExchange): Mono<CsrfToken> {
        val csrfToken: Mono<CsrfToken>? = exchange.getAttribute(CsrfToken::class.java.name)
        return csrfToken!!.doOnSuccess { token ->
            exchange.attributes[CsrfRequestDataValueProcessor.DEFAULT_CSRF_ATTR_NAME] = token
        }
    }
}
----
======

幸运的是，Thymeleaf 提供了 <<webflux-csrf-include-form-auto,集成支持>>，无需额外工作即可正常运行。

[[webflux-csrf-include-form]]
==== 表单 URL 编码
要提交 HTML 表单，必须将 CSRF token 作为隐藏输入字段包含在表单中。  
以下示例展示了渲染后的 HTML 可能的样子：

.CSRF Token HTML
[source,html]
----
<input type="hidden"
	name="_csrf"
	value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
----

接下来，我们将讨论几种将 CSRF token 作为隐藏输入字段包含在表单中的方式。

[[webflux-csrf-include-form-auto]]
===== 自动包含 CSRF Token

Spring Security 的 CSRF 支持通过其 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/reactive/result/view/CsrfRequestDataValueProcessor.html[`CsrfRequestDataValueProcessor`] 与 Spring 的 https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/reactive/result/view/RequestDataValueProcessor.html[`RequestDataValueProcessor`] 集成。  
要使 `CsrfRequestDataValueProcessor` 正常工作，必须订阅 `Mono<CsrfToken>`，并且 `CsrfToken` 必须 <<webflux-csrf-include-subscribe,作为属性暴露>>，且属性名需匹配 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/reactive/result/view/CsrfRequestDataValueProcessor.html#DEFAULT_CSRF_ATTR_NAME[`DEFAULT_CSRF_ATTR_NAME`]。

幸运的是，Thymeleaf 通过与 `RequestDataValueProcessor` 集成，https://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#integration-with-requestdatavalueprocessor[自动处理所有样板代码]，确保使用非安全 HTTP 方法（POST）的表单会自动包含实际的 CSRF token。

[[webflux-csrf-include-form-attr]]
===== CsrfToken 请求属性

如果 <<webflux-csrf-include,其他方式>> 无法满足你在请求中包含实际 CSRF token 的需求，你可以利用这样一个事实：`Mono<CsrfToken>` <<webflux-csrf-include,已被暴露>> 为名为 `org.springframework.security.web.server.csrf.CsrfToken` 的 `ServerWebExchange` 属性。

以下 Thymeleaf 示例假设你已 <<webflux-csrf-include-subscribe,将 `CsrfToken` 暴露为名为 `_csrf` 的属性>：

.使用请求属性在表单中包含 CSRF Token
[source,html]
----
<form th:action="@{/logout}"
	method="post">
<input type="submit"
	value="登出" />
<input type="hidden"
	th:name="${_csrf.parameterName}"
	th:value="${_csrf.token}"/>
</form>
----

[[webflux-csrf-include-ajax]]
==== Ajax 和 JSON 请求
如果你使用 JSON，则不能通过 HTTP 参数提交 CSRF token。  
相反，你可以通过 HTTP 请求头提交 token。

在接下来的小节中，我们将讨论如何在基于 JavaScript 的应用中将 CSRF token 作为 HTTP 请求头包含进去。

[[webflux-csrf-include-ajax-auto]]
===== 自动包含

你可以 <<webflux-csrf-configure-custom-repository,配置>> Spring Security 将预期的 CSRF token 存储在 cookie 中。  
通过将 CSRF token 存储在 cookie 中，JavaScript 框架（如 https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection[AngularJS]）会自动将其包含在 HTTP 请求头中。

[[webflux-csrf-include-ajax-meta]]
===== Meta 标签

另一种替代 <<webflux-csrf-include-form-auto,将 CSRF token 存放在 cookie 中>> 的方式是将 CSRF token 放在 `meta` 标签内。  
HTML 可能看起来像这样：

.CSRF meta 标签 HTML
[source,html]
----
<html>
<head>
	<meta name="_csrf" content="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
	<meta name="_csrf_header" content="X-CSRF-TOKEN"/>
	<!-- ... -->
</head>
<!-- ... -->
----

一旦 meta 标签包含了 CSRF token，JavaScript 代码就可以读取这些标签并将 token 作为请求头发送出去。  
如果你使用 jQuery，可以用以下代码读取 meta 标签：

.AJAX 发送 CSRF Token
[source,javascript]
----
$(function () {
	var token = $("meta[name='_csrf']").attr("content");
	var header = $("meta[name='_csrf_header']").attr("content");
	$(document).ajaxSend(function(e, xhr, options) {
		xhr.setRequestHeader(header, token);
	});
});
----

以下示例假设你已 <<webflux-csrf-include-subscribe,将 `CsrfToken` 暴露为名为 `_csrf` 的属性>，并通过 Thymeleaf 实现：

.CSRF meta 标签 JSP
[source,html]
----
<html>
<head>
	<meta name="_csrf" th:content="${_csrf.token}"/>
	<!-- 默认请求头名称为 X-CSRF-TOKEN -->
	<meta name="_csrf_header" th:content="${_csrf.headerName}"/>
	<!-- ... -->
</head>
<!-- ... -->
----

[[webflux-csrf-considerations]]
== CSRF 注意事项
在实现针对 CSRF 攻击的防护时，有一些特殊情况需要注意。  
本节讨论这些注意事项在 WebFlux 环境下的具体体现。  
更多通用讨论，请参阅 xref:features/exploits/csrf.adoc#csrf-considerations[CSRF 注意事项]。

[[webflux-considerations-csrf-login]]
=== 登录

你应该 xref:features/exploits/csrf.adoc#csrf-considerations-login[在登录请求中要求 CSRF 保护]，以防止伪造登录尝试。  
Spring Security 的 WebFlux 支持会自动完成此操作。

[[webflux-considerations-csrf-logout]]
=== 登出

你应该 xref:features/exploits/csrf.adoc#csrf-considerations-logout[在登出请求中要求 CSRF 保护]，以防止伪造登出操作。  
默认情况下，Spring Security 的 `LogoutWebFilter` 仅处理 HTTP POST 请求。  
这确保了登出操作需要携带 CSRF token，恶意用户无法强制注销你的用户。

最简单的做法是使用表单进行登出。  
如果你确实想要使用链接，可以通过 JavaScript 让该链接执行 POST 请求（可能通过一个隐藏表单）。  
对于禁用了 JavaScript 的浏览器，你可以选择让链接跳转到一个确认登出页面，该页面再执行 POST 请求。

如果你确实想使用 HTTP GET 方式进行登出，也可以这样做，但请注意，通常不推荐这种做法。  
例如，以下 Java 配置会在 `/logout` URL 接收到任意 HTTP 方法请求时触发登出：

// FIXME: 这里应链接到登出文档

.使用 HTTP GET 登出
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.logout(logout -> logout.requiresLogout(new PathPatternParserServerWebExchangeMatcher("/logout")))
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        logout {
            requiresLogout = PathPatternParserServerWebExchangeMatcher("/logout")
        }
    }
}
----
======

[[webflux-considerations-csrf-timeouts]]
=== CSRF 与会话超时

默认情况下，Spring Security 将 CSRF token 存储在 `WebSession` 中。  
这种设计可能导致会话过期，进而导致没有可用的预期 CSRF token 用于验证。

我们已经讨论了 xref:features/exploits/csrf.adoc#csrf-considerations-login[关于会话超时的一般解决方案]。  
本节专门讨论 WebFlux 支持中 CSRF 超时的具体情况。

你可以更改预期 CSRF token 的存储位置，将其保存在 cookie 中。  
详情请参见 <<webflux-csrf-configure-custom-repository>> 小节。

// FIXME: 我们应在参考文档中添加自定义 AccessDeniedHandler 的章节，并更新之前的链接

// FIXME: 我们需要补充 WebFlux 中 multipart body 与 action 的相关内容。WebFlux 始终启用 multipart 支持。
[[webflux-csrf-considerations-multipart]]
=== 多部分请求（文件上传）
我们已经 xref:features/exploits/csrf.adoc#csrf-considerations-multipart[讨论过] 如何防范对多部分请求（文件上传）的 CSRF 攻击，这会导致一个 https://en.wikipedia.org/wiki/Chicken_or_the_egg[先有鸡还是先有蛋] 的问题。  
本节将讨论如何在 WebFlux 应用程序中将 CSRF token 放在 <<webflux-csrf-considerations-multipart-body,body>> 和 <<webflux-csrf-considerations-multipart-url,url>> 中。

[NOTE]
====
有关在 Spring 中使用多部分表单的更多信息，请参阅 Spring 官方参考文档中的 https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web-reactive.html#webflux-multipart[Multipart Data] 章节。
====

[[webflux-csrf-considerations-multipart-body]]
==== 将 CSRF Token 放在请求体中

我们已经 xref:features/exploits/csrf.adoc#csrf-considerations-multipart[讨论过] 将 CSRF token 放在请求体中的利弊。

在 WebFlux 应用中，你可以通过以下配置实现：

.启用从 multipart/form-data 获取 CSRF token
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.csrf(csrf -> csrf.tokenFromMultipartDataEnabled(true))
	return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
		// ...
        csrf {
            tokenFromMultipartDataEnabled = true
        }
    }
}
----
======

[[webflux-csrf-considerations-multipart-url]]
==== 在 URL 中包含 CSRF Token

我们已经 xref:features/exploits/csrf.adoc#csrf-considerations-multipart[讨论过] 将 CSRF token 放在 URL 中的权衡。  
由于 `CsrfToken` 是作为 `ServerHttpRequest` <<webflux-csrf-include,请求属性> 暴露出来的，我们可以利用这一点创建一个包含 CSRF token 的 `action`。  
以下是一个 Thymeleaf 的示例：

.CSRF Token 在 Action 中
[source,html]
----
<form method="post"
	th:action="@{/upload(${_csrf.parameterName}=${_csrf.token})}"
	enctype="multipart/form-data">
----

[[webflux-csrf-considerations-override-method]]
=== HiddenHttpMethodFilter
我们已经 xref:features/exploits/csrf.adoc#csrf-considerations-override-method[讨论过] 如何重写 HTTP 方法。

在 Spring WebFlux 应用中，通过使用 https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/web/filter/reactive/HiddenHttpMethodFilter.html[`HiddenHttpMethodFilter`] 来实现 HTTP 方法的重写。