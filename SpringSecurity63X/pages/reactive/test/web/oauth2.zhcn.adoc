[[webflux-testing-oauth2]]
= 测试 OAuth 2.0

在涉及 OAuth 2.0 时，xref:reactive/test/method.adoc#test-erms[之前讨论的相同原则仍然适用]：最终，这取决于被测试方法期望 `SecurityContextHolder` 中包含什么内容。

考虑以下控制器示例：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@GetMapping("/endpoint")
public Mono<String> foo(Principal user) {
    return Mono.just(user.getName());
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@GetMapping("/endpoint")
fun foo(user: Principal): Mono<String> {
    return Mono.just(user.name)
}
----
======

该示例与 OAuth2 没有任何特定关联，因此你可以使用 xref:reactive/test/method.adoc#test-erms[`@WithMockUser`] 并且一切正常。

然而，考虑一种情况，你的控制器绑定到 Spring Security 的 OAuth 2.0 支持的某些方面：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@GetMapping("/endpoint")
public Mono<String> foo(@AuthenticationPrincipal OidcUser user) {
    return Mono.just(user.getIdToken().getSubject());
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@GetMapping("/endpoint")
fun foo(@AuthenticationPrincipal user: OidcUser): Mono<String> {
    return Mono.just(user.idToken.subject)
}
----
======

在这种情况下，Spring Security 的测试支持非常有用。

[[webflux-testing-oidc-login]]
== 测试 OIDC 登录

使用 `WebTestClient` 测试 <<webflux-testing-oauth2,上一节>>中显示的方法需要模拟某种授权服务器的授权流程。这是一个艰巨的任务，因此 Spring Security 提供了支持以消除这种样板代码。

例如，我们可以使用 `SecurityMockServerConfigurers#oidcLogin` 方法告诉 Spring Security 包含一个默认的 `OidcUser`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
    .mutateWith(mockOidcLogin()).get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockOidcLogin())
    .get().uri("/endpoint")
    .exchange()
----
======

该行配置了相关的 `MockServerRequest`，其中包含一个简单的 `OidcIdToken`、一个 `OidcUserInfo` 和一组授予的权限（granted authorities）。

具体来说，它包含一个 `sub` 声明设置为 `user` 的 `OidcIdToken`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
assertThat(user.getIdToken().getClaim("sub")).isEqualTo("user");
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
assertThat(user.idToken.getClaim<String>("sub")).isEqualTo("user")
----
======

它还包含一个没有设置任何声明的 `OidcUserInfo`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
assertThat(user.getUserInfo().getClaims()).isEmpty();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
assertThat(user.userInfo.claims).isEmpty()
----
======

它还包括一个只包含一个权限 `SCOPE_read` 的权限集合：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
assertThat(user.getAuthorities()).hasSize(1);
assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
assertThat(user.authorities).hasSize(1)
assertThat(user.authorities).containsExactly(SimpleGrantedAuthority("SCOPE_read"))
----
======

Spring Security 确保 `OidcUser` 实例可供 xref:servlet/integrations/mvc.adoc#mvc-authentication-principal[`@AuthenticationPrincipal` 注解] 使用。

此外，它还将 `OidcUser` 链接到一个简单的 `OAuth2AuthorizedClient` 实例，并将其存入一个模拟的 `ServerOAuth2AuthorizedClientRepository`。如果你的测试<<webflux-testing-oauth2-client,使用了`@RegisteredOAuth2AuthorizedClient`注解>>，这会很有用。

[[webflux-testing-oidc-login-authorities]]
=== 配置权限

在许多情况下，你的方法受到过滤器或方法安全性的保护，需要你的 `Authentication` 具有某些授予的权限才能允许请求。

在这种情况下，你可以使用 `authorities()` 方法提供所需的权限：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
    .mutateWith(mockOidcLogin()
        .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockOidcLogin()
        .authorities(SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange()
----
======

[[webflux-testing-oidc-login-claims]]
=== 配置声明

尽管授予的权限在 Spring Security 中是通用的，但在 OAuth 2.0 的情况下我们也有声明。

例如，假设你有一个 `user_id` 声明来表示系统中的用户 ID。你可以在控制器中按如下方式访问它：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@GetMapping("/endpoint")
public Mono<String> foo(@AuthenticationPrincipal OidcUser oidcUser) {
    String userId = oidcUser.getIdToken().getClaim("user_id");
    // ...
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@GetMapping("/endpoint")
fun foo(@AuthenticationPrincipal oidcUser: OidcUser): Mono<String> {
    val userId = oidcUser.idToken.getClaim<String>("user_id")
    // ...
}
----
======

在这种情况下，你可以使用 `idToken()` 方法指定该声明：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
    .mutateWith(mockOidcLogin()
        .idToken(token -> token.claim("user_id", "1234"))
    )
    .get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockOidcLogin()
        .idToken { token -> token.claim("user_id", "1234") }
    )
    .get().uri("/endpoint").exchange()
----
======

之所以可行，是因为 `OidcUser` 从 `OidcIdToken` 收集其声明。

[[webflux-testing-oidc-login-user]]
=== 额外配置

还有其他一些方法可以进一步配置身份验证，具体取决于你的控制器期望的数据：

* `userInfo(OidcUserInfo.Builder)`：配置 `OidcUserInfo` 实例
* `clientRegistration(ClientRegistration)`：使用给定的 `ClientRegistration` 配置相关的 `OAuth2AuthorizedClient`
* `oidcUser(OidcUser)`：配置完整的 `OidcUser` 实例

最后一个选项在以下情况下很有用：
* 你有自己的 `OidcUser` 实现，或者
* 需要更改名称属性

例如，假设你的授权服务器将主体名称发送到 `user_name` 声明而不是 `sub` 声明。在这种情况下，你可以手动配置一个 `OidcUser`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
OidcUser oidcUser = new DefaultOidcUser(
        AuthorityUtils.createAuthorityList("SCOPE_message:read"),
        OidcIdToken.withTokenValue("id-token").claim("user_name", "foo_user").build(),
        "user_name");

client
    .mutateWith(mockOidcLogin().oidcUser(oidcUser))
    .get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val oidcUser: OidcUser = DefaultOidcUser(
    AuthorityUtils.createAuthorityList("SCOPE_message:read"),
    OidcIdToken.withTokenValue("id-token").claim("user_name", "foo_user").build(),
    "user_name"
)

client
    .mutateWith(mockOidcLogin().oidcUser(oidcUser))
    .get().uri("/endpoint").exchange()
----
======

[[webflux-testing-oauth2-login]]
== 测试 OAuth 2.0 登录

与 <<webflux-testing-oidc-login,测试 OIDC 登录>>类似，测试 OAuth 2.0 登录也面临类似的挑战：模拟授权流程。正因为如此，Spring Security 还为非 OIDC 用例提供了测试支持。

假设我们有一个控制器，它获取作为 `OAuth2User` 的已登录用户：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@GetMapping("/endpoint")
public Mono<String> foo(@AuthenticationPrincipal OAuth2User oauth2User) {
    return Mono.just(oauth2User.getAttribute("sub"));
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@GetMapping("/endpoint")
fun foo(@AuthenticationPrincipal oauth2User: OAuth2User): Mono<String> {
    return Mono.just(oauth2User.getAttribute("sub"))
}
----
======

在这种情况下，我们可以使用 `SecurityMockServerConfigurers#oauth2User` 方法告诉 Spring Security 包含一个默认的 `OAuth2User`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
    .mutateWith(mockOAuth2Login())
    .get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockOAuth2Login())
    .get().uri("/endpoint").exchange()
----
======

上述示例配置了相关的 `MockServerRequest`，其中包含一个简单的属性 `Map` 和一组授予的权限。

具体来说，它包含一个键值对为 `sub`/`user` 的 `Map`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
assertThat((String) user.getAttribute("sub")).isEqualTo("user");
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
assertThat(user.getAttribute<String>("sub")).isEqualTo("user")
----
======

它还包括一个仅包含一个权限 `SCOPE_read` 的权限集合：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
assertThat(user.getAuthorities()).hasSize(1);
assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
assertThat(user.authorities).hasSize(1)
assertThat(user.authorities).containsExactly(SimpleGrantedAuthority("SCOPE_read"))
----
======

Spring Security 执行必要的工作以确保 `OAuth2User` 实例可供 xref:servlet/integrations/mvc.adoc#mvc-authentication-principal[`@AuthenticationPrincipal` 注解] 使用。

此外，它还将该 `OAuth2User` 链接到一个简单的 `OAuth2AuthorizedClient` 实例，并将其存入一个模拟的 `ServerOAuth2AuthorizedClientRepository`。如果你的测试<<webflux-testing-oauth2-client,使用了`@RegisteredOAuth2AuthorizedClient`注解>>，这会很有用。

[[webflux-testing-oauth2-login-authorities]]
=== 配置权限

在许多情况下，你的方法受到过滤器或方法安全性的保护，需要你的 `Authentication` 具有某些授予的权限才能允许请求。

在这种情况下，你可以使用 `authorities()` 方法提供所需的权限：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
    .mutateWith(mockOAuth2Login()
        .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockOAuth2Login()
        .authorities(SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange()
----
======

[[webflux-testing-oauth2-login-claims]]
=== 配置声明

虽然授予的权限在 Spring Security 中很常见，但 OAuth 2.0 也有声明。

例如，假设你有一个 `user_id` 属性来表示系统中的用户 ID。你可以在控制器中按如下方式访问它：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@GetMapping("/endpoint")
public Mono<String> foo(@AuthenticationPrincipal OAuth2User oauth2User) {
    String userId = oauth2User.getAttribute("user_id");
    // ...
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@GetMapping("/endpoint")
fun foo(@AuthenticationPrincipal oauth2User: OAuth2User): Mono<String> {
    val userId = oauth2User.getAttribute<String>("user_id")
    // ...
}
----
======

在这种情况下，你可以使用 `attributes()` 方法指定该属性：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
    .mutateWith(mockOAuth2Login()
        .attributes(attrs -> attrs.put("user_id", "1234"))
    )
    .get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockOAuth2Login()
        .attributes { attrs -> attrs["user_id"] = "1234" }
    )
    .get().uri("/endpoint").exchange()
----
======

[[webflux-testing-oauth2-login-user]]
=== 额外配置

还有其他一些方法可以进一步配置身份验证，具体取决于你的控制器期望的数据：

* `clientRegistration(ClientRegistration)`：使用给定的 `ClientRegistration` 配置相关的 `OAuth2AuthorizedClient`
* `oauth2User(OAuth2User)`：配置完整的 `OAuth2User` 实例

最后一个选项在以下情况下很有用：
* 你有自己的 `OAuth2User` 实现，或者
* 需要更改名称属性

例如，假设你的授权服务器将主体名称发送到 `user_name` 声明而不是 `sub` 声明。在这种情况下，你可以手动配置一个 `OAuth2User`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
OAuth2User oauth2User = new DefaultOAuth2User(
        AuthorityUtils.createAuthorityList("SCOPE_message:read"),
        Collections.singletonMap("user_name", "foo_user"),
        "user_name");

client
    .mutateWith(mockOAuth2Login().oauth2User(oauth2User))
    .get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val oauth2User: OAuth2User = DefaultOAuth2User(
    AuthorityUtils.createAuthorityList("SCOPE_message:read"),
    mapOf(Pair("user_name", "foo_user")),
    "user_name"
)

client
    .mutateWith(mockOAuth2Login().oauth2User(oauth2User))
    .get().uri("/endpoint").exchange()
----
======

[[webflux-testing-oauth2-client]]
== 测试 OAuth 2.0 客户端

无论用户如何进行身份验证，你的请求可能涉及其他令牌和客户端注册。例如，你的控制器可能依赖于客户端凭据授权来获取与用户完全无关的令牌：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@GetMapping("/endpoint")
public Mono<String> foo(@RegisteredOAuth2AuthorizedClient("my-app") OAuth2AuthorizedClient authorizedClient) {
    return this.webClient.get()
        .attributes(oauth2AuthorizedClient(authorizedClient))
        .retrieve()
        .bodyToMono(String.class);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.web.reactive.function.client.bodyToMono

// ...

@GetMapping("/endpoint")
fun foo(@RegisteredOAuth2AuthorizedClient("my-app") authorizedClient: OAuth2AuthorizedClient?): Mono<String> {
    return this.webClient.get()
        .attributes(oauth2AuthorizedClient(authorizedClient))
        .retrieve()
        .bodyToMono()
}
----
======

模拟与授权服务器的此握手过程可能会很繁琐。相反，你可以使用 `SecurityMockServerConfigurers#oauth2Client` 将 `OAuth2AuthorizedClient` 添加到模拟的 `ServerOAuth2AuthorizedClientRepository`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
    .mutateWith(mockOAuth2Client("my-app"))
    .get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockOAuth2Client("my-app"))
    .get().uri("/endpoint").exchange()
----
======

这会创建一个 `OAuth2AuthorizedClient`，它具有一个简单的 `ClientRegistration`、一个 `OAuth2AccessToken` 和一个资源所有者名称。

具体来说，它包括一个客户端 ID 为 `test-client` 和客户端密钥为 `test-secret` 的 `ClientRegistration`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
assertThat(authorizedClient.getClientRegistration().getClientId()).isEqualTo("test-client");
assertThat(authorizedClient.getClientRegistration().getClientSecret()).isEqualTo("test-secret");
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
assertThat(authorizedClient.clientRegistration.clientId).isEqualTo("test-client")
assertThat(authorizedClient.clientRegistration.clientSecret).isEqualTo("test-secret")
----
======

它还包括一个资源所有者名称 `user`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
assertThat(authorizedClient.getPrincipalName()).isEqualTo("user");
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
assertThat(authorizedClient.principalName).isEqualTo("user")
----
======

它还包括一个具有一个作用域 `read` 的 `OAuth2AccessToken`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
assertThat(authorizedClient.getAccessToken().getScopes()).hasSize(1);
assertThat(authorizedClient.getAccessToken().getScopes()).containsExactly("read");
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
assertThat(authorizedClient.accessToken.scopes).hasSize(1)
assertThat(authorizedClient.accessToken.scopes).containsExactly("read")
----
======

然后，你可以在控制器方法中通常使用 `@RegisteredOAuth2AuthorizedClient` 来检索客户端。

[[webflux-testing-oauth2-client-scopes]]
=== 配置作用域

在许多情况下，OAuth 2.0 访问令牌附带一组作用域。考虑以下示例，展示控制器如何检查作用域：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@GetMapping("/endpoint")
public Mono<String> foo(@RegisteredOAuth2AuthorizedClient("my-app") OAuth2AuthorizedClient authorizedClient) {
    Set<String> scopes = authorizedClient.getAccessToken().getScopes();
    if (scopes.contains("message:read")) {
        return this.webClient.get()
            .attributes(oauth2AuthorizedClient(authorizedClient))
            .retrieve()
            .bodyToMono(String.class);
    }
    // ...
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.web.reactive.function.client.bodyToMono

// ...

@GetMapping("/endpoint")
fun foo(@RegisteredOAuth2AuthorizedClient("my-app") authorizedClient: OAuth2AuthorizedClient): Mono<String> {
    val scopes = authorizedClient.accessToken.scopes
    if (scopes.contains("message:read")) {
        return webClient.get()
            .attributes(oauth2AuthorizedClient(authorizedClient))
            .retrieve()
            .bodyToMono()
    }
    // ...
}
----
======

对于检查作用域的控制器，你可以使用 `accessToken()` 方法配置作用域：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
    .mutateWith(mockOAuth2Client("my-app")
        .accessToken(new OAuth2AccessToken(BEARER, "token", null, null, Collections.singleton("message:read")))
    )
    .get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockOAuth2Client("my-app")
        .accessToken(OAuth2AccessToken(BEARER, "token", null, null, setOf("message:read")))
)
.get().uri("/endpoint").exchange()
----
======

[[webflux-testing-oauth2-client-registration]]
=== 额外配置

你还可以使用其他方法根据控制器期望的数据进一步配置身份验证：

* `principalName(String)`；配置资源所有者名称
* `clientRegistration(Consumer<ClientRegistration.Builder>)`：配置相关的 `ClientRegistration`
* `clientRegistration(ClientRegistration)`：配置完整的 `ClientRegistration`

最后一个选项在你想使用真实的 `ClientRegistration` 时非常有用。

例如，假设你想使用在 `application.yml` 中指定的应用程序的一个 `ClientRegistration` 定义。

在这种情况下，你的测试可以自动注入 `ReactiveClientRegistrationRepository` 并查找测试需要的那个：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Autowired
ReactiveClientRegistrationRepository clientRegistrationRepository;

// ...

client
    .mutateWith(mockOAuth2Client()
        .clientRegistration(this.clientRegistrationRepository.findByRegistrationId("facebook").block())
    )
    .get().uri("/exchange").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Autowired
lateinit var clientRegistrationRepository: ReactiveClientRegistrationRepository

// ...

client
    .mutateWith(mockOAuth2Client()
        .clientRegistration(this.clientRegistrationRepository.findByRegistrationId("facebook").block())
    )
    .get().uri("/exchange").exchange()
----
======

[[webflux-testing-jwt]]
== 测试 JWT 身份验证

要在资源服务器上发出授权请求，你需要一个持有者令牌（bearer token）。如果你的资源服务器配置为使用 JWT，则持有者令牌需要根据 JWT 规范进行签名和编码。所有这些都可能相当复杂，特别是当这不是你测试的重点时。

幸运的是，有几种简单的方法可以克服这一困难，让你的测试专注于授权而不是代表持有者令牌。我们在接下来的两个小节中介绍其中两种方法。

=== `mockJwt() WebTestClientConfigurer`

第一种方法是使用 `WebTestClientConfigurer`。最简单的方法是使用 `SecurityMockServerConfigurers#mockJwt` 方法，如下所示：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
    .mutateWith(mockJwt()).get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockJwt()).get().uri("/endpoint").exchange()
----
======

此示例创建一个模拟的 `Jwt` 并通过任何身份验证 API 传递它，以便你的授权机制可以对其进行验证。

默认情况下，它创建的 `JWT` 具有以下特征：

[source,json]
----
{
  "headers" : { "alg" : "none" },
  "claims" : {
    "sub" : "user",
    "scope" : "read"
  }
}
----

如果对此结果 `Jwt` 进行测试，将以以下方式通过：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
assertThat(jwt.getTokenValue()).isEqualTo("token");
assertThat(jwt.getHeaders().get("alg")).isEqualTo("none");
assertThat(jwt.getSubject()).isEqualTo("sub");
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
assertThat(jwt.tokenValue).isEqualTo("token")
assertThat(jwt.headers["alg"]).isEqualTo("none")
assertThat(jwt.subject).isEqualTo("sub")
----
======

请注意，你可以配置这些值。

你还可以使用相应的方法配置任何头部或声明：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
	.mutateWith(mockJwt().jwt(jwt -> jwt.header("kid", "one")
		.claim("iss", "https://idp.example.org")))
	.get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockJwt().jwt { jwt -> jwt.header("kid", "one")
        .claim("iss", "https://idp.example.org")
    })
    .get().uri("/endpoint").exchange()
----
======

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
	.mutateWith(mockJwt().jwt(jwt -> jwt.claims(claims -> claims.remove("scope"))))
	.get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockJwt().jwt { jwt ->
        jwt.claims { claims -> claims.remove("scope") }
    })
    .get().uri("/endpoint").exchange()
----
======

`scope` 和 `scp` 声明在这里的处理方式与正常持有者令牌请求中的处理方式相同。但是，只需提供测试所需的 `GrantedAuthority` 实例列表即可覆盖此行为：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
	.mutateWith(mockJwt().authorities(new SimpleGrantedAuthority("SCOPE_messages")))
	.get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockJwt().authorities(SimpleGrantedAuthority("SCOPE_messages")))
    .get().uri("/endpoint").exchange()
----
======

或者，如果你有一个自定义的 `Jwt` 到 `Collection<GrantedAuthority>` 的转换器，也可以使用它来派生权限：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
	.mutateWith(mockJwt().authorities(new MyConverter()))
	.get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockJwt().authorities(MyConverter()))
    .get().uri("/endpoint").exchange()
----
======

你还可以指定一个完整的 `Jwt`，为此 `{security-api-url}org/springframework/security/oauth2/jwt/Jwt.Builder.html[Jwt.Builder]` 非常方便：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .claim("scope", "read")
    .build();

client
	.mutateWith(mockJwt().jwt(jwt))
	.get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val jwt: Jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .claim("scope", "read")
    .build()

client
    .mutateWith(mockJwt().jwt(jwt))
    .get().uri("/endpoint").exchange()
----
======

=== `authentication()` 和 `WebTestClientConfigurer`

第二种方法是使用 `authentication()` `Mutator`。你可以实例化自己的 `JwtAuthenticationToken` 并在测试中提供它：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .build();
Collection<GrantedAuthority> authorities = AuthorityUtils.createAuthorityList("SCOPE_read");
JwtAuthenticationToken token = new JwtAuthenticationToken(jwt, authorities);

client
	.mutateWith(mockAuthentication(token))
	.get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .build()
val authorities: Collection<GrantedAuthority> = AuthorityUtils.createAuthorityList("SCOPE_read")
val token = JwtAuthenticationToken(jwt, authorities)

client
    .mutateWith(mockAuthentication<JwtMutator>(token))
    .get().uri("/endpoint").exchange()
----
======

请注意，除了这些方法之外，你还可以使用 `@MockBean` 注解来模拟 `ReactiveJwtDecoder` bean 本身。

[[webflux-testing-opaque-token]]
== 测试不透明令牌身份验证

类似于 <<webflux-testing-jwt,JWT>>，不透明令牌需要一个授权服务器来验证其有效性，这使得测试更加困难。为了帮助解决这个问题，Spring Security 为不透明令牌提供了测试支持。

假设你有一个控制器，它将身份验证作为 `BearerTokenAuthentication` 获取：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@GetMapping("/endpoint")
public Mono<String> foo(BearerTokenAuthentication authentication) {
    return Mono.just((String) authentication.getTokenAttributes().get("sub"));
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@GetMapping("/endpoint")
fun foo(authentication: BearerTokenAuthentication): Mono<String?> {
    return Mono.just(authentication.tokenAttributes["sub"] as String?)
}
----
======

在这种情况下，你可以使用 `SecurityMockServerConfigurers#opaqueToken` 方法告诉 Spring Security 包含一个默认的 `BearerTokenAuthentication`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
    .mutateWith(mockOpaqueToken())
    .get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockOpaqueToken())
    .get().uri("/endpoint").exchange()
----
======

此示例配置了相关的 `MockHttpServletRequest`，其中包含一个 `BearerTokenAuthentication`，该认证包含一个简单的 `OAuth2AuthenticatedPrincipal`、一个属性 `Map` 和一组授予的权限。

具体来说，它包含一个键值对为 `sub`/`user` 的 `Map`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
assertThat((String) token.getTokenAttributes().get("sub")).isEqualTo("user");
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
assertThat(token.tokenAttributes["sub"] as String?).isEqualTo("user")
----
======

它还包括一个仅包含一个权限 `SCOPE_read` 的权限集合：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
assertThat(token.getAuthorities()).hasSize(1);
assertThat(token.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
assertThat(token.authorities).hasSize(1)
assertThat(token.authorities).containsExactly(SimpleGrantedAuthority("SCOPE_read"))
----
======

Spring Security 执行必要的工作以确保 `BearerTokenAuthentication` 实例可供你的控制器方法使用。

[[webflux-testing-opaque-token-authorities]]
=== 配置权限

在许多情况下，你的方法受到过滤器或方法安全性的保护，需要你的 `Authentication` 具有某些授予的权限才能允许请求。

在这种情况下，你可以使用 `authorities()` 方法提供所需的权限：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
    .mutateWith(mockOpaqueToken()
        .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockOpaqueToken()
        .authorities(SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange()
----
======

[[webflux-testing-opaque-token-attributes]]
=== 配置声明

尽管授予的权限在 Spring Security 中很常见，但在 OAuth 2.0 的情况下我们也有属性。

例如，假设你有一个 `user_id` 属性来表示系统中的用户 ID。你可以在控制器中按如下方式访问它：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@GetMapping("/endpoint")
public Mono<String> foo(BearerTokenAuthentication authentication) {
    String userId = (String) authentication.getTokenAttributes().get("user_id");
    // ...
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@GetMapping("/endpoint")
fun foo(authentication: BearerTokenAuthentication): Mono<String?> {
    val userId = authentication.tokenAttributes["user_id"] as String?
    // ...
}
----
======

在这种情况下，你可以使用 `attributes()` 方法指定该属性：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
client
    .mutateWith(mockOpaqueToken()
        .attributes(attrs -> attrs.put("user_id", "1234"))
    )
    .get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
client
    .mutateWith(mockOpaqueToken()
        .attributes { attrs -> attrs["user_id"] = "1234" }
    )
    .get().uri("/endpoint").exchange()
----
======

[[webflux-testing-opaque-token-principal]]
=== 额外配置

你还可以使用其他方法根据控制器期望的数据进一步配置身份验证。

其中一个方法是 `principal(OAuth2AuthenticatedPrincipal)`，可用于配置底层 `BearerTokenAuthentication` 的完整 `OAuth2AuthenticatedPrincipal` 实例。

它在以下情况下很有用：
* 你有自己的 `OAuth2AuthenticatedPrincipal` 实现，或者
* 想要指定不同的主体名称

例如，假设你的授权服务器将主体名称发送到 `user_name` 属性而不是 `sub` 属性。在这种情况下，你可以手动配置一个 `OAuth2AuthenticatedPrincipal`：

[tabs]
======
Java::
+
[source,java,role="primary"]
----
Map<String, Object> attributes = Collections.singletonMap("user_name", "foo_user");
OAuth2AuthenticatedPrincipal principal = new DefaultOAuth2AuthenticatedPrincipal(
        (String) attributes.get("user_name"),
        attributes,
        AuthorityUtils.createAuthorityList("SCOPE_message:read"));

client
    .mutateWith(mockOpaqueToken().principal(principal))
    .get().uri("/endpoint").exchange();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val attributes: Map<String, Any> = mapOf(Pair("user_name", "foo_user"))
val principal: OAuth2AuthenticatedPrincipal = DefaultOAuth2AuthenticatedPrincipal(
    attributes["user_name"] as String?,
    attributes,
    AuthorityUtils.createAuthorityList("SCOPE_message:read")
)

client
    .mutateWith(mockOpaqueToken().principal(principal))
    .get().uri("/endpoint").exchange()
----
======

请注意，作为使用 `mockOpaqueToken()` 测试支持的替代方案，你也可以使用 `@MockBean` 注解来模拟 `OpaqueTokenIntrospector` bean 本身。