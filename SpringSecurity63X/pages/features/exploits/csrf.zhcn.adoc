// FIXME: 添加对 Servlet 和 WebFlux 支持的链接

[[csrf]]
= 跨站请求伪造 (CSRF)

Spring 提供了全面的支持，用于防范 https://en.wikipedia.org/wiki/Cross-site_request_forgery[跨站请求伪造（Cross Site Request Forgery, CSRF）]攻击。在接下来的部分中，我们将探讨：

* <<csrf-explained>>
* <<csrf-protection>>
* <<csrf-considerations>>

// FIXME: 添加 WebFlux 的 CSRF 文档（下面的链接已失效）
[NOTE]
====
本文档的这一部分讨论的是 CSRF 防护的一般主题。有关基于 xref:servlet/exploits/csrf.adoc#servlet-csrf[servlet] 和 xref:reactive/exploits/csrf.adoc#webflux-csrf[WebFlux] 应用程序的 CSRF 防护具体信息，请参见相关章节。
====

[[csrf-explained]]
== 什么是 CSRF 攻击？
理解 CSRF 攻击的最佳方式是通过一个具体的例子。

假设你的银行网站提供了一个表单，允许将当前登录用户账户中的资金转账到另一个银行账户。例如，该转账表单可能如下所示：

.转账表单
[source,html]
----
<form method="post"
	action="/transfer">
<input type="text"
	name="amount"/>
<input type="text"
	name="routingNumber"/>
<input type="text"
	name="account"/>
<input type="submit"
	value="Transfer"/>
</form>
----

对应的 HTTP 请求可能如下：

.转账 HTTP 请求
[source]
----
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876
----

现在假设你已经登录了银行网站，然后在未退出登录的情况下访问了一个恶意网站。该恶意网站包含一个 HTML 页面，其表单如下：

.恶意转账表单
[source,html]
----
<form method="post"
	action="https://bank.example.com/transfer">
<input type="hidden"
	name="amount"
	value="100.00"/>
<input type="hidden"
	name="routingNumber"
	value="evilsRoutingNumber"/>
<input type="hidden"
	name="account"
	value="evilsAccountNumber"/>
<input type="submit"
	value="Win Money!"/>
</form>
----

你喜欢赢钱，于是点击了提交按钮。在这个过程中，你不经意间向恶意用户转账了 100 美元。之所以会发生这种情况，是因为虽然恶意网站无法读取你的 Cookie，但与你的银行账户关联的 Cookie 仍会随请求一同发送。

更糟糕的是，整个过程可以通过 JavaScript 自动化完成。这意味着你甚至不需要点击按钮。此外，这种攻击也可能发生在访问一个遭受 https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)[XSS 攻击]的正常网站时。那么我们该如何保护用户免受此类攻击呢？

[[csrf-protection]]
== 如何防范 CSRF 攻击
CSRF 攻击之所以可能发生，是因为来自受害者网站的请求和来自攻击者网站的请求完全相同。这意味着我们无法区分并拒绝来自恶意网站的请求，同时只允许来自银行网站的请求。为了防止 CSRF 攻击，我们需要确保请求中包含某些恶意网站无法提供的内容，从而能够区分这两个请求。

Spring 提供了两种机制来防御 CSRF 攻击：

* 使用 <<Synchronizer Token Pattern>>（同步器令牌模式）
* 在会话 Cookie 上指定 <<SameSite Attribute>>（SameSite 属性）

[NOTE]
====
这两种防护措施都要求 <<csrf-protection-read-only,安全方法必须为只读>>。
====

[[csrf-protection-read-only]]
=== 安全方法必须为只读

要使 <<csrf-protection,任一 CSRF 防护机制> 起作用，应用程序必须确保 https://tools.ietf.org/html/rfc7231#section-4.2.1["安全" HTTP 方法是只读的]。这意味着使用 HTTP `GET`、`HEAD`、`OPTIONS` 和 `TRACE` 方法的请求不应更改应用程序的状态。

[[csrf-protection-stp]]
=== 同步器令牌模式（Synchronizer Token Pattern）
防范 CSRF 攻击最主要且最全面的方法是使用 https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern[同步器令牌模式]。该方案要求每个 HTTP 请求除了会话 Cookie 外，还必须包含一个称为 CSRF 令牌的安全随机生成值。

当提交 HTTP 请求时，服务器必须查找预期的 CSRF 令牌，并将其与实际请求中的 CSRF 令牌进行比较。如果两者不匹配，则应拒绝该请求。

此机制的关键在于：实际的 CSRF 令牌必须位于浏览器不会自动包含的 HTTP 请求部分中。例如，要求将 CSRF 令牌作为 HTTP 参数或 HTTP 头部传递可以有效防止 CSRF 攻击。但如果要求将 CSRF 令牌放在 Cookie 中则无效，因为浏览器会自动包含 Cookie。

我们可以放宽要求，仅对那些更新应用状态的 HTTP 请求强制验证 CSRF 令牌。为此，我们的应用程序必须确保 <<csrf-protection-read-only,安全的 HTTP 方法是只读的>>。这能提升用户体验，因为我们希望允许外部站点链接到我们的网站。此外，我们也不希望在 HTTP GET 请求中包含随机令牌，否则可能导致令牌泄露。

让我们看看在使用同步器令牌模式后，<<csrf-explained,前面的例子>>会发生怎样的变化。假设实际的 CSRF 令牌必须出现在名为 `_csrf` 的 HTTP 参数中。我们应用程序的转账表单将变为：

.同步器令牌表单
[source,html]
----
<form method="post"
	action="/transfer">
<input type="hidden"
	name="_csrf"
	value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
<input type="text"
	name="amount"/>
<input type="text"
	name="routingNumber"/>
<input type="hidden"
	name="account"/>
<input type="submit"
	value="Transfer"/>
</form>
----

现在的表单包含了一个隐藏输入字段，其中包含了 CSRF 令牌的值。由于同源策略的存在，外部网站无法读取该 CSRF 令牌，因此无法获取其内容。

对应的转账 HTTP 请求将如下所示：

.同步器令牌请求
[source]
----
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876&_csrf=4bfd1575-3ad1-4d21-96c7-4ef2d9f86721
----


你会注意到，HTTP 请求现在包含了一个名为 `_csrf` 的参数，其值是一个安全的随机数。恶意网站无法提供正确的 `_csrf` 参数值（该值必须显式地在恶意网站上提供），因此当服务器比较实际与预期的 CSRF 令牌时，转账操作将会失败。

[[csrf-protection-ssa]]
=== SameSite 属性
一种新兴的防范 <<csrf,CSRF 攻击>>的方法是在 Cookie 上设置 https://tools.ietf.org/html/draft-west-first-party-cookies[SameSite 属性]。服务器可以在设置 Cookie 时指定 `SameSite` 属性，以表明该 Cookie 不应在来自外部站点的请求中被发送。

[NOTE]
====
Spring Security 并不直接控制会话 Cookie 的创建，因此它本身不提供对 SameSite 属性的支持。https://spring.io/projects/spring-session[Spring Session] 为基于 Servlet 的应用程序提供了对 `SameSite` 属性的支持。Spring Framework 的 https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/server/session/CookieWebSessionIdResolver.html[`CookieWebSessionIdResolver`] 为基于 WebFlux 的应用程序提供了开箱即用的 `SameSite` 属性支持。
====

一个设置了 `SameSite` 属性的 HTTP 响应头示例如下：

.SameSite HTTP 响应
[source]
----
Set-Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly; SameSite=Lax
----

`SameSite` 属性的有效值包括：

* `Strict`：指定后，只有当请求来自 https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-2.1[同站] 时才包含该 Cookie；否则不会在 HTTP 请求中包含该 Cookie。
* `Lax`：指定后，当请求来自 https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-2.1[同站] 或来自顶级导航且 <<Safe Methods Must be Read-only,方法为只读>> 时，才会发送 Cookie；其他情况下不会包含该 Cookie。

考虑如何利用 `SameSite` 属性来保护 <<csrf-explained,前面的例子>>。银行应用可以通过在会话 Cookie 上设置 `SameSite` 属性来防范 CSRF 攻击。

一旦我们在会话 Cookie 上设置了 `SameSite` 属性，浏览器将继续在来自银行网站的请求中发送 `JSESSIONID` Cookie。然而，当请求来自恶意网站的转账请求时，浏览器将不再发送 `JSESSIONID` Cookie。由于此时会话信息不再存在于来自恶意网站的转账请求中，因此应用程序就得到了 CSRF 攻击的保护。

使用 `SameSite` 属性防范 CSRF 攻击时，有一些重要的 https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-5[注意事项] 需要注意。

将 `SameSite` 属性设置为 `Strict` 可提供更强的防御，但也可能给用户带来困扰。例如，某用户一直登录着托管在 https://social.example.com 的社交媒体网站。该用户收到一封来自 https://email.example.org 的邮件，其中包含指向社交媒体网站的链接。如果用户点击该链接，他们理所当然期望自己仍处于登录状态。但如果 `SameSite` 属性设为 `Strict`，则 Cookie 将不会被发送，导致用户需要重新登录。

[NOTE]
====
我们可以通过实现 https://github.com/spring-projects/spring-security/issues/7537[gh-7537] 来改进 `SameSite` 防护在 CSRF 防御中的保护性和可用性。
====

另一个明显的考虑因素是：要使 `SameSite` 属性发挥作用，用户的浏览器必须支持该属性。大多数现代浏览器都 https://developer.mozilla.org/en-US/docs/Web/HTTP/headers/Set-Cookie#Browser_compatibility[支持 SameSite 属性]，但仍在使用的旧版浏览器可能不支持。

因此，我们通常建议将 `SameSite` 属性作为纵深防御手段，而不是唯一的 CSRF 防护措施。

[[csrf-when]]
== 何时使用 CSRF 防护
你应该在什么时候使用 CSRF 防护？我们的建议是：对于任何可能由普通用户通过浏览器处理的请求，都应该启用 CSRF 防护。如果你正在构建的服务仅由非浏览器客户端使用，那么你很可能希望禁用 CSRF 防护。

[[csrf-when-json]]
=== CSRF 防护与 JSON 请求
一个常见的问题是：“我是否需要保护 JavaScript 发出的 JSON 请求？”  
简短的回答是：视情况而定。但你必须非常小心，因为确实存在影响 JSON 请求的 CSRF 漏洞。例如，恶意用户可以利用以下表单发起 http://blog.opensecurityresearch.com/2012/02/json-csrf-with-parameter-padding.html[针对 JSON 的 CSRF 攻击]：

.使用 JSON 的 CSRF 表单
[source,html]
----
<form action="https://bank.example.com/transfer" method="post" enctype="text/plain">
	<input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'>
	<input type="submit"
		value="Win Money!"/>
</form>
----


这会产生如下 JSON 结构：

.使用 JSON 的 CSRF 请求
[source,javascript]
----
{ "amount": 100,
"routingNumber": "evilsRoutingNumber",
"account": "evilsAccountNumber",
"ignore_me": "=test"
}
----

如果应用程序没有验证 `Content-Type` 头部，则容易受到此类攻击。根据具体配置，即使 Spring MVC 应用程序验证了 Content-Type，也仍可能通过将 URL 后缀改为 `.json` 来被利用，如下所示：

.针对 Spring MVC 的 JSON CSRF 表单
[source,html]
----
<form action="https://bank.example.com/transfer.json" method="post" enctype="text/plain">
	<input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'>
	<input type="submit"
		value="Win Money!"/>
</form>
----

[[csrf-when-stateless]]
=== CSRF 与无状态浏览器应用
如果我的应用是无状态的怎么办？这并不意味着你就一定安全。事实上，如果用户无需在浏览器中执行任何操作即可完成某个请求，那么他们仍然可能面临 CSRF 攻击的风险。

例如，考虑一个使用自定义 Cookie 进行身份验证的应用程序，该 Cookie 包含所有认证所需的状态信息（而不是 JSESSIONID）。当发生 CSRF 攻击时，这个自定义 Cookie 会像之前的 JSESSIONID 一样随请求一起发送。这类应用程序仍然容易受到 CSRF 攻击。

使用基本认证（Basic Authentication）的应用程序也同样容易受到 CSRF 攻击。因为浏览器会自动在所有请求中包含用户名和密码，就像之前自动发送 JSESSIONID Cookie 一样。

[[csrf-considerations]]
== CSRF 注意事项
在实现针对 CSRF 攻击的防护时，有几个特殊注意事项需要考虑。

// FIXME: 记录在登录时轮换 CSRF 令牌以避免固定攻击

[[csrf-considerations-login]]
=== 登录

为了防止 https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests[伪造登录请求]，登录 HTTP 请求应受到 CSRF 防护。防止伪造登录请求是必要的，否则恶意用户可能会读取受害者的敏感信息。攻击步骤如下：

. 恶意用户使用自己的凭据发起 CSRF 登录。
  此时受害者会被认证为恶意用户。
. 接着，恶意用户诱导受害者访问已被篡改的网站并输入敏感信息。
. 这些信息将被关联到恶意用户的账户，从而使恶意用户可以使用自己的凭据登录并查看受害者的敏感数据。

确保登录 HTTP 请求受到 CSRF 防护的一个潜在问题是：用户可能会遇到会话超时，导致请求被拒绝。会话超时会让用户感到意外，因为他们并不认为登录需要现有会话。更多信息请参考 <<csrf-considerations-timeouts>>。

[[csrf-considerations-logout]]
=== 登出

为了防止伪造登出请求，登出 HTTP 请求也应受到 CSRF 防护。防止伪造登出请求是为了避免恶意用户读取受害者的敏感信息。有关攻击细节，请参阅 https://labs.detectify.com/2017/03/15/loginlogout-csrf-time-to-reconsider/[这篇博客文章]。

确保登出 HTTP 请求受到 CSRF 防护的一个潜在问题是：用户可能会遇到会话超时，导致请求被拒绝。这对用户来说是意外的，因为他们不认为登出需要已有会话。更多信息请参见 <<csrf-considerations-timeouts>>。

[[csrf-considerations-timeouts]]
=== CSRF 与会话超时
通常情况下，预期的 CSRF 令牌是存储在会话中的。这意味着一旦会话过期，服务器就找不到预期的 CSRF 令牌，从而拒绝该 HTTP 请求。解决超时问题有多种选择（每种都有其权衡）：

* 缓解超时的最佳方式是使用 JavaScript 在表单提交时请求一个新的 CSRF 令牌。然后用新令牌更新表单并提交。
* 另一种选择是使用 JavaScript 提示用户其会话即将过期。用户可点击按钮继续并刷新会话。
* 最后一种选择是将预期的 CSRF 令牌存储在 Cookie 中。这样可以让 CSRF 令牌的生命周期超过会话。
+
有人可能会问：为什么默认不把预期的 CSRF 令牌存入 Cookie？这是因为已知存在某些漏洞，其他域可以设置头部（例如用于指定 Cookie）。这也是 Ruby on Rails https://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails/[不再跳过带有 X-Requested-With 头部的 CSRF 检查]的原因。详情请见 https://web.archive.org/web/20210221120355/https://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html[webappsec.org 上的讨论帖]。另一个缺点是，通过移除状态（即超时机制），你失去了在令牌泄露时强制使其失效的能力。

// FIXME: 文档中需说明长时间填写的表单超时问题。我们不希望自动重放该请求，因为它可能导致攻击。

[[csrf-considerations-multipart]]
=== Multipart（文件上传）

防范 multipart 请求（文件上传）的 CSRF 攻击会导致一个 https://en.wikipedia.org/wiki/Chicken_or_the_egg[先有鸡还是先有蛋]的问题。为了防止 CSRF 攻击，必须先读取 HTTP 请求体以获取实际的 CSRF 令牌。但读取请求体意味着文件已经被上传，也就是说外部网站可以上传文件。

有两种方式可在 `multipart/form-data` 请求中使用 CSRF 防护：

* <<csrf-considerations-multipart-body,将 CSRF 令牌放在请求体中>>
* <<csrf-considerations-multipart-url,将 CSRF 令牌放在 URL 中>>

每种方式都有其优缺点。

[NOTE]
====
在将 Spring Security 的 CSRF 防护与 multipart 文件上传集成之前，你应该首先确保在没有 CSRF 防护的情况下也能成功上传。更多关于 Spring 中 multipart 表单的使用信息，请参阅 Spring 参考文档的 https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-multipart[1.1.11. Multipart Resolver] 章节以及 https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html[`MultipartFilter` Javadoc]。
====

[[csrf-considerations-multipart-body]]
==== 将 CSRF 令牌放在请求体中
第一种选择是将实际的 CSRF 令牌包含在请求体中。通过将 CSRF 令牌放入请求体，可以在执行授权前读取请求体。这意味着任何人都可以在你的服务器上放置临时文件。但只有经过授权的用户才能提交被应用程序处理的文件。通常这是推荐的做法，因为临时文件上传对大多数服务器的影响微乎其微。

[[csrf-considerations-multipart-url]]
==== 将 CSRF 令牌包含在 URL 中
如果不能接受未经授权的用户上传临时文件，则另一种选择是将预期的 CSRF 令牌作为查询参数添加到表单的 action 属性的 URL 中。这种方法的缺点是查询参数可能被泄露。更普遍的看法是，最佳实践是将敏感数据放在请求体或头部中，以确保不会泄露。更多信息可参考 https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3[RFC 2616 第 15.1.3 节：URI 中敏感信息的编码]。

[[csrf-considerations-override-method]]
==== HiddenHttpMethodFilter
一些应用程序可以使用表单参数来覆盖 HTTP 方法。例如，以下表单可以将 HTTP 方法视为 `delete` 而不是 `post`。

.CSRF 隐藏 HTTP 方法表单
[source,html]
----
<form action="/process"
	method="post">
	<!-- ... -->
	<input type="hidden"
		name="_method"
		value="delete"/>
</form>
----


HTTP 方法的覆盖发生在过滤器中。该过滤器必须置于 Spring Security 支持之前。注意，这种覆盖仅发生在 `post` 请求上，因此实际上不太可能引起严重问题。不过，最好还是确保它位于 Spring Security 过滤器之前。