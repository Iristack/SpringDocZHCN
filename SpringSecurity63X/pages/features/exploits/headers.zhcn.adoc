[[headers]]
= 安全HTTP响应头

[NOTE]
====
本文档部分讨论了安全HTTP响应头的一般主题。
有关基于 xref:servlet/exploits/headers.adoc#servlet-headers[servlet] 和 xref:reactive/exploits/headers.adoc#webflux-headers[WebFlux] 的应用程序中安全HTTP响应头的详细信息，请参阅相关章节。
====

你可以通过多种方式使用 https://owasp.org/www-project-secure-headers/#div-headers[HTTP响应头] 来提升Web应用程序的安全性。  
本节专门介绍Spring Security明确支持的各种HTTP响应头。如有需要，你还可以配置Spring Security以提供<<headers-custom,自定义头>>。

[[headers-default]]
== 默认安全头

[NOTE]
====
请参阅相关章节，了解如何为基于 xref:servlet/exploits/headers.adoc#servlet-headers-default[servlet] 和 xref:reactive/exploits/headers.adoc#webflux-headers-default[webflux] 的应用程序自定义默认设置。
====

Spring Security 提供了一组默认的安全相关HTTP响应头，以确保默认的安全性。

Spring Security 的默认行为是包含以下响应头：

.默认安全HTTP响应头
[source,http]
----
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 0
----

[NOTE]
====
Strict-Transport-Security 仅在HTTPS请求时添加
====

如果默认设置不满足你的需求，你可以轻松地从这些默认值中删除、修改或添加头信息。有关每个头的更多细节，请参见对应章节：

* <<headers-cache-control,缓存控制>>
* <<headers-content-type-options,内容类型选项>>
* <<headers-hsts,HTTP严格传输安全（HSTS）>>
* <<headers-frame-options,X-Frame-Options>>
* <<headers-xss-protection,X-XSS-Protection>>

[[headers-cache-control]]
== 缓存控制

[NOTE]
====
请参阅相关章节，了解如何为基于 xref:servlet/exploits/headers.adoc#servlet-headers-cache-control[servlet] 和 xref:reactive/exploits/headers.adoc#webflux-headers-cache-control[webflux] 的应用程序自定义默认设置。
====

Spring Security 默认禁用缓存，以保护用户的内容。

例如，当用户登录查看敏感信息并随后登出时，我们不希望恶意用户能够通过点击“后退”按钮再次查看该敏感信息。因此，默认发送的缓存控制头如下：

.默认缓存控制HTTP响应头
[source]
----
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
----

为了默认更安全，Spring Security 默认添加这些头。然而，如果你的应用程序已提供自己的缓存控制头，Spring Security 将自动让位。这使得应用程序可以确保静态资源（如CSS和JavaScript文件）仍可被缓存。

[[headers-content-type-options]]
== 内容类型选项

[NOTE]
====
请参阅相关章节，了解如何为基于 xref:servlet/exploits/headers.adoc#servlet-headers-content-type-options[servlet] 和 xref:reactive/exploits/headers.adoc#webflux-headers-content-type-options[webflux] 的应用程序自定义默认设置。
====

历史上，浏览器（包括Internet Explorer）会使用 https://en.wikipedia.org/wiki/Content_sniffing[内容嗅探] 技术来猜测请求的内容类型。这种方式允许浏览器在未指定内容类型的资源上推测其类型，从而改善用户体验。例如，当浏览器遇到一个未指定内容类型的JavaScript文件时，它能推断出类型并执行。

[NOTE]
====
当允许上传内容时，还需要做许多其他工作（例如仅在独立域名下显示文档、确保设置了 Content-Type 头、对文档进行清理等）。但这些措施超出了Spring Security提供的范围。需要特别指出的是，在禁用内容嗅探时，你必须显式指定内容类型，否则功能将无法正常工作。
====

内容嗅探的问题在于，它允许恶意用户使用多用途文件（即同时符合多种内容类型的文件）发起跨站脚本（XSS）攻击。例如，某些网站可能允许用户提交有效的PostScript文档并查看。而恶意用户可能创建一个 http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf[既是PostScript又是有效JavaScript的文件]，并借此实施XSS攻击。

默认情况下，Spring Security 通过向HTTP响应添加以下头来禁用内容嗅探：

.nosniff HTTP响应头
[source,http]
----
X-Content-Type-Options: nosniff
----

[[headers-hsts]]
== HTTP严格传输安全（HSTS）

[NOTE]
====
请参阅相关章节，了解如何为基于 xref:servlet/exploits/headers.adoc#servlet-headers-hsts[servlet] 和 xref:reactive/exploits/headers.adoc#webflux-headers-hsts[webflux] 的应用程序自定义默认设置。
====

当你输入银行网站地址时，你是输入 `mybank.example.com` 还是 `\https://mybank.example.com`？如果你省略了 `https` 协议，就可能面临 https://en.wikipedia.org/wiki/Man-in-the-middle_attack[中间人攻击] 的风险。即使网站会重定向到 `\https://mybank.example.com`，恶意用户仍可能拦截初始的HTTP请求并篡改响应（例如重定向到 `\https://mibank.example.com` 并窃取凭证）。

许多用户都会省略 `https` 协议，因此 https://tools.ietf.org/html/rfc6797[HTTP严格传输安全（HSTS）] 被提出。一旦 `mybank.example.com` 被标记为 https://tools.ietf.org/html/rfc6797#section-5.1[HSTS主机]，浏览器就能提前知道所有对该域名的请求都应解释为 `\https://mybank.example.com`，这大大降低了中间人攻击的可能性。

[NOTE]
====
根据 https://tools.ietf.org/html/rfc6797#section-7.2[RFC6797] 规范，HSTS头仅注入HTTPS响应中。为了让浏览器认可该头，浏览器必须首先信任用于建立连接的SSL证书所对应的CA（不仅仅是SSL证书本身）。
====

一种将站点标记为HSTS主机的方式是将主机预加载到浏览器中。另一种方式是在响应中添加 `Strict-Transport-Security` 头。例如，Spring Security 的默认行为是添加以下头，指示浏览器在未来一年内（非闰年共31536000秒）将该域名视为HSTS主机：

.Strict Transport Security HTTP响应头
[source]
----
Strict-Transport-Security: max-age=31536000 ; includeSubDomains ; preload
----

可选的 `includeSubDomains` 指令指示浏览器子域名（如 `secure.mybank.example.com`）也应被视为HSTS域。

可选的 `preload` 指令指示浏览器应将该域名预加载为HSTS域。有关HSTS预加载的更多详情，请参见 https://hstspreload.org。

[[headers-hpkp]]
== HTTP公钥固定（HPKP）

[NOTE]
====
为保持被动兼容，Spring Security 仍为 xref:servlet/exploits/headers.adoc#servlet-headers-hpkp[servlet环境提供HPKP支持]。但由于前述原因，Spring Security团队不再推荐使用HPKP。
====

https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning[HTTP公钥固定（HPKP）] 是一种机制，用于告知Web客户端应使用哪个公钥与特定Web服务器通信，以防止使用伪造证书的中间人（MITM）攻击。正确使用HPKP可以在一定程度上增强对证书被冒用的防护。然而，由于HPKP的复杂性，许多专家已不再推荐使用，并且 https://www.chromestatus.com/feature/5903385005916160[Chrome甚至已移除支持]。

[[headers-hpkp-deprecated]]
有关为何不再推荐使用HPKP的更多细节，请阅读：
https://blog.qualys.com/ssllabs/2016/09/06/is-http-public-key-pinning-dead[Is HTTP Public Key Pinning Dead?] 和
https://scotthelme.co.uk/im-giving-up-on-hpkp/[I'm giving up on HPKP]。

[[headers-frame-options]]
== X-Frame-Options

[NOTE]
====
请参阅相关章节，了解如何为基于 xref:servlet/exploits/headers.adoc#servlet-headers-frame-options[servlet] 和 xref:reactive/exploits/headers.adoc#webflux-headers-frame-options[webflux] 的应用程序自定义默认设置。
====

允许你的网站被嵌入到框架（frame）中可能会带来安全问题。例如，通过巧妙的CSS样式，用户可能被诱骗点击他们本不想点击的内容。比如，已登录银行账户的用户可能误点一个按钮，从而授权他人访问其账户。这类攻击被称为 https://en.wikipedia.org/wiki/Clickjacking[点击劫持（Clickjacking）]。

[NOTE]
====
应对点击劫持的另一种现代方法是使用 <<headers-csp>>。
====

有多种方式可以缓解点击劫持攻击。例如，为保护旧版浏览器免受点击劫持，可以使用 https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet#Best-for-now_Legacy_Browser_Frame_Breaking_Script[防框架嵌套代码]。虽然这种方法并不完美，但对于旧版浏览器来说已是最佳选择。

更现代的方法是使用 https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options[X-Frame-Options] 响应头。默认情况下，Spring Security 使用以下头来禁止页面在 iframe 中渲染：

[source]
----
X-Frame-Options: DENY
----

[[headers-xss-protection]]
== X-XSS-Protection

[NOTE]
====
请参阅相关章节，了解如何为基于 xref:servlet/exploits/headers.adoc#servlet-headers-xss-protection[servlet] 和 xref:reactive/exploits/headers.adoc#webflux-headers-xss-protection[webflux] 的应用程序自定义默认设置。
====

一些浏览器内置了过滤 https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OWASP-DV-001)[反射型XSS攻击] 的功能。不过该功能已在主流浏览器中被弃用，目前 https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#x-xss-protection[OWASP建议] 明确将此头设为0。

默认情况下，Spring Security 使用以下头来阻止内容渲染：

[source]
----
X-XSS-Protection: 0
----


[[headers-csp]]
== 内容安全策略（CSP）

[NOTE]
====
请参阅相关章节，了解如何配置基于 xref:servlet/exploits/headers.adoc#servlet-headers-csp[servlet] 和 xref:reactive/exploits/headers.adoc#webflux-headers-csp[webflux] 的应用程序。
====

https://www.w3.org/TR/CSP2/[内容安全策略（CSP）] 是一种Web应用可用的机制，用于缓解内容注入漏洞（如跨站脚本攻击XSS）。CSP是一种声明式策略，使Web应用开发者能够声明并最终告知客户端（用户代理）哪些来源是预期加载资源的合法来源。

[NOTE]
====
内容安全策略并非用于解决所有内容注入漏洞，而是帮助减少内容注入攻击造成的损害。作为第一道防线，Web应用开发者仍应验证输入并对输出进行编码。
====

Web应用可通过在响应中包含以下任一HTTP头来使用CSP：

* `Content-Security-Policy`
* `Content-Security-Policy-Report-Only`

这些头用作向客户端传递安全策略的机制。安全策略包含一组安全策略指令，每条指令负责声明特定资源表示形式的限制。

例如，Web应用可以通过在响应中包含以下头，声明其仅从特定可信源加载脚本：

.内容安全策略示例
[source]
----
Content-Security-Policy: script-src https://trustedscripts.example.com
----

尝试从 `script-src` 指令未声明的源加载脚本时，用户代理将阻止该操作。此外，如果安全策略中声明了 https://www.w3.org/TR/CSP2/#directive-report-uri[report-uri] 指令，用户代理会将违规行为报告给指定的URL。

例如，当Web应用违反声明的安全策略时，以下响应头指示用户代理将违规报告发送至策略中 `report-uri` 指令指定的URL：

.带 report-uri 的内容安全策略
[source]
----
Content-Security-Policy: script-src https://trustedscripts.example.com; report-uri /csp-report-endpoint/
----

https://www.w3.org/TR/CSP2/#violation-reports[违规报告] 是标准的JSON结构，可通过Web应用自身的API或公开托管的CSP违规报告服务（如 https://report-uri.io/）捕获。

`Content-Security-Policy-Report-Only` 头允许开发者和管理员监控安全策略而非强制执行。该头通常用于实验或开发阶段制定安全策略。当策略被认为有效后，可改用 `Content-Security-Policy` 头字段强制执行。

以下响应头声明脚本可以从两个可能的源之一加载：

.内容安全策略（仅报告）
[source]
----
Content-Security-Policy-Report-Only: script-src 'self' https://trustedscripts.example.com; report-uri /csp-report-endpoint/
----

如果站点试图从 `evil.example.com` 加载脚本而违反策略，用户代理会向 `report-uri` 指令指定的URL发送违规报告，但仍允许加载违规资源。

为Web应用实施内容安全策略通常是一项复杂的任务。以下资源可能有助于你为网站制定有效的安全策略：

https://www.html5rocks.com/en/tutorials/security/content-security-policy/[内容安全策略简介]

https://developer.mozilla.org/en-US/docs/Web/Security/CSP[CSP指南 - Mozilla开发者网络]

https://www.w3.org/TR/CSP2/[W3C候选推荐]

[[headers-referrer]]
== 引用来源策略（Referrer Policy）

[NOTE]
====
请参阅相关章节，了解如何配置基于 xref:servlet/exploits/headers.adoc#servlet-headers-referrer[servlet] 和 xref:reactive/exploits/headers.adoc#webflux-headers-referrer[webflux] 的应用程序。
====

https://www.w3.org/TR/referrer-policy[引用来源策略（Referrer Policy）] 是一种Web应用可用于管理“引荐来源”字段的机制，该字段包含用户此前所在的页面。

Spring Security 的做法是使用 https://www.w3.org/TR/referrer-policy/[Referrer Policy] 响应头，该头支持多种 https://www.w3.org/TR/referrer-policy/#referrer-policies[策略]：

.Referrer Policy 示例
[source]
----
Referrer-Policy: same-origin
----

Referrer-Policy 响应头指示浏览器向目标站点透露用户之前所在的来源页面。

[[headers-feature]]
== 功能策略（Feature Policy）

[NOTE]
====
请参阅相关章节，了解如何配置基于 xref:servlet/exploits/headers.adoc#servlet-headers-feature[servlet] 和 xref:reactive/exploits/headers.adoc#webflux-headers-feature[webflux] 的应用程序。
====

https://wicg.github.io/feature-policy/[功能策略（Feature Policy）] 是一种机制，允许Web开发者选择性地启用、禁用或修改浏览器中某些API和功能的行为。

.Feature Policy 示例
[source]
----
Feature-Policy: geolocation 'self'
----

通过功能策略，开发者可以选择一组“策略”，由浏览器在其网站使用的特定功能上强制执行。这些策略限制了网站可访问的API，或修改某些功能的浏览器默认行为。

[[headers-permissions]]
== 权限策略（Permissions Policy）

[NOTE]
====
请参阅相关章节，了解如何配置基于 xref:servlet/exploits/headers.adoc#servlet-headers-permissions[servlet] 和 xref:reactive/exploits/headers.adoc#webflux-headers-permissions[webflux] 的应用程序。
====

https://w3c.github.io/webappsec-permissions-policy/[权限策略（Permissions Policy）] 是一种机制，允许Web开发者选择性地启用、禁用或修改浏览器中某些API和功能的行为。

.Permissions Policy 示例
[source]
----
Permissions-Policy: geolocation=(self)
----

通过权限策略，开发者可以选择一组“策略”，由浏览器在其网站使用的特定功能上强制执行。这些策略限制了网站可访问的API，或修改某些功能的浏览器默认行为。

[[headers-clear-site-data]]
== 清除站点数据（Clear Site Data）

[NOTE]
====
请参阅相关章节，了解如何配置基于 xref:servlet/exploits/headers.adoc#servlet-headers-clear-site-data[servlet] 和 xref:reactive/exploits/headers.adoc#webflux-headers-clear-site-data[webflux] 的应用程序。
====

https://www.w3.org/TR/clear-site-data/[清除站点数据（Clear Site Data）] 是一种机制，当HTTP响应包含此头时，可清除浏览器端的所有数据（如cookies、本地存储等）：

[source]
----
Clear-Site-Data: "cache", "cookies", "storage", "executionContexts"
----

这是一个理想的注销时清理操作。

[[headers-custom]]
== 自定义头

[NOTE]
====
请参阅相关章节，了解如何配置基于 xref:servlet/exploits/headers.adoc#servlet-headers-custom[servlet] 的应用程序。
====

Spring Security 提供了便捷的机制，以便将常见的安全头添加到你的应用中。此外，它还提供了钩子（hooks），支持添加自定义头。